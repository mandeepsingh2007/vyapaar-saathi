import asyncio
import copy
from datetime import date, datetime, timedelta
import logging
import os
import re
import urllib.parse
from threading import Thread

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from dotenv import load_dotenv
from flask import Flask, request, send_from_directory
from fuzzywuzzy import fuzz
from openai import OpenAI
from pydub import AudioSegment
import requests
from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_fixed
from twilio.rest import Client
from twilio.twiml.messaging_response import MessagingResponse
from twilio.twiml.voice_response import VoiceResponse
# import google.generativeai as genai # Removed Google Generative AI import

from call_handler import initiate_outbound_call
from data_extractor import (
    extract_items_from_bill_image,
    extract_structured_data,
    transcribe_audio,
)
from supabase_client import (
    get_daily_sales_summary,
    get_low_stock_items,
    get_stock_levels,
    get_user_transactions_summary,
    save_transaction,
    supabase,
    update_stock_item,
    get_all_unique_user_ids_with_stock,
)
from weather_events_api import get_weather_forecast, get_festivals_from_llm

# FFmpeg path configuration
ffmpeg_bin_path = r"C:\Users\singh\Downloads\ffmpeg-8.0-essentials_build\ffmpeg-8.0-essentials_build\bin"
if ffmpeg_bin_path not in os.environ["PATH"]:
    os.environ["PATH"] += os.pathsep + ffmpeg_bin_path
    print(f"DEBUG: Added {ffmpeg_bin_path} to PATH for Flask app.")

load_dotenv()

# !! IMPORTANT !!
# Replace this with your actual public URL (e.g., from ngrok or your deployed server)
BASE_URL = "https://523af0195609.ngrok-free.app"

SHOPKEEPER_LOCATION = {"latitude": 28.7041, "longitude": 77.1025} # Default to Delhi, India
DEFAULT_LANGUAGE = "hi" # Define default language

client = OpenAI() # Re-initialize OpenAI client
# Removed Google Generative AI client configuration
# genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
# gemini_model = genai.GenerativeModel("gemini-2.5-pro") # Removed Gemini model initialization

app = Flask(__name__)
scheduler = AsyncIOScheduler() # Initialize scheduler here

TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID")
TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")
TWILIO_WHATSAPP_NUMBER = os.getenv("TWILIO_WHATSAPP_NUMBER")
TWILIO_PHONE_NUMBER = os.getenv("TWILIO_PHONE_NUMBER") # Twilio Voice enabled phone number
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

twilio_client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)

# Configure logging
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

language_map = {"en": "en", "english": "en", "hi": "hi", "hindi": "hi",
                "pa": "pa", "punjabi": "pa", "gu": "gu", "gujarati": "gu",
                "ta": "ta", "tamil": "ta", "te": "te", "telugu": "te",
                "bn": "bn", "bengali": "bn", "mr": "mr", "marathi": "mr",
                "ur": "hi", "urdu": "hi"}

MESSAGES = {
    "en": {
        "sale_success": "‚úÖ Sale of ‚Çπ{amount:.2f} recorded for:\n{item_details}",
        "sale_success_no_item": "‚úÖ Sale of ‚Çπ{amount:.2f} added to your records.",
        "expense_success": "‚úÖ Expense of ‚Çπ{amount} ({item}) recorded.",
        "expense_success_no_item": "‚úÖ Expense of ‚Çπ{amount} recorded.",
        "balance_inquiry": "üìä Your current digital khata balance is ‚Çπ{balance:.2f}.\n\nRecent Transactions:\n{transactions_summary}",
        "earnings_summary": "üìà Today's total sales: ‚Çπ{total_sales:.2f}.\n\nToday's transactions:\n{sales_details}",
        "extract_fail": "Could not extract structured data from your message. Please be more specific (e.g., 'Sold 1kg sugar for 50 rupees').",
        "transcribe_fail": "Could not understand your voice note. The audio quality might be poor or not in a supported language.",
        "download_fail": "Failed to download your voice note: {error_msg}. Please try again.",
        "network_error": "A network error occurred while downloading your voice note: {error_msg}. Please try again.",
        "file_error": "There was an issue with the voice note file: {error_msg}. Please try sending it again.",
        "unexpected_error": "An unexpected error occurred while processing your voice note. Please try again.",
        "no_voice_note": "Please send a voice note for transaction processing or a text message for balance inquiry.",
        "unsupported_media": "Unsupported media type: {media_type}. Please send a voice note or an image.",
        "no_transactions_found": "No recent transactions found.",
        "no_sales_found_today": "No sales found today.",
        "image_received_stock_update": "Image received! Processing for stock update...",
        "stock_update_success": "‚úÖ Stock updated successfully for: {updates}.",
        "stock_update_fail": "‚ùå Failed to update stock from image. Error: {error_msg}",
        "file_download_error": "Failed to download your image: {error_msg}. Please try again.",
        "welcome": "Hello! I'm your inventory management bot. How can I help you?",
        "stock_updated": "Stock for {item_name} updated successfully. Current quantity: {current_quantity} {unit}.",
        "sale_recorded": "Sale of {quantity} {unit} of {item_name} recorded. Remaining stock: {current_quantity} {unit}. Total sale amount: {selling_amount}. Profit: {profit}.",
        "purchase_recorded": "Purchase of {quantity} {unit} of {item_name} recorded. New stock: {current_quantity} {unit}. Cost: {cost_price_per_unit} per {unit}.",
        "item_not_found": "'{item_name}' not found in stock. Would you like to add it?",
        "unknown_command": "I didn't understand that. Please try again or type 'help'.",
        "current_stock": "Current stock for {item_name}: {current_quantity} {unit}.",
        "all_stock_items": "Your current stock:\n{stock_list}",
        "daily_summary": "Daily Sales Summary for {date}:\nTotal Sales: {total_sales}\nTotal Profit: {total_profit}\n{sales_details}",
        "low_stock_alert": "‚ö†Ô∏è Low stock alert! The following items are running low:\n{low_stock_items_list}\nPlease consider ordering soon.",
        "call_initiated": "Initiating call to {supplier_name} at {supplier_phone_number} for {quantity} {unit} of {item_name}. I will notify you once the order is confirmed.",
        "order_confirmation_prompt": "Which item and supplier would you like to confirm an order for? Example: 'Order 10 kg rice from Supplier A'.",
        "order_confirmed_shopkeeper": "‚úÖ Order for {quantity} {unit} of {item_name} from {supplier_name} confirmed. Expect delivery in 2 days.",
        "order_failed_shopkeeper": "‚ùå Failed to confirm order for {item_name} from {supplier_name}. Reason: {reason}"
    },
    "hi": {
        "sale_success": "‚úÖ ‚Çπ{amount:.2f} ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§¶‡§∞‡•ç‡§ú ‡§ï‡•Ä ‡§ó‡§à:\n{item_details}",
        "sale_success_no_item": "‚úÖ ‡§Ü‡§™‡§ï‡•á ‡§°‡§ø‡§ú‡§ø‡§ü‡§≤ ‡§ñ‡§æ‡§§‡•á ‡§Æ‡•á‡§Ç ‚Çπ{amount:.2f} ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§¶‡§∞‡•ç‡§ú ‡§ï‡•Ä ‡§ó‡§à‡•§",
        "expense_success": "‚úÖ ‡§Ü‡§™‡§ï‡•á ‡§°‡§ø‡§ú‡§ø‡§ü‡§≤ ‡§ñ‡§æ‡§§‡•á ‡§Æ‡•á‡§Ç ‚Çπ{amount} ({item}) ‡§ï‡§æ ‡§ñ‡§∞‡•ç‡§ö ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§",
        "expense_success_no_item": "‚úÖ ‡§Ü‡§™‡§ï‡•á ‡§°‡§ø‡§ú‡§ø‡§ü‡§≤ ‡§ñ‡§æ‡§§‡•á ‡§Æ‡•á‡§Ç ‚Çπ{amount} ‡§ï‡§æ ‡§ñ‡§∞‡•ç‡§ö ‡§¶‡§∞‡•ç‡§ú ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§",
        "balance_inquiry": "üìä ‡§Ü‡§™‡§ï‡•á ‡§°‡§ø‡§ú‡§ø‡§ü‡§≤ ‡§ñ‡§æ‡§§‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∂‡•á‡§∑ ‡§∞‡§æ‡§∂‡§ø ‚Çπ{balance:.2f} ‡§π‡•à‡•§\n\n‡§™‡§ø‡§õ‡§≤‡•á ‡§≤‡•á‡§®‡§¶‡•á‡§®:\n{transactions_summary}",
        "earnings_summary": "üìà ‡§Ü‡§ú ‡§ï‡•Ä ‡§ï‡•Å‡§≤ ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä: ‚Çπ{total_sales:.2f}‡•§\n\n‡§Ü‡§ú ‡§ï‡•á ‡§≤‡•á‡§®‡§¶‡•á‡§®:\n{sales_details}",
        "extract_fail": "‡§Ü‡§™‡§ï‡•á ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§∏‡•á ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§®‡§ø‡§ï‡§æ‡§≤‡•Ä ‡§ú‡§æ ‡§∏‡§ï‡•Ä‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§ß‡§ø‡§ï ‡§µ‡§ø‡§∂‡§ø‡§∑‡•ç‡§ü ‡§∞‡§π‡•á‡§Ç (‡§â‡§¶‡§æ‡§π‡§∞‡§£ ‡§ï‡•á ‡§≤‡§ø‡§è, '50 ‡§∞‡•Å‡§™‡§Ø‡•á ‡§Æ‡•á‡§Ç 1 ‡§ï‡§ø‡§≤‡•ã ‡§ö‡•Ä‡§®‡•Ä ‡§¨‡•á‡§ö‡•Ä')‡•§",
        "transcribe_fail": "‡§Ü‡§™‡§ï‡•á ‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§ï‡•ã ‡§∏‡§Æ‡§ù‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§ú‡§æ ‡§∏‡§ï‡§æ‡•§ ‡§ë‡§°‡§ø‡§Ø‡•ã ‡§ó‡•Å‡§£‡§µ‡§§‡•ç‡§§‡§æ ‡§ñ‡§∞‡§æ‡§¨ ‡§π‡•ã ‡§∏‡§ï‡§§‡•Ä ‡§π‡•à ‡§Ø‡§æ ‡§Ø‡§π ‡§∏‡§Æ‡§∞‡•ç‡§•‡§ø‡§§ ‡§≠‡§æ‡§∑‡§æ ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§",
        "download_fail": "‡§Ü‡§™‡§ï‡§æ ‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡§æ: {error_msg}‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "network_error": "‡§Ü‡§™‡§ï‡§æ ‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡§§‡•á ‡§∏‡§Æ‡§Ø ‡§®‡•á‡§ü‡§µ‡§∞‡•ç‡§ï ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à: {error_msg}‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "file_error": "‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§´‡§º‡§æ‡§á‡§≤ ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§•‡•Ä: {error_msg}‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§á‡§∏‡•á ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§≠‡•á‡§ú‡•á‡§Ç‡•§",
        "unexpected_error": "‡§è‡§ï ‡§Ö‡§™‡•ç‡§∞‡§§‡•ç‡§Ø‡§æ‡§∂‡§ø‡§§ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "no_voice_note": "‡§ï‡•É‡§™‡§Ø‡§æ ‡§≤‡•á‡§®‡§¶‡•á‡§® ‡§ï‡•á ‡§≤‡§ø‡§è ‡§è‡§ï ‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§≠‡•á‡§ú‡•á‡§Ç ‡§Ø‡§æ ‡§∂‡•á‡§∑ ‡§∞‡§æ‡§∂‡§ø ‡§ú‡§æ‡§®‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§",
        "unsupported_media": "‡§Ö‡§∏‡§Æ‡§∞‡•ç‡§•‡§ø‡§§ ‡§Æ‡•Ä‡§°‡§ø‡§Ø‡§æ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞: {media_type}‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§µ‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§Ø‡§æ ‡§è‡§ï ‡§á‡§Æ‡•á‡§ú ‡§≠‡•á‡§ú‡•á‡§Ç‡•§",
        "no_transactions_found": "‡§ï‡•ã‡§à ‡§π‡§æ‡§≤‡§ø‡§Ø‡§æ ‡§≤‡•á‡§®‡§¶‡•á‡§® ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§",
        "no_sales_found_today": "‡§Ü‡§ú ‡§ï‡•ã‡§à ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§¶‡§∞‡•ç‡§ú ‡§®‡§π‡•Ä‡§Ç ‡§ï‡•Ä ‡§ó‡§à‡•§",
        "image_received_stock_update": "‡§õ‡§µ‡§ø ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§π‡•Å‡§à! ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è ‡§™‡•ç‡§∞‡§∏‡§Ç‡§∏‡•ç‡§ï‡§∞‡§£ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à...",
        "stock_update_success": "‚úÖ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ: {updates}.",
        "stock_update_fail": "‚ùå ‡§õ‡§µ‡§ø ‡§∏‡•á ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§µ‡§ø‡§´‡§≤‡•§ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø: {error_msg}",
        "file_download_error": "‡§Ü‡§™‡§ï‡•Ä ‡§õ‡§µ‡§ø ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡•Ä: {error_msg}‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "welcome": "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§á‡§®‡•ç‡§µ‡•á‡§Ç‡§ü‡•ç‡§∞‡•Ä ‡§™‡•ç‡§∞‡§¨‡§Ç‡§ß‡§® ‡§¨‡•â‡§ü ‡§π‡•Ç‡§Å‡•§ ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§ï‡•à‡§∏‡•á ‡§Æ‡§¶‡§¶ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•Ä ‡§π‡•Ç‡§Å?",
        "stock_updated": "{item_name} ‡§ï‡§æ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§ ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§Æ‡§æ‡§§‡•ç‡§∞‡§æ: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} ‡§ï‡•Ä ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§¶‡§∞‡•ç‡§ú ‡§ï‡•Ä ‡§ó‡§à‡•§ ‡§∂‡•á‡§∑ ‡§∏‡•ç‡§ü‡•â‡§ï: {current_quantity} {unit}. ‡§ï‡•Å‡§≤ ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§∞‡§æ‡§∂‡§ø: {selling_amount}. ‡§≤‡§æ‡§≠: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} ‡§ï‡•Ä ‡§ñ‡§∞‡•Ä‡§¶ ‡§¶‡§∞‡•ç‡§ú ‡§ï‡•Ä ‡§ó‡§à‡•§ ‡§®‡§Ø‡§æ ‡§∏‡•ç‡§ü‡•â‡§ï: {current_quantity} {unit}. ‡§≤‡§æ‡§ó‡§§: {cost_price_per_unit} ‡§™‡•ç‡§∞‡§§‡§ø {unit}.",
        "item_not_found": "'{item_name}' ‡§Ü‡§á‡§ü‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§á‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á?",
        "unknown_command": "‡§Æ‡•Å‡§ù‡•á ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§Ø‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ '‡§∏‡§π‡§æ‡§Ø‡§§‡§æ' ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "current_stock": "{item_name} ‡§ï‡§æ ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡•ç‡§ü‡•â‡§ï: {current_quantity} {unit}.",
        "all_stock_items": "‡§Ü‡§™‡§ï‡§æ ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡•ç‡§ü‡•â‡§ï:\n{stock_list}",
        "daily_summary": "{date} ‡§ï‡•á ‡§≤‡§ø‡§è ‡§¶‡•à‡§®‡§ø‡§ï ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂:\n‡§ï‡•Å‡§≤ ‡§¨‡§ø‡§ï‡•ç‡§∞‡•Ä: {total_sales}\n‡§ï‡•Å‡§≤ ‡§≤‡§æ‡§≠: {total_profit}\n{sales_details}",
        "low_stock_alert": "‚ö†Ô∏è ‡§ï‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡•Ä! ‡§®‡§ø‡§Æ‡•ç‡§®‡§≤‡§ø‡§ñ‡§ø‡§§ ‡§Ü‡§á‡§ü‡§Æ ‡§ï‡§Æ ‡§π‡•ã ‡§∞‡§π‡•á ‡§π‡•à‡§Ç:\n{low_stock_items_list}\n‡§ú‡§≤‡•ç‡§¶ ‡§π‡•Ä ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡§∞‡§®‡•á ‡§™‡§∞ ‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "call_initiated": "‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Æ‡•à‡§Ç ‡§ó‡•Å‡§™‡•ç‡§§‡§æ ‡§ï‡§ø‡§∞‡§æ‡§®‡§æ ‡§∏‡•ç‡§ü‡•ã‡§∞ ‡§∏‡•á ‡§∞‡§Æ‡§æ ‡§¨‡§æ‡§§ ‡§ï‡§∞ ‡§∞‡§π‡•Ä ‡§π‡•Ç‡§Å‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Æ‡•à‡§Ç {supplier_name} ‡§∏‡•á ‡§¨‡§æ‡§§ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•Ä ‡§π‡•Ç‡§Å?",
        "order_confirmation_prompt": "‡§Ü‡§™ ‡§ï‡§ø‡§∏ ‡§Ü‡§á‡§ü‡§Æ ‡§î‡§∞ ‡§Ü‡§™‡•Ç‡§∞‡•ç‡§§‡§ø‡§ï‡§∞‡•ç‡§§‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á? ‡§â‡§¶‡§æ‡§π‡§∞‡§£: '‡§∏‡§™‡•ç‡§≤‡§æ‡§Ø‡§∞ ‡§è ‡§∏‡•á 10 ‡§ï‡§ø‡§≤‡•ã ‡§ö‡§æ‡§µ‡§≤ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡§∞‡•á‡§Ç'‡•§",
        "order_confirmed_shopkeeper": "‚úÖ {item_name} ‡§ï‡•á {quantity} {unit} ‡§ï‡§æ {supplier_name} ‡§∏‡•á ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§™‡•Å‡§∑‡•ç‡§ü ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§ ‡§°‡§ø‡§≤‡•Ä‡§µ‡§∞‡•Ä 2 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§Ö‡§™‡•á‡§ï‡•ç‡§∑‡§ø‡§§ ‡§π‡•à‡•§",
        "order_failed_shopkeeper": "‚ùå Failed to confirm order for {item_name} from {supplier_name}. Reason: {reason}"
    },
    "pa": { # Punjabi messages
        "sale_success": "‚úÖ ‡®§‡©Å‡®π‡®æ‡®°‡©á ‡®°‡®ø‡®ú‡©Ä‡®ü‡®≤ ‡®ñ‡®æ‡®§‡©á ‡®µ‡®ø‡©±‡®ö ‚Çπ{amount:.2f} ({item}) ‡®¶‡©Ä ‡®µ‡®ø‡®ï‡®∞‡©Ä ‡®¶‡®∞‡®ú ‡®ï‡©Ä‡®§‡©Ä ‡®ó‡®à‡•§",
        "sale_success_no_item": "‚úÖ ‡®§‡©Å‡®π‡®æ‡®°‡©á ‡®°‡®ø‡®ú‡©Ä‡®ü‡®≤ ‡®ñ‡®æ‡®§‡©á ‡®µ‡®ø‡©±‡®ö ‚Çπ{amount:.2f} ‡®¶‡©Ä ‡®µ‡®ø‡®ï‡®∞‡©Ä ‡®¶‡®∞‡®ú ‡®ï‡©Ä‡®§‡©Ä ‡®ó‡®à‡•§",
        "expense_success": "‚úÖ ‡®§‡©Å‡®π‡®æ‡®°‡©á ‡®°‡®ø‡®ú‡©Ä‡®ü‡®≤ ‡®ñ‡®æ‡®§‡©á ‡®µ‡®ø‡©±‡®ö ‚Çπ{amount} ({item}) ‡®¶‡®æ ‡®ñ‡®∞‡®ö ‡®¶‡®∞‡®ú ‡®ï‡©Ä‡®§‡®æ ‡®ó‡®ø‡®Ü‡•§",
        "expense_success_no_item": "‚úÖ ‡®§‡©Å‡®π‡®æ‡®°‡©á ‡®°‡®ø‡®ú‡©Ä‡®ü‡®≤ ‡®ñ‡®æ‡®§‡©á ‡®µ‡®ø‡©±‡®ö ‚Çπ{amount} ‡®¶‡®æ ‡®ñ‡®∞‡®ö ‡®¶‡®∞‡®ú ‡®ï‡©Ä‡®§‡®æ ‡®ó‡®ø‡®Ü‡•§",
        "balance_inquiry": "üìä ‡®§‡©Å‡®π‡®æ‡®°‡©á ‡®°‡®ø‡®ú‡©Ä‡®ü‡®≤ ‡®ñ‡®æ‡®§‡©á ‡®µ‡®ø‡©±‡®ö ‡®µ‡®∞‡®§‡®Æ‡®æ‡®® ‡®¨‡®ï‡®æ‡®á‡®Ü ‚Çπ{balance:.2f} ‡®π‡©à‡•§\n\n‡®™‡®ø‡®õ‡®≤‡©á ‡®≤‡©à‡®£-‡®¶‡©á‡®£:\n{transactions_summary}",
        "extract_fail": "‡®§‡©Å‡®π‡®æ‡®°‡©á ‡®∏‡©Å‡®®‡©á‡®π‡©á ‡®§‡©ã‡®Ç ‡®ú‡®æ‡®£‡®ï‡®æ‡®∞‡©Ä ‡®®‡®π‡©Ä‡®Ç ‡®ï‡©±‡®¢‡©Ä ‡®ú‡®æ ‡®∏‡®ï‡©Ä‡•§ ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®∏‡®™‡®∏‡®º‡®ü ‡®¨‡©ã‡®≤‡©ã‡•§",
        "transcribe_fail": "‡®§‡©Å‡®π‡®æ‡®°‡©á ‡®µ‡©å‡®á‡®∏ ‡®®‡©ã‡®ü ‡®®‡©Ç‡©∞ ‡®ü‡©ç‡®∞‡®æ‡®Ç‡®∏‡®ï‡©ç‡®∞‡®æ‡®à‡®¨ ‡®ú‡®æ‡®Ç ‡®Ö‡®®‡©Å‡®µ‡®æ‡®¶ ‡®®‡®π‡©Ä‡®Ç ‡®ï‡©Ä‡®§‡®æ ‡®ú‡®æ ‡®∏‡®ï‡®ø‡®Ü‡•§ ‡®Ü‡®°‡©Ä‡®ì ‡®ó‡©Å‡®£‡®µ‡©±‡®§‡®æ ‡®ñ‡®∞‡®æ‡®¨ ‡®π‡©ã ‡®∏‡®ï‡®¶‡©Ä ‡®π‡©à‡•§",
        "download_fail": "‡®§‡©Å‡®π‡®æ‡®°‡®æ ‡®µ‡©å‡®á‡®∏ ‡®®‡©ã‡®ü ‡®°‡®æ‡®ä‡®®‡®≤‡©ã‡®° ‡®®‡®π‡©Ä‡®Ç ‡®π‡©ã ‡®∏‡®ï‡®ø‡®Ü: {error_msg}‡•§ ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®¶‡©Å‡®¨‡®æ‡®∞‡®æ ‡®ï‡©ã‡®∏‡®º‡®ø‡®∏‡®º ‡®ï‡®∞‡©ã‡•§",
        "network_error": "‡®§‡©Å‡®π‡®æ‡®°‡®æ ‡®µ‡©å‡®á‡®∏ ‡§®‡•ã‡§ü ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡§§‡•á ‡§∏‡§Æ‡§Ø ‡§®‡•á‡§ü‡§µ‡§∞‡•ç‡§ï ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à: {error_msg}‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "file_error": "‡®µ‡©å‡®á‡®∏ ‡®®‡©ã‡®ü ‡®´‡®æ‡®à‡®≤ ‡®µ‡®ø‡©±‡®ö ‡®∏‡®Æ‡©±‡®∏‡®ø‡®Ü ‡®∏‡©Ä: {error_msg}‡•§ ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®á‡®∏‡®®‡©Ç‡©∞ ‡®´‡®ø‡®∞ ‡®§‡©ã‡®Ç ‡®≠‡©á‡®ú‡©ã‡•§",
        "unexpected_error": "‡®§‡©Å‡®π‡®æ‡®°‡©á ‡®µ‡©å‡®á‡®∏ ‡®®‡©ã‡®ü ‡®®‡©Ç‡©∞ ‡®™‡©ç‡®∞‡©ã‡®∏‡©à‡®∏ ‡®ï‡®∞‡®¶‡©á ‡®∏‡®Æ‡©á‡®Ç ‡®á‡©±‡®ï ‡®Ö‡®£‡®ï‡®ø‡®Ü‡®∏‡©Ä ‡®ó‡®≤‡®§‡©Ä ‡®π‡©ã‡®à‡•§ ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®¶‡©Å‡®¨‡®æ‡®∞‡®æ ‡®ï‡©ã‡®∏‡®º‡®ø‡®∏‡®º ‡®ï‡®∞‡©ã‡•§",
        "no_voice_note": "‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®ü‡©ç‡®∞‡®æ‡®Ç‡®ú‡©à‡®ï‡®∏‡®º‡®® ‡®™‡©ç‡®∞‡©ã‡®∏‡©à‡®∏‡®ø‡©∞‡®ó ‡®≤‡®à ‡®á‡©±‡®ï ‡®µ‡©å‡®á‡®∏ ‡®®‡©ã‡®ü ‡®≠‡©á‡®ú‡©ã ‡®ú‡®æ‡®Ç ‡®¨‡®ï‡®æ‡®á‡®Ü ‡®™‡©Å‡©±‡®õ‡®£ ‡®≤‡®à ‡®á‡©±‡®ï ‡®ü‡©à‡®ï‡®∏‡®ü ‡®∏‡©Å‡®®‡©á‡®π‡®æ ‡®≠‡©á‡®ú‡©ã‡•§",
        "unsupported_media": "‡®Ö‡®∏‡®Æ‡®∞‡®•‡®ø‡®§ ‡®Æ‡©Ä‡®°‡©Ä‡®Ü ‡®ï‡®ø‡®∏‡®Æ: {media_type}‡•§ ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®á‡©±‡®ï ‡®µ‡©å‡®á‡®∏ ‡®®‡©ã‡®ü ‡®ú‡®æ‡®Ç ‡®á‡©±‡®ï ‡®ö‡®ø‡©±‡®§‡®∞ ‡®≠‡©á‡®ú‡©ã‡•§",
        "no_transactions_found": "‡®ï‡©ã‡®à ‡®π‡®æ‡®≤‡©Ä‡®Ü ‡®≤‡©à‡®£-‡®¶‡©á‡®£ ‡®®‡®π‡©Ä‡®Ç ‡®Æ‡®ø‡®≤‡®ø‡®Ü‡•§",
        "image_received_stock_update": "‡®§‡®∏‡®µ‡©Ä‡®∞ ‡®™‡©ç‡®∞‡®æ‡®™‡®§ ‡®π‡©ã‡®à! ‡®∏‡®ü‡®æ‡®ï ‡®Ö‡©±‡®™‡®°‡©á‡®ü ‡®≤‡®à ‡®™‡©ç‡®∞‡®ï‡®ø‡®∞‡®ø‡®Ü ‡®ï‡©Ä‡®§‡©Ä ‡®ú‡®æ ‡®∞‡®π‡©Ä ‡®π‡©à...",
        "stock_update_success": "‚úÖ ‡®∏‡®ü‡®æ‡®ï ‡®∏‡®´‡®≤‡®§‡®æ‡©ç‡®™‡©Ç‡®∞‡©ç‡®µ‡®ï ‡®Ö‡©±‡®™‡®°‡©á‡®ü ‡®ï‡©Ä‡®§‡®æ ‡®ó‡®ø‡®Ü: {updates}.",
        "stock_update_fail": "‚ùå ‡®§‡®∏‡®µ‡©Ä‡®∞ ‡®§‡©ã‡®Ç ‡®∏‡®ü‡®æ‡®ï ‡®Ö‡©±‡®™‡®°‡©á‡®ü ‡®ï‡®∞‡®® ‡®µ‡®ø‡©±‡®ö ‡®Ö‡®∏‡®´‡®≤‡•§ ‡®ó‡®≤‡®§‡©Ä: {error_msg}",
        "file_download_error": "‡®§‡©Å‡®π‡®æ‡®°‡©Ä ‡®§‡®∏‡®µ‡©Ä‡®∞ ‡®°‡®æ‡®ä‡®®‡®≤‡©ã‡®° ‡®®‡®π‡©Ä‡®Ç ‡§π‡©ã ‡®∏‡®ï‡©Ä: {error_msg}‡•§ ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®¶‡©Å‡®¨‡®æ‡®∞‡®æ ‡®ï‡©ã‡®∏‡®º‡®ø‡®∏‡®º ‡®ï‡®∞‡©ã‡•§",
        "welcome": "‡®∏‡®§ ‡®∏‡©ç‡®∞‡©Ä ‡®Ö‡®ï‡®æ‡®≤! ‡®Æ‡©à‡®Ç ‡®§‡©Å‡®π‡®æ‡®°‡®æ ‡®á‡®®‡®µ‡©à‡®Ç‡®ü‡®∞‡©Ä ‡®™‡©ç‡®∞‡®¨‡©∞‡®ß‡®® ‡®¨‡©ã‡®ü ‡®π‡®æ‡®Ç‡•§ ‡®Æ‡©à‡®Ç ‡®§‡©Å‡®π‡®æ‡®°‡©Ä ‡®ï‡®ø‡µΩ ‡®Æ‡®¶‡®¶ ‡®ï‡®∞ ‡®∏‡®ï‡®¶‡®æ ‡®π‡®æ‡®Ç?",
        "stock_updated": "{item_name} ‡®¶‡®æ ‡®∏‡®ü‡®æ‡®ï ‡®∏‡®´‡®≤‡®§‡®æ‡®™‡©Ç‡®∞‡®µ‡®ï ‡®Ö‡©±‡®™‡®°‡©á‡®ü ‡®ï‡©Ä‡®§‡®æ ‡®ó‡®ø‡®Ü‡•§ ‡®Æ‡©å‡®ú‡©Ç‡®¶‡®æ ‡®Æ‡®æ‡®§‡®∞‡®æ: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} ‡®¶‡©Ä ‡®µ‡®ø‡®ï‡®∞‡©Ä ‡®¶‡®∞‡®ú ‡®ï‡©Ä‡®§‡©Ä ‡®ó‡®à‡•§ ‡®¨‡®æ‡®ï‡©Ä ‡®∏‡®ü‡®æ‡®ï: {current_quantity} {unit}. ‡®ï‡©Å‡©±‡®≤ ‡®µ‡®ø‡®ï‡®∞‡©Ä ‡®∞‡®æ‡®∏‡®º‡©Ä: {selling_amount}. ‡®≤‡®æ‡®≠: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} ‡®¶‡©Ä ‡®ñ‡®∞‡©Ä‡®¶ ‡®¶‡®∞‡®ú ‡®ï‡©Ä‡®§‡©Ä ‡®ó‡®à‡•§ ‡®®‡®µ‡´ã ‡®∏‡®ü‡®æ‡®ï: {current_quantity} {unit}. ‡®≤‡®æ‡®ó‡®§: {cost_price_per_unit} ‡®™‡©ç‡®∞‡®§‡©Ä {unit}.",
        "item_not_found": "'{item_name}' ‡®∏‡®ü‡®æ‡®ï ‡®µ‡®ø‡©±‡®ö ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡©Ä. ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§á‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á?",
        "unknown_command": "‡®Æ‡©à‡®®‡©Ç‡©∞ ‡®∏‡®Æ‡®ù ‡®®‡®π‡©Ä‡®Ç ‡®Ü‡®á‡®Ü‡•§ ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ '‡§∏‡§π‡§æ‡§Ø‡§§‡§æ' ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "current_stock": "{item_name} ‡®¶‡®æ ‡®Æ‡©å‡®ú‡©Ç‡®¶‡®æ ‡®∏‡®ü‡®æ‡®ï: {current_quantity} {unit}.",
        "all_stock_items": "‡®§‡©Å‡®π‡®æ‡®°‡®æ ‡®Æ‡©å‡®ú‡©Ç‡®¶‡®æ ‡®∏‡®ü‡®æ‡®ï:\n{stock_list}",
        "daily_summary": "{date} ‡®≤‡®à ‡®∞‡©ã‡®ú‡®º‡®æ‡®®‡®æ ‡®µ‡®ø‡®ï‡®∞‡©Ä ‡®∏‡©∞‡®ñ‡©á‡®™:\n‡®ï‡©Å‡©±‡®≤ ‡®µ‡®ø‡®ï‡®∞‡©Ä: {total_sales}\n‡®ï‡©Å‡©±‡®≤ ‡®≤‡®æ‡®≠: {total_profit}\n{sales_details}",
        "low_stock_alert": "‚ö†Ô∏è ‡®ò‡©±‡®ü ‡®∏‡®ü‡®æ‡®ï ‡®ö‡©á‡®§‡®æ‡®µ‡®®‡©Ä! ‡®π‡©á‡®†‡®æ‡®Ç ‡®¶‡®ø‡©±‡®§‡©Ä‡®Ü‡®Ç ‡®ö‡©Ä‡®ú‡®º‡®æ‡®Ç ‡®ò‡©±‡®ü ‡®π‡©ã ‡®∞‡®π‡©Ä‡®Ü‡®Ç ‡®π‡®®:\n{low_stock_items_list}\n‡®ú‡®≤‡®¶‡©Ä ‡®π‡©Ä ‡®Ü‡®∞‡®°‡®∞ ‡®ï‡®∞‡®® ‡®¨‡®æ‡®∞‡©á ‡®µ‡®ø‡®ö‡®æ‡®∞ ‡®ï‡®∞‡©ã‡•§",
        "call_initiated": "{item_name} ‡®¶‡©á {quantity} {unit} ‡®≤‡®à {supplier_name} ({supplier_phone_number}) ‡®®‡©Ç‡©∞ ‡®ï‡®æ‡®≤ ‡®ï‡©Ä‡®§‡®æ ‡®ú‡®æ ‡®∞‡®ø‡®π‡®æ ‡®π‡©à‡•§ ‡®Ü‡®∞‡®°‡®∞ ‡®¶‡©Ä ‡®™‡©Å‡®∏‡®º‡®ü‡©Ä ‡®π‡©ã‡®£ '‡®§‡©á ‡®Æ‡©à‡®Ç ‡®§‡©Å‡®π‡®æ‡®®‡©Ç‡©∞ ‡§∏‡•Ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§",
        "order_confirmation_prompt": "‡§Ü‡§™ ‡§ï‡§ø‡§∏ ‡§Ü‡§á‡§ü‡§Æ ‡§î‡§∞ ‡§Ü‡§™‡•Ç‡§∞‡•ç‡§§‡§ø‡§ï‡§∞‡•ç‡§§‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á? ‡§â‡§¶‡§æ‡§π‡§∞‡§£: '‡§∏‡§™‡•ç‡§≤‡§æ‡§Ø‡§∞ ‡§è ‡§∏‡•á 10 ‡§ï‡§ø‡§≤‡•ã ‡§ö‡§æ‡§µ‡§≤ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡§∞‡•á‡§Ç'‡•§",
        "order_confirmed_shopkeeper": "‚úÖ {item_name} ‡§ï‡•á {quantity} {unit} ‡§ï‡§æ {supplier_name} ‡§∏‡•á ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§™‡•Å‡§∑‡•ç‡§ü ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§™‡§°‡•á‡§ü ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§ ‡§°‡§ø‡§≤‡•Ä‡§µ‡§∞‡•Ä 2 ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§Ö‡§™‡•á‡§ï‡•ç‡§∑‡§ø‡§§ ‡§π‡•à‡•§",
        "order_failed_shopkeeper": "‚ùå Failed to confirm order for {item_name} from {supplier_name}. Reason: {reason}"
    },
    "gu": { # Gujarati messages
        "sale_success": "‚úÖ ‡™§‡™Æ‡™æ‡™∞‡™æ ‡™°‡™ø‡™ú‡™ø‡™ü‡™≤ ‡™ñ‡™æ‡™§‡™æ‡™Æ‡™æ‡™Ç ‚Çπ{amount:.2f} ({item}) ‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£ ‡™®‡´ã‡™Ç‡™ß‡™æ‡™à ‡™õ‡´á.",
        "sale_success_no_item": "‚úÖ ‡™§‡™Æ‡™æ‡™∞‡™æ ‡™°‡™ø‡™ú‡™ø‡™ü‡™≤ ‡™ñ‡™æ‡™§‡™æ‡™Æ‡™æ‡™Ç ‚Çπ{amount:.2f} ‡™®‡´Ä ‡™µ‡´á‡™ö‡™æ‡™£ ‡™®‡´ã‡™Ç‡™ß‡™æ‡™à ‡™õ‡´á.",
        "expense_success": "‚úÖ ‡™§‡™Æ‡™æ‡™∞‡™æ ‡™°‡™ø‡™ú‡™ø‡™ü‡™≤ ‡™ñ‡™æ‡™§‡™æ‡™Æ‡™æ‡™Ç ‚Çπ{amount} ({item}) ‡™®‡´ã ‡™ñ‡™∞‡´ç‡™ö ‡™®‡´ã‡™Ç‡™ß‡™æ‡™Ø‡´ã ‡™õ‡´á.",
        "expense_success_no_item": "‚úÖ ‡™§‡™Æ‡™æ‡™∞‡™æ ‡™°‡™ø‡™ú‡™ø‡™ü‡™≤ ‡™ñ‡™æ‡™§‡™æ‡™Æ‡™æ‡™Ç ‚Çπ{amount} ‡™®‡´ã ‡™ñ‡™∞‡´ç‡™ö ‡™®‡´ã‡™Ç‡™ß‡™æ‡™Ø‡´ã ‡™õ‡´á.",
        "balance_inquiry": "üìä ‡™§‡™Æ‡™æ‡™∞‡™æ ‡™°‡™ø‡™ú‡™ø‡™ü‡™≤ ‡™ñ‡™æ‡™§‡™æ‡™Æ‡™æ‡™Ç ‡™µ‡™∞‡´ç‡™§‡™Æ‡™æ‡™® ‡™¨‡´á‡™≤‡´á‡™®‡´ç‡™∏ ‚Çπ{balance:.2f} ‡™õ‡´á‡•§\n\n‡™õ‡´á‡™≤‡´ç‡™≤‡™æ ‡™µ‡´ç‡™Ø‡™µ‡™π‡™æ‡™∞‡´ã:\n{transactions_summary}",
        "extract_fail": "‡™§‡™Æ‡™æ‡™∞‡™æ ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü‡™Æ‡™æ‡™Ç‡™•‡´Ä ‡™Æ‡™æ‡™π‡™ø‡™§‡´Ä ‡™ï‡™æ‡™¢‡´Ä ‡™∂‡™ï‡™æ‡™à ‡™®‡™•‡´Ä. ‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™∏‡´ç‡™™‡™∑‡´ç‡™ü ‡™¨‡´ã‡™≤‡´ã.",
        "transcribe_fail": "‡™§‡™Æ‡™æ‡™∞‡´ã ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™ü‡´ç‡™∞‡™æ‡™®‡´ç‡™∏‡™ï‡´ç‡™∞‡™æ‡™á‡™¨ ‡™Ö‡™•‡™µ‡™æ ‡™Ö‡™®‡´Å‡™µ‡™æ‡™¶ ‡™ï‡™∞‡´Ä ‡™∂‡™ï‡™æ‡™Ø‡´Å‡™Ç ‡™®‡™•‡´Ä. ‡™ë‡™°‡™ø‡™Ø‡´ã ‡™ó‡´Å‡™£‡™µ‡™§‡´ç‡™§‡™æ ‡™®‡™¨‡™≥‡´Ä ‡™π‡´ã‡™à ‡™∂‡™ï‡´á ‡™õ‡´á.",
        "download_fail": "‡™§‡™Æ‡™æ‡™∞‡´ã ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™°‡™æ‡™â‡™®‡™≤‡´ã‡™° ‡™•‡™à ‡™∂‡™ï‡´ç‡™Ø‡´ã ‡™®‡™•‡´Ä: {error_msg}. ‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™´‡™∞‡´Ä ‡™™‡´ç‡™∞‡™Ø‡™æ‡™∏ ‡™ï‡™∞‡´ã.",
        "network_error": "‡™§‡™Æ‡™æ‡™∞‡´ã ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™°‡™æ‡™â‡™®‡™≤‡´ã‡™° ‡™ï‡™∞‡™§‡´Ä ‡™µ‡™ñ‡™§‡´á ‡™®‡´á‡™ü‡™µ‡™∞‡´ç‡™ï ‡™≠‡´Ç‡™≤ ‡™•‡™à: {error_msg}. ‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™´‡™∞‡´Ä ‡™™‡´ç‡™∞‡™Ø‡™æ‡™∏ ‡™ï‡™∞‡´ã.",
        "file_error": "‡™µ‡´â‡™á‡™∏ ‡™®‡´â‡™ü ‡™´‡™æ‡™á‡™≤‡™Æ‡™æ‡™Ç ‡™∏‡™Æ‡®∏‡´ç‡™Ø ‡™π‡™§‡´Ä: {error_msg}‡•§ ‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™§‡´á‡™®‡´á ‡™´‡™∞‡´Ä‡™•‡´Ä ‡™Æ‡´ã‡™ï‡™≤‡´ã.",
        "unexpected_error": "‡™§‡™Æ‡™æ‡™∞‡™æ ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™™‡™∞ ‡™™‡´ç‡™∞‡™ï‡´ç‡™∞‡™ø‡™Ø‡™æ ‡™ï‡™∞‡™§‡´Ä ‡™µ‡™ñ‡™§‡´á ‡™Ö‡™£‡´ç‡™ß‡™æ‡™∞‡´Ä ‡™≠‡´Ç‡™≤ ‡™•‡™à. ‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™´‡™∞‡´Ä ‡™™‡´ç‡™∞‡™Ø‡™æ‡™∏ ‡™ï‡™∞‡´ã.",
        "no_voice_note": "‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™µ‡´ç‡™Ø‡™µ‡™π‡™æ‡™∞ ‡™™‡´ç‡™∞‡™ï‡´ç‡™∞‡™ø‡™Ø‡™æ ‡™Æ‡™æ‡™ü‡´á ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™Æ‡´ã‡™ï‡™≤‡´ã ‡™Ö‡™•‡™µ‡™æ ‡™¨‡´á‡™≤‡´á‡™®‡´ç‡™∏ ‡™™‡´Ç‡™õ‡™µ‡™æ ‡™Æ‡™æ‡™ü‡´á ‡™ü‡´á‡™ï‡´ç‡™∏‡´ç‡™ü ‡™∏‡™Ç‡™¶‡´á‡™∂ ‡™Æ‡´ã‡™ï‡™≤‡´ã.",
        "unsupported_media": "‡™Ö‡™∏‡™Æ‡™∞‡´ç‡™•‡™ø‡™§ ‡™Æ‡´Ä‡™°‡™ø‡™Ø‡™æ ‡™™‡´ç‡™∞‡™ï‡™æ‡™∞: {media_type}‡•§ ‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™è‡™ï ‡™µ‡´â‡™á‡™∏ ‡™®‡´ã‡™ü ‡™Ö‡™•‡™µ‡™æ ‡™è‡™ï ‡™õ‡™¨‡´Ä ‡™Æ‡´ã‡™ï‡™≤‡´ã‡•§",
        "no_transactions_found": "‡™ï‡´ã‡™à ‡™§‡™æ‡™ú‡´á‡™§‡™∞‡™®‡™æ ‡™µ‡´ç‡™Ø‡™µ‡™π‡™æ‡™∞‡´ã ‡™Æ‡™≥‡´ç‡™Ø‡™æ ‡™®‡™•‡´Ä‡•§",
        "image_received_stock_update": "‡™õ‡™¨‡´Ä ‡™™‡´ç‡™∞‡™æ‡™™‡´ç‡™§ ‡™•‡™à! ‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Ö‡™™‡™°‡´á‡™ü ‡™Æ‡™æ‡™ü‡´á ‡™™‡´ç‡™∞‡™ï‡´ç‡™∞‡™ø‡™Ø‡™æ ‡™•‡™à ‡™∞‡™π‡´Ä ‡™õ‡´á...",
        "stock_update_success": "‚úÖ ‡™∏‡´ç‡™ü‡´ã‡™ï ‡™∏‡™´‡™≥‡™§‡™æ‡´ç‡®™‡©Ç‡´Ç‡™∞‡´ç‡™µ‡™ï ‡™Ö‡™™‡™°‡´á‡™ü ‡™•‡™Ø‡´ã: {updates}.",
        "stock_update_fail": "‚ùå ‡™õ‡™¨‡´Ä‡™Æ‡™æ‡™Ç‡™•‡´Ä ‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Ö‡™™‡™°‡´á‡™ü ‡™ï‡™∞‡™µ‡™æ‡™Æ‡™æ‡™Ç ‡™®‡™ø‡™∑‡´ç‡™´‡™≥. ‡™≠‡´Ç‡™≤: {error_msg}",
        "file_download_error": "‡™§‡™Æ‡™æ‡™∞‡´Ä ‡™õ‡™¨‡´Ä ‡™°‡™æ‡™â‡™®‡™≤‡´ã‡™° ‡™•‡™à ‡™∂‡™ï‡´Ä ‡™®‡™•‡´Ä: {error_msg}. ‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™´‡™∞‡´Ä ‡™™‡´ç‡™∞‡™Ø‡™æ‡™∏ ‡™ï‡™∞‡´ã.",
        "welcome": "‡™®‡™Æ‡™∏‡´ç‡™§‡´á! ‡™π‡´Å‡™Ç ‡™§‡™Æ‡™æ‡™∞‡´Ä ‡™á‡™®‡´ç‡™µ‡´á‡™®‡´ç‡™ü‡´ç‡™∞‡´Ä ‡™Æ‡´á‡™®‡´á‡™ú‡™Æ‡´á‡™®‡´ç‡™ü ‡™¨‡´ã‡™ü ‡™õ‡´Å‡™Ç. ‡™π‡´Å‡™Ç ‡™§‡™Æ‡™®‡´á ‡™ï‡´á‡™µ‡´Ä ‡™∞‡´Ä‡™§‡´á ‡™Æ‡™¶‡™¶ ‡™ï‡™∞‡´Ä ‡™∂‡™ï‡´Å‡™Ç?",
        "stock_updated": "{item_name} ‡™®‡´ã ‡™∏‡´ç‡™ü‡´ã‡™ï ‡™∏‡´ç‡™´‡™≥‡™§‡™æ‡™™‡´Ç‡™∞‡´ç‡™µ‡™ï ‡™Ö‡™™‡™°‡´á‡™ü ‡™•‡™Ø‡´ã. ‡™µ‡™∞‡´ç‡™§‡™Æ‡™æ‡™® ‡™ú‡™•‡´ç‡™•‡´ã: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} ‡™®‡´Å‡™Ç ‡™µ‡´á‡™ö‡™æ‡™£ ‡™®‡´ã‡™Ç‡™ß‡™æ‡™à. ‡™¨‡™æ‡™ï‡´Ä ‡™∏‡´ç‡™ü‡´ã‡™ï: {current_quantity} {unit}. ‡™ï‡´Å‡™≤ ‡™µ‡´á‡™ö‡™æ‡™£ ‡™∞‡™ï‡™Æ: {selling_amount}. ‡™®‡™´‡´ã: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} ‡™®‡´Ä ‡™ñ‡®∞‡´Ä‡™¶‡´Ä ‡™®‡´ã‡™Ç‡™ß‡™æ‡™à. ‡™®‡™µ‡´ã ‡™∏‡´ç‡™ü‡´ã‡™ï: {current_quantity} {unit}. ‡™ñ‡™∞‡´ç‡™ö: {cost_price_per_unit} ‡®™‡©ç‡®∞‡®§‡©Ä {unit}.",
        "item_not_found": "'{item_name}' ‡™∏‡´ç‡™ü‡´ã‡™ï ‡™µ‡®ø‡©±‡®ö ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡©Ä. ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§á‡§∏‡•á ‡§ú‡•ã‡§°‡§º‡§®‡§æ ‡§ö‡§æ‡§π‡•á‡§Ç‡§ó‡•á?",
        "unknown_command": "‡®Æ‡©à‡®®‡©Ç‡©∞ ‡™∏‡®Æ‡™ù ‡™®‡®π‡©Ä‡™Ç ‡®Ü‡™Ø‡™æ. ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ '‡§∏‡§π‡§æ‡§Ø‡§§‡§æ' ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç‡•§",
        "current_stock": "{item_name} ‡™¶‡®æ ‡®Æ‡©å‡®ú‡©Ç‡®¶‡®æ ‡®∏‡®ü‡®æ‡®ï: {current_quantity} {unit}.",
        "all_stock_items": "‡®§‡©Å‡®π‡®æ‡®°‡®æ ‡®Æ‡©å‡®ú‡©Ç‡®¶‡®æ ‡®∏‡®ü‡®æ‡®ï:\n{stock_list}",
        "daily_summary": "{date} ‡®≤‡®à ‡®∞‡©ã‡®ú‡®º‡®æ‡®®‡®æ ‡®µ‡®ø‡®ï‡®∞‡©Ä ‡®∏‡©∞‡®ñ‡©á‡®™:\n‡®ï‡©Å‡©±‡®≤ ‡®µ‡®ø‡®ï‡®∞‡©Ä: {total_sales}\n‡®ï‡©Å‡©±‡®≤ ‡®≤‡®æ‡®≠: {total_profit}\n{sales_details}",
        "low_stock_alert": "‚ö†Ô∏è ‡®ò‡©±‡®ü ‡®∏‡®ü‡®æ‡®ï ‡®ö‡©á‡®§‡®æ‡®µ‡®®‡©Ä! ‡®π‡©á‡®†‡®æ‡®Ç ‡®¶‡®ø‡©±‡®§‡©Ä‡®Ü‡®Ç ‡®ö‡©Ä‡®ú‡®º‡®æ‡®Ç ‡®ò‡©±‡®ü ‡®π‡©ã ‡®∞‡®π‡©Ä‡®Ü‡®Ç ‡®π‡®®:\n{low_stock_items_list}\n‡®ú‡®≤‡®¶‡©Ä ‡®π‡©Ä ‡®Ü‡®∞‡®°‡®∞ ‡®ï‡®∞‡®® ‡®¨‡®æ‡®∞‡©á ‡®µ‡®ø‡®ö‡®æ‡®∞ ‡®ï‡®∞‡©ã‡•§",
        "call_initiated": "{item_name} ‡™¶‡©á {quantity} {unit} ‡™≤‡®à {supplier_name} ({supplier_phone_number}) ‡™®‡©Ç‡™Ç ‡™ï‡®æ‡™≤ ‡™ï‡©Ä‡™§‡™æ ‡™ú‡™æ ‡™∞‡®ø‡™π‡™æ ‡™π‡©à‡•§ ‡™Ü‡™∞‡®°‡™∞ ‡™¶‡©Ä ‡®™‡©Å‡™∏‡®º‡™ü‡©Ä ‡™π‡©ã‡™£ '‡™§‡©á ‡™Æ‡©à‡™Ç ‡™§‡©Å‡®π‡®æ‡™®‡©Ç‡™Ç ‡§∏‡•Ç‡§ö‡§ø‡§§ ‡™ï‡™∞‡´Ç‡™Ç‡™ó‡´ã‡•§",
        "order_confirmation_prompt": "‡™§‡™Æ‡´á ‡™ï‡™à ‡™µ‡™∏‡´ç‡™§‡´Å ‡™Ö‡™®‡´á ‡™∏‡™™‡´ç‡™≤‡™æ‡™Ø‡™∞ ‡™Æ‡™æ‡™ü‡´á ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ï‡™®‡´ç‡™´‡™∞‡´ç‡™Æ ‡™ï‡™∞‡™µ‡™æ ‡™Æ‡™æ‡™Ç‡™ó‡´ã ‡™õ‡´ã? ‡™â‡™¶‡™æ‡™π‡™∞‡™£: '‡™∏‡™™‡´ç‡™≤‡™æ‡™Ø‡™∞ A ‡™™‡™æ‡™∏‡´á‡™•‡´Ä 10 ‡™ï‡™ø‡™≤‡´ã ‡™ö‡´ã‡™ñ‡™æ‡™®‡´ã ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ï‡™∞‡´ã'.",
        "order_confirmed_shopkeeper": "‚úÖ {item_name} ‡™®‡™æ {quantity} {unit} ‡™Æ‡™æ‡™ü‡´á {supplier_name} ‡™™‡™æ‡™∏‡´á‡™•‡´Ä ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ï‡™®‡´ç‡™´‡™∞‡´ç‡™Æ ‡™•‡™Ø‡´ã ‡™õ‡´á. ‡™∏‡´ç‡™ü‡´ã‡™ï ‡™Ö‡™™‡™°‡´á‡™ü ‡™ï‡™∞‡™µ‡™æ‡™Æ‡™æ‡™Ç ‡™Ü‡™µ‡´ç‡™Ø‡´ã ‡™õ‡´á. 2 ‡™¶‡™ø‡™µ‡™∏‡™Æ‡™æ‡™Ç ‡™°‡™ø‡™≤‡™ø‡™µ‡™∞‡´Ä ‡™Ö‡™™‡´á‡™ï‡´ç‡™∑‡™ø‡™§ ‡™õ‡´á.",
        "order_failed_shopkeeper": "‚ùå {item_name} ‡™®‡™æ {supplier_name} ‡™™‡™æ‡™∏‡´á‡™•‡´Ä ‡™ì‡™∞‡´ç‡™°‡™∞ ‡™ï‡™®‡´ç‡™´‡™∞‡´ç‡™Æ ‡™ï‡™∞‡™µ‡™æ‡™Æ‡™æ‡™Ç ‡™®‡™ø‡™∑‡´ç‡™´‡™≥. ‡™ï‡™æ‡™∞‡™£: {reason}"
    },
    "te": { # Telugu messages
        "sale_success": "‚úÖ ‡∞Æ‡±Ä ‡∞°‡∞ø‡∞ú‡∞ø‡∞ü‡∞≤‡±ç ‡∞ñ‡∞æ‡∞§‡∞æ‡∞≤‡±ã ‚Çπ{amount:.2f} ({item}) ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø.",
        "sale_success_no_item": "‚úÖ ‡∞Æ‡±Ä ‡∞°‡∞ø‡∞ú‡∞ø‡∞ü‡∞≤‡±ç ‡∞ñ‡∞æ‡∞§‡∞æ‡∞≤‡±ã ‚Çπ{amount:.2f} ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø.",
        "expense_success": "‚úÖ ‡∞Æ‡±Ä ‡∞°‡∞ø‡∞ú‡∞ø‡∞ü‡∞≤‡±ç ‡∞ñ‡∞æ‡∞§‡∞æ‡∞≤‡±ã ‚Çπ{amount} ({item}) ‡∞ñ‡∞∞‡±ç‡∞ö‡±Å ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø.",
        "expense_success_no_item": "‚úÖ ‡∞Æ‡±Ä ‡∞°‡∞ø‡∞ú‡∞ø‡∞ü‡∞≤‡±ç ‡∞ñ‡∞æ‡∞§‡∞æ‡∞≤‡±ã ‚Çπ{amount} ‡∞ñ‡∞∞‡±ç‡∞ö‡±Å ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø.",
        "balance_inquiry": "üìä ‡∞Æ‡±Ä ‡∞°‡∞ø‡∞ú‡∞ø‡∞ü‡∞≤‡±ç ‡∞ñ‡∞æ‡∞§‡∞æ‡∞≤‡±ã ‡∞™‡±ç‡∞∞‡∞∏‡±ç‡∞§‡±Å‡∞§ ‡∞¨‡±ç‡∞Ø‡∞æ‡∞≤‡±Ü‡∞®‡±ç‡∞∏‡±ç ‚Çπ{balance:.2f} ‡∞â‡∞Ç‡∞¶‡∞ø.\n\n‡∞§‡∞æ‡∞ú‡∞æ ‡∞≤‡∞æ‡∞µ‡∞æ‡∞¶‡±á‡∞µ‡±Ä‡∞≤‡±Å:\n{transactions_summary}",
        "extract_fail": "‡∞Æ‡±Ä ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç ‡∞®‡±Å‡∞Ç‡∞°‡∞ø ‡∞°‡±á‡∞ü‡∞æ‡∞®‡±Å ‡∞∏‡±á‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞≤‡±á‡∞Æ‡±Å. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞∏‡±ç‡∞™‡∞∑‡±ç‡∞ü‡∞Ç‡∞ó‡∞æ ‡∞Æ‡∞æ‡∞ü‡±ç‡∞≤‡∞æ‡∞°‡∞Ç‡∞°‡∞ø.",
        "transcribe_fail": "‡∞Æ‡±Ä ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç‚Äå‡∞®‡±Å ‡∞≤‡∞ø‡∞™‡±ç‡∞Ø‡∞Ç‡∞§‡∞∞‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞°‡∞Ç ‡∞≤‡±á‡∞¶‡∞æ ‡∞Ö‡∞®‡∞®‡±Å‡∞µ‡∞¶‡∞ø‡∞Ç‡∞ö‡∞°‡∞Ç ‡∞∏‡∞æ‡∞ß‡∞Ø‡∞Ç ‡∞ï‡∞æ‡∞≤‡±á‡∞¶‡±Å. ‡∞Ü‡∞°‡∞ø‡∞Ø‡±ã ‡∞®‡∞æ‡∞£‡±ç‡∞Ø‡∞§ ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ‡∞ó‡∞æ ‡∞â‡∞Ç‡∞°‡∞µ‡∞ö‡±ç‡∞ö‡±Å.",
        "download_fail": "‡∞Æ‡±Ä ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç‚Äå‡∞®‡±Å ‡∞°‡±å‡∞®‡±ç‚Äå‡∞≤‡±ã‡∞°‡±ç ‡∞ö‡±á‡∞Ø‡∞°‡∞Ç‡∞≤‡±ã ‡∞µ‡∞ø‡∞´‡∞≤‡∞Æ‡±à‡∞Ç‡∞¶‡∞ø: {error_msg}. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø.",
        "network_error": "‡∞Æ‡±Ä ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç‚Äå‡∞®‡±Å ‡∞°‡±å‡∞®‡±ç‚Äå‡∞≤‡±ã‡∞°‡±ç ‡∞ö‡±á‡∞∏‡±ç‡∞§‡±Å‡∞®‡±ç‡∞®‡∞™‡±ç‡∞™‡±Å‡∞°‡±Å ‡∞®‡±Ü‡∞ü‡±ç‚Äå‡∞µ‡∞∞‡±ç‡∞ï‡±ç ‡∞≤‡±ã‡∞™‡∞Ç ‡∞∏‡∞Ç‡∞≠‡∞µ‡∞ø‡∞Ç‡∞ö‡∞ø‡∞Ç‡∞¶‡∞ø: {error_msg}. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø.",
        "file_error": "‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç ‡∞´‡±à‡∞≤‡±ç‚Äå‡∞≤‡±ã ‡∞∏‡∞Æ‡∞∏‡±ç‡∞Ø ‡∞â‡∞Ç‡∞¶‡∞ø: {error_msg}. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞¶‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞™‡∞Ç‡∞™‡∞Ç‡∞°‡∞ø.",
        "unexpected_error": "‡∞Æ‡±Ä ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç‚Äå‡∞®‡±Å ‡∞™‡±ç‡∞∞‡∞æ‡∞∏‡±Ü‡∞∏‡±ç ‡∞ö‡±á‡∞∏‡±ç‡∞§‡±Å‡∞®‡±ç‡∞®‡∞™‡±ç‡∞™‡±Å‡∞°‡±Å ‡∞ä‡∞π‡∞ø‡∞Ç‡∞ö‡∞®‡∞ø ‡∞≤‡±ã‡∞™‡∞Ç ‡∞∏‡∞Ç‡∞≠‡∞µ‡∞ø‡∞Ç‡∞ö‡∞ø‡∞Ç‡∞¶‡∞ø. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø.",
        "no_voice_note": "‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞≤‡∞æ‡∞µ‡∞æ‡∞¶‡±á‡∞µ‡±Ä‡∞≤ ‡∞™‡±ç‡∞∞‡∞æ‡∞∏‡±Ü‡∞∏‡∞ø‡∞Ç‡∞ó‡±ç ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç ‡∞™‡∞Ç‡∞™‡∞Ç‡∞°‡∞ø ‡∞≤‡±á‡∞¶‡∞æ ‡∞¨‡±ç‡∞Ø‡∞æ‡∞≤‡±Ü‡∞®‡±ç‡∞∏‡±ç ‡∞µ‡∞ø‡∞ö‡∞æ‡∞∞‡∞£ ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞ü‡±Ü‡∞ï‡±ç‡∞∏‡±ç‡∞ü‡±ç ‡∞∏‡∞Ç‡∞¶‡´á‡∞∂‡∞Ç ‡∞™‡∞Ç‡∞™‡∞Ç‡∞°‡∞ø.",
        "unsupported_media": "‡∞Æ‡∞¶‡±ç‡∞¶‡∞§‡±Å ‡∞≤‡±á‡∞®‡∞ø ‡∞Æ‡±Ä‡∞°‡∞ø‡∞Ø‡∞æ ‡∞∞‡∞ï‡∞Ç: {media_type}‡•§ ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞µ‡∞æ‡∞Ø‡∞ø‡∞∏‡±ç ‡∞®‡±ã‡∞ü‡±ç ‡∞≤‡±á‡∞¶‡∞æ ‡∞ö‡∞ø‡∞§‡±ç‡∞∞‡∞æ‡∞®‡±ç‡∞®‡∞ø ‡∞™‡∞Ç‡∞™‡∞Ç‡∞°‡∞ø.",
        "no_transactions_found": "‡∞§‡∞æ‡∞ú‡∞æ ‡∞≤‡∞æ‡∞µ‡∞æ‡∞¶‡±á‡∞µ‡±Ä‡∞≤‡±Å ‡∞è‡∞µ‡±Ä ‡∞ï‡∞®‡±Å‡∞ó‡±ä‡∞®‡∞¨‡∞°‡∞≤‡±á‡∞¶‡±Å.",
        "image_received_stock_update": "‡∞ö‡∞ø‡∞§‡±ç‡∞∞‡∞Ç ‡∞∏‡±ç‡∞µ‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø! ‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞Ö‡∞™‡±ç‚Äå‡∞°‡±á‡∞ü‡±ç ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞™‡±ç‡∞∞‡∞æ‡∞∏‡±Ü‡∞∏‡±ç ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡±Å‡∞§‡±ã‡∞Ç‡∞¶‡∞ø...",
        "stock_update_success": "‚úÖ ‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞µ‡∞ø‡∞ú‡∞Ø‡∞µ‡∞Ç‡∞§‡∞Ç‡∞ó‡∞æ ‡∞®‡∞µ‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø: {updates}.",
        "stock_update_fail": "‚ùå ‡∞ö‡∞ø‡∞§‡±ç‡∞∞‡∞Ç ‡∞®‡±Å‡∞Ç‡∞°‡∞ø ‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç‚Äå‡∞®‡±Å ‡∞®‡∞µ‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞°‡∞Ç‡∞≤‡±ã ‡∞µ‡∞ø‡∞´‡∞≤‡∞Æ‡±à‡∞Ç‡∞¶‡∞ø. ‡∞≤‡±ã‡∞™‡∞Ç: {error_msg}",
        "file_download_error": "‡∞Æ‡±Ä ‡∞ö‡∞ø‡∞§‡±ç‡∞∞‡∞Ç ‡∞°‡±å‡∞®‡±ç‚Äå‡∞≤‡±ã‡∞°‡±ç ‡∞ö‡±á‡∞Ø‡∞°‡∞Ç‡∞≤‡±ã ‡∞µ‡∞ø‡∞´‡∞≤‡∞Æ‡±à‡∞Ç‡∞¶‡∞ø: {error_msg}. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø.",
        "welcome": "‡∞®‡∞Æ‡∞∏‡±ç‡∞ï‡∞æ‡∞∞‡∞Ç! ‡∞®‡±á‡∞®‡±Å ‡∞Æ‡±Ä ‡∞á‡∞®‡±ç‡∞µ‡±Ü‡∞Ç‡∞ü‡∞∞‡±Ä ‡∞®‡∞ø‡∞∞‡±ç‡∞µ‡∞π‡∞£ ‡∞¨‡∞æ‡∞ü‡±ç ‡∞®‡∞ø. ‡∞®‡±á‡∞®‡±Å ‡∞Æ‡±Ä‡∞ï‡±Å ‡∞é‡∞≤‡∞æ ‡∞∏‡∞π‡∞æ‡∞Ø‡∞Ç ‡∞ö‡±á‡∞Ø‡∞ó‡∞≤‡∞®‡±Å?",
        "stock_updated": "{item_name} ‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞µ‡∞ø‡∞ú‡∞Ø‡∞µ‡∞Ç‡∞§‡∞Ç‡∞ó‡∞æ ‡∞®‡∞µ‡±Ä‡∞ï‡∞∞‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø. ‡∞™‡±ç‡∞∞‡∞∏‡±ç‡∞§‡±Å‡∞§ ‡∞™‡∞∞‡∞ø‡∞Æ‡∞æ‡∞£‡∞Ç: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞Ç ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø. ‡∞Æ‡∞ø‡∞ó‡∞ø‡∞≤‡∞ø‡∞® ‡∞®‡∞ø‡∞≤‡±ç‡∞µ: {current_quantity} {unit}. ‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞™‡±Å ‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç: {selling_amount}. ‡∞≤‡∞æ‡∞≠‡∞Ç: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} ‡∞ï‡±ä‡∞®‡±Å‡∞ó‡±ã‡∞≤‡±Å ‡∞®‡∞Æ‡±ã‡∞¶‡±Å ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø. ‡∞ï‡±ä‡∞§‡±ç‡∞§ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ: {current_quantity} {unit}. ‡∞ß‡∞∞: {cost_price_per_unit} ‡∞™‡±ç‡∞∞‡∞§‡∞ø {unit}.",
        "item_not_found": "'{item_name}' ‡∞®‡∞ø‡∞≤‡±ç‡∞µ‡∞≤‡±ã ‡∞ï‡∞®‡±Å‡∞ó‡±ä‡∞®‡∞¨‡∞°‡∞≤‡±á‡∞¶‡±Å. ‡∞Æ‡±Ä‡∞∞‡±Å ‡∞¶‡±Ä‡∞®‡±ç‡∞®‡∞ø ‡∞ú‡±ã‡∞°‡∞ø‡∞Ç‡∞ö‡∞æ‡∞≤‡∞®‡±Å‡∞ï‡±Å‡∞Ç‡∞ü‡±Å‡∞®‡±ç‡∞®‡∞æ‡∞∞‡∞æ?",
        "unknown_command": "‡∞®‡∞æ‡∞ï‡±Å ‡∞Ö‡∞∞‡±ç‡∞•‡∞Ç ‡∞ï‡∞æ‡∞≤‡±á‡∞¶‡±Å. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞Æ‡∞≥‡±ç‡∞≥‡±Ä ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø ‡∞≤‡±á‡∞¶‡∞æ '‡∞∏‡∞π‡∞æ‡∞Ø‡∞Ç' ‡∞Ö‡∞®‡∞ø ‡∞ü‡±à‡∞™‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø.",
        "current_stock": "{item_name} ‡∞™‡±ç‡∞∞‡∞∏‡±ç‡∞§‡±Å‡∞§ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ: {current_quantity} {unit}.",
        "all_stock_items": "‡∞Æ‡±Ä ‡∞™‡±ç‡∞∞‡∞∏‡±ç‡∞§‡±Å‡∞§ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ:\n{stock_list}",
        "daily_summary": "{date} ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞∞‡±ã‡∞ú‡±Å‡∞µ‡∞æ‡∞∞‡±Ä ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤ ‡∞∏‡∞æ‡∞∞‡∞æ‡∞Ç‡∞∂‡∞Ç:\n‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞Ö‡∞Æ‡±ç‡∞Æ‡∞ï‡∞æ‡∞≤‡±Å: {total_sales}\n‡∞Æ‡±ä‡∞§‡±ç‡∞§‡∞Ç ‡∞≤‡∞æ‡∞≠‡∞Ç: {total_profit}\n{sales_details}",
        "low_stock_alert": "‚ö†Ô∏è ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ ‡∞®‡∞ø‡∞≤‡±ç‡∞µ ‡∞π‡±Ü‡∞ö‡±ç‡∞ö‡∞∞‡∞ø‡∞ï! ‡∞ï‡±ç‡∞∞‡∞ø‡∞Ç‡∞¶‡∞ø ‡∞Ö‡∞Ç‡∞∂‡∞æ‡∞≤‡±Å ‡∞§‡∞ï‡±ç‡∞ï‡±Å‡∞µ‡∞ó‡∞æ ‡∞â‡∞®‡±ç‡∞®‡∞æ‡∞Ø‡∞ø:\n{low_stock_items_list}\n‡∞§‡±ç‡∞µ‡∞∞‡∞≤‡±ã ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞ö‡±á‡∞Ø‡∞æ‡∞≤‡∞®‡∞ø ‡∞™‡∞∞‡∞ø‡∞ó‡∞£‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø.",
        "call_initiated": "{item_name} ‡∞Ø‡±ä‡∞ï‡±ç‡∞ï {quantity} {unit} ‡∞ï‡±ã‡∞∏‡∞Ç {supplier_name} ({supplier_phone_number}) ‡∞ï‡±Å ‡∞ï‡∞æ‡∞≤‡±ç ‡∞™‡±ç‡∞∞‡∞æ‡∞∞‡∞Ç‡∞≠‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡±Å‡∞§‡±ã‡∞Ç‡∞¶‡∞ø. ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞® ‡∞§‡∞∞‡±ç‡∞µ‡∞æ‡∞§ ‡∞®‡±á‡∞®‡±Å ‡∞Æ‡±Ä‡∞ï‡±Å ‡∞§‡±Ü‡∞≤‡∞ø‡∞Ø‡∞ú‡±á‡∞∏‡±ç‡∞§‡∞æ‡∞®‡±Å.",
        "order_confirmation_prompt": "‡∞Æ‡±Ä‡∞∞‡±Å ‡∞è ‡∞µ‡∞∏‡±ç‡∞§‡©Å‡∞µ‡±Å ‡∞Æ‡∞∞‡∞ø‡∞Ø‡±Å ‡∞∏‡∞∞‡∞´‡∞∞‡∞æ‡∞¶‡∞æ‡∞∞‡±Å ‡∞ï‡±ã‡∞∏‡∞Ç ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç‚Äå‡∞®‡±Å ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞ø‡∞Ç‡∞ö‡∞æ‡∞≤‡∞®‡±Å‡∞ï‡±Å‡∞Ç‡∞ü‡±Å‡∞®‡±ç‡∞®‡∞æ‡∞∞‡±Å? ‡∞â‡∞¶‡∞æ‡∞π‡∞∞‡∞£: '‡∞∏‡∞™‡±ç‡∞≤‡∞Ø‡∞∞‡±ç A ‡∞®‡±Å‡∞Ç‡∞°‡∞ø 10 ‡∞ï‡∞ø‡∞≤‡´ã‡∞≤ ‡∞¨‡∞ø‡∞Ø‡±ç‡∞Ø‡∞Ç ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞ö‡±á‡∞Ø‡∞Ç‡∞°‡∞ø'.",
        "order_confirmed_shopkeeper": "‚úÖ {item_name} ‡∞Ø‡±ä‡∞ï‡±ç‡∞ï {quantity} {unit} ‡∞ï‡±ä‡∞∞‡∞ï‡±Å {supplier_name} ‡∞®‡±Å‡∞Ç‡∞°‡∞ø ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø. ‡∞∏‡±ç‡∞ü‡∞æ‡∞ï‡±ç ‡∞Ö‡∞™‡±ç‚Äå‡∞°‡±á‡∞ü‡±ç ‡∞ö‡±á‡∞Ø‡∞¨‡∞°‡∞ø‡∞Ç‡∞¶‡∞ø. 2 ‡∞∞‡±ã‡∞ú‡±Å‡∞≤‡∞≤‡±ã ‡∞°‡±Ü‡∞≤‡∞ø‡∞µ‡∞∞‡±Ä ‡∞Ü‡∞∂‡∞ø‡∞Ç‡∞ö‡∞¨‡∞°‡±Å‡∞§‡±Å‡∞Ç‡∞¶‡∞ø.",
        "order_failed_shopkeeper": "‚ùå {item_name} ‡∞Ø‡±ä‡∞ï‡±ç‡∞ï {supplier_name} ‡∞®‡±Å‡∞Ç‡∞°‡∞ø ‡∞Ü‡∞∞‡±ç‡∞°‡∞∞‡±ç‚Äå‡∞®‡±Å ‡∞®‡∞ø‡∞∞‡±ç‡∞ß‡∞æ‡∞∞‡∞ø‡∞Ç‡∞ö‡∞°‡∞Ç‡∞≤‡±ã ‡∞µ‡∞ø‡∞´‡∞≤‡∞Æ‡±à‡∞Ç‡∞¶‡∞ø. ‡∞ï‡∞æ‡∞∞‡∞£‡∞Ç: {reason}"
    },
    "bn": { # Bengali messages
        "sale_success": "‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü‡¶æ‡¶≤ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá ‚Çπ{amount:.2f} ({item}) ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§",
        "sale_success_no_item": "‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü‡¶æ‡¶≤ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá ‚Çπ{amount:.2f} ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§",
        "expense_success": "‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü‡¶æ‡¶≤ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá ‚Çπ{amount} ({item}) ‡¶ñ‡¶∞‡¶ö ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§",
        "expense_success_no_item": "‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü‡¶æ‡¶≤ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá ‚Çπ{amount} ‡¶ñ‡¶∞‡¶ö ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§",
        "balance_inquiry": "üìä ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶°‡¶ø‡¶ú‡¶ø‡¶ü‡¶æ‡¶≤ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‚Çπ{balance:.2f}‡•§\n\n‡¶∏‡¶æ‡¶Æ‡ßç‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï ‡¶≤‡ßá‡¶®‡¶¶‡ßá‡¶®:\n{transactions_summary}",
        "extract_fail": "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶•‡ßá‡¶ï‡ßá ‡¶°‡ßá‡¶ü‡¶æ ‡¶è‡¶ï‡ßç‡¶∏‡¶ü‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶™‡¶∞‡¶ø‡¶∑‡ßç‡¶ï‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶¨‡¶≤‡ßÅ‡¶®‡•§",
        "transcribe_fail": "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶ü‡ßç‡¶∞‡¶æ‡¶®‡ßç‡¶∏‡¶ï‡ßç‡¶∞‡¶æ‡¶á‡¶¨ ‡¶¨‡¶æ ‡¶Ö‡¶®‡ßÅ‡¶¨‡¶æ‡¶¶ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§ ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶ó‡ßÅ‡¶£‡¶Æ‡¶æ‡¶® ‡¶ñ‡¶æ‡¶∞‡¶æ‡¶™ ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§",
        "download_fail": "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø: {error_msg}‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
        "network_error": "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá: {error_msg}‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
        "file_error": "‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶´‡¶æ‡¶á‡¶≤‡¶ü‡¶ø‡¶§‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶õ‡¶ø‡¶≤: {error_msg}‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶è‡¶ü‡¶ø ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§",
        "unexpected_error": "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡¶™‡ßç‡¶∞‡¶§‡ßç‡¶Ø‡¶æ‡¶∂‡¶ø‡¶§ ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶ò‡¶ü‡ßá‡¶õ‡ßá‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
        "no_voice_note": "‡¶≤‡ßá‡¶®‡¶¶‡ßá‡¶® ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶ï‡¶∞‡¶£‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶™‡¶æ‡¶†‡¶æ‡¶® ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶ú‡¶æ‡¶®‡¶§‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡¶æ‡¶†‡ßç‡¶Ø ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§",
        "unsupported_media": "‡¶Ö‡¶∏‡¶Æ‡¶∞‡ßç‡¶•‡¶ø‡¶§ ‡¶Æ‡¶ø‡¶°‡¶ø‡¶Ø‡¶º‡¶æ ‡¶™‡ßç‡¶∞‡¶ï‡¶æ‡¶∞: {media_type}‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶≠‡¶Ø‡¶º‡ßá‡¶∏ ‡¶®‡ßã‡¶ü ‡¶¨‡¶æ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶õ‡¶¨‡¶ø ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§",
        "no_transactions_found": "‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶æ‡¶Æ‡ßç‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï ‡¶≤‡ßá‡¶®‡¶¶‡ßá‡¶® ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§",
        "image_received_stock_update": "‡¶õ‡¶¨‡¶ø ‡¶ó‡ßÉ‡¶π‡ßÄ‡¶§ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá! ‡¶∏‡ßç‡¶ü‡¶ï ‡¶Ü‡¶™‡¶°‡ßá‡¶ü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...",
        "stock_update_success": "‚úÖ ‡¶∏‡ßç‡¶ü‡¶ï ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá: {updates}.",
        "stock_update_fail": "‚ùå ‡¶õ‡¶¨‡¶ø ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡ßç‡¶ü‡¶ï ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: {error_msg}",
        "file_download_error": "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶õ‡¶¨‡¶ø ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø: {error_msg}‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
        "low_stock_alert": "‚ö†Ô∏è ‡¶ï‡¶Æ ‡¶∏‡ßç‡¶ü‡¶ï ‡¶∏‡¶§‡¶∞‡ßç‡¶ï‡¶§‡¶æ! ‡¶®‡¶ø‡¶Æ‡ßç‡¶®‡¶≤‡¶ø‡¶ñ‡¶ø‡¶§ ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶ï‡¶Æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá:\n{low_stock_items_list}\n‡¶∂‡ßÄ‡¶ò‡ßç‡¶∞‡¶á ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ï‡¶•‡¶æ ‡¶≠‡¶æ‡¶¨‡ßÅ‡¶®‡•§",
        "welcome": "‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡¶∞! ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶ú‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶¨‡¶ü‡•§ ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø?",
        "stock_updated": "{item_name} ‡¶è‡¶∞ ‡¶∏‡ßç‡¶ü‡¶ï ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶£: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} ‡¶è‡¶∞ ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶Ö‡¶¨‡¶∂‡¶ø‡¶∑‡ßç‡¶ü ‡¶∏‡ßç‡¶ü‡¶ï: {current_quantity} {unit}. ‡¶Æ‡ßã‡¶ü ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º ‡¶™‡¶∞‡¶ø‡¶Æ‡¶æ‡¶£: {selling_amount}. ‡¶≤‡¶æ‡¶≠: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} ‡¶è‡¶∞ ‡¶ï‡ßç‡¶∞‡¶Ø‡¶º ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶®‡¶§‡ßÅ‡¶® ‡¶∏‡ßç‡¶ü‡¶ï: {current_quantity} {unit}. ‡¶ñ‡¶∞‡¶ö: {cost_price_per_unit} ‡¶™‡ßç‡¶∞‡¶§‡¶ø {unit}.",
        "item_not_found": "'{item_name}' ‡¶∏‡ßç‡¶ü‡¶ï ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶è‡¶ü‡¶ø ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶®?",
        "unknown_command": "‡¶Ü‡¶Æ‡¶ø ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‡¶®‡¶ø‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶¨‡¶æ '‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø' ‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
        "current_stock": "{item_name} ‡¶è‡¶∞ ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶∏‡ßç‡¶ü‡¶ï: {current_quantity} {unit}.",
        "all_stock_items": "‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶∏‡ßç‡¶ü‡¶ï:\n{stock_list}",
        "daily_summary": "{date} ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¶‡ßà‡¶®‡¶ø‡¶ï ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º ‡¶∏‡¶æ‡¶∞‡¶æ‡¶Ç‡¶∂:\n‡¶Æ‡ßã‡¶ü ‡¶¨‡¶ø‡¶ï‡ßç‡¶∞‡¶Ø‡¶º: {total_sales}\n‡¶Æ‡ßã‡¶ü ‡¶≤‡¶æ‡¶≠: {total_profit}\n{sales_details}",
        "low_stock_alert": "‚ö†Ô∏è ‡¶ï‡¶Æ ‡¶∏‡ßç‡¶ü‡¶ï ‡¶∏‡¶§‡¶∞‡ßç‡¶ï‡¶§‡¶æ! ‡¶®‡¶ø‡¶Æ‡ßç‡¶®‡¶≤‡¶ø‡¶ñ‡¶ø‡¶§ ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶ï‡¶Æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá:\n{low_stock_items_list}\n‡¶∂‡ßÄ‡¶ò‡ßç‡¶∞‡¶á ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ï‡¶•‡¶æ ‡¶≠‡¶æ‡¶¨‡ßÅ‡¶®‡•§",
        "call_initiated": "{item_name} ‡¶è‡¶∞ {quantity} {unit} ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø {supplier_name} ({supplier_phone_number}) ‡¶ï‡ßá ‡¶ï‡¶≤ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶™‡¶∞‡ßá ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶ú‡¶æ‡¶®‡¶æ‡¶¨‡ßã‡•§",
        "order_confirmation_prompt": "‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡ßã‡¶® ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ ‡¶è‡¶¨‡¶Ç ‡¶∏‡¶∞‡¶¨‡¶∞‡¶æ‡¶π‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶®? ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: '‡¶∏‡¶æ‡¶™‡ßç‡¶≤‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶è ‡¶•‡ßá‡¶ï‡ßá 10 ‡¶ï‡ßá‡¶ú‡¶ø ‡¶ö‡¶æ‡¶≤ ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®'.",
        "order_confirmed_shopkeeper": "‚úÖ {item_name} ‡¶è‡¶∞ {quantity} {unit} ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø {supplier_name} ‡¶•‡ßá‡¶ï‡ßá ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶∏‡ßç‡¶ü‡¶ï ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ 2 ‡¶¶‡¶ø‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶°‡ßá‡¶≤‡¶ø‡¶≠‡¶æ‡¶∞‡¶ø ‡¶Ü‡¶∂‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§",
        "order_failed_shopkeeper": "‚ùå {item_name} ‡¶è‡¶∞ {supplier_name} ‡¶•‡ßá‡¶ï‡ßá ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§ ‡¶ï‡¶æ‡¶∞‡¶£: {reason}"
    },
    "mr": { # Marathi messages
        "sale_success": "‚úÖ ‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§°‡§ø‡§ú‡§ø‡§ü‡§≤ ‡§ñ‡§æ‡§§‡•ç‡§Ø‡§æ‡§§ ‚Çπ{amount:.2f} ({item}) ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡•Ä ‡§ó‡•á‡§≤‡•Ä ‡§Ü‡§π‡•á.",
        "sale_success_no_item": "‚úÖ ‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§°‡§ø‡§ú‡§ø‡§ü‡§≤ ‡§ñ‡§æ‡§§‡•ç‡§Ø‡§æ‡§§ ‚Çπ{amount:.2f} ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡•Ä ‡§ó‡•á‡§≤‡•Ä ‡§Ü‡§π‡•á.",
        "expense_success": "‚úÖ ‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§°‡§ø‡§ú‡§ø‡§ü‡§≤ ‡§ñ‡§æ‡§§‡•ç‡§Ø‡§æ‡§§ ‚Çπ{amount} ({item}) ‡§ö‡§æ ‡§ñ‡§∞‡•ç‡§ö ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡§æ ‡§ó‡•á‡§≤‡§æ ‡§Ü‡§π‡•á.",
        "expense_success_no_item": "‚úÖ ‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§°‡§ø‡§ú‡§ø‡§ü‡§≤ ‡§ñ‡§æ‡§§‡•ç‡§Ø‡§æ‡§§ ‚Çπ{amount} ‡§ö‡§æ ‡§ñ‡§∞‡•ç‡§ö ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡§æ ‡§ó‡•á‡§≤‡§æ ‡§Ü‡§π‡•á.",
        "balance_inquiry": "üìä ‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§°‡§ø‡§ú‡§ø‡§ü‡§≤ ‡§ñ‡§æ‡§§‡•ç‡§Ø‡§æ‡§§‡•Ä‡§≤ ‡§∏‡§ß‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§∂‡§ø‡§≤‡•ç‡§≤‡§ï ‚Çπ{balance:.2f} ‡§Ü‡§π‡•á.\n\n‡§Ö‡§≤‡•Ä‡§ï‡§°‡•Ä‡§≤ ‡§µ‡•ç‡§Ø‡§µ‡§π‡§æ‡§∞:\n{transactions_summary}",
        "extract_fail": "‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§µ‡•ç‡§π‡•â‡§á‡§∏ ‡§®‡•ã‡§ü‡§Æ‡§ß‡•Ç‡§® ‡§°‡•á‡§ü‡§æ ‡§ï‡§æ‡§¢‡§§‡§æ ‡§Ü‡§≤‡§æ ‡§®‡§æ‡§π‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§¨‡•ã‡§≤‡§æ.",
        "transcribe_fail": "‡§§‡•Å‡§Æ‡§ö‡§æ ‡§µ‡•ç‡§π‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§ü‡•ç‡§∞‡§æ‡§®‡•ç‡§∏‡§ï‡•ç‡§∞‡§æ‡§á‡§¨ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶‡§ø‡§§ ‡§ï‡§∞‡§§‡§æ ‡§Ü‡§≤‡§æ ‡§®‡§æ‡§π‡•Ä. ‡§ë‡§°‡§ø‡§ì ‡§ó‡•Å‡§£‡§µ‡§§‡•ç‡§§‡§æ ‡§ñ‡§∞‡§æ‡§¨ ‡§Ö‡§∏‡•Ç ‡§∂‡§ï‡§§‡•á.",
        "download_fail": "‡§§‡•Å‡§Æ‡§ö‡•á ‡§µ‡•ç‡§π‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§§ ‡§Ö‡§Ø‡§∂‡§∏‡•ç‡§µ‡•Ä: {error_msg}. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.",
        "network_error": "‡§§‡•Å‡§Æ‡§ö‡•á ‡§µ‡•ç‡§π‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡§§‡§æ‡§®‡§æ ‡§®‡•á‡§ü‡§µ‡§∞‡•ç‡§ï ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§Ü‡§≤‡•Ä: {error_msg}. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.",
        "file_error": "‡§µ‡•ç‡§π‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§´‡§æ‡§á‡§≤‡•ç‡§Æ‡§ß‡•ç‡§Ø‡•á ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•ã‡§§‡•Ä: {error_msg}. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡•Ä ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡§æ‡§†‡§µ‡§æ.",
        "unexpected_error": "‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§µ‡•ç‡§π‡•â‡§á‡§∏ ‡§®‡•ã‡§ü‡§µ‡§∞ ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§ï‡§∞‡§§‡§æ‡§®‡§æ ‡§Ö‡§®‡§™‡•á‡§ï‡•ç‡§∑‡§ø‡§§ ‡§§‡•ç‡§∞‡•Å‡§ü‡•Ä ‡§Ü‡§≤‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.",
        "no_voice_note": "‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡•ç‡§Ø‡§µ‡§π‡§æ‡§∞‡§æ‡§ö‡•ç‡§Ø‡§æ ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡•á‡§∏‡§æ‡§†‡•Ä ‡§µ‡•ç‡§π‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§™‡§æ‡§†‡§µ‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§∂‡§ø‡§≤‡•ç‡§≤‡§ï ‡§ö‡•å‡§ï‡§∂‡•Ä‡§∏‡§æ‡§†‡•Ä ‡§Æ‡§ú‡§ï‡•Ç‡§∞ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§™‡§æ‡§†‡§µ‡§æ.",
        "unsupported_media": "‡§Ö‡§∏‡§Æ‡§∞‡•ç‡§•‡§ø‡§§ ‡§Æ‡•Ä‡§°‡§ø‡§Ø‡§æ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞: {media_type}. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡•ç‡§π‡•â‡§á‡§∏ ‡§®‡•ã‡§ü ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§á‡§Æ‡•á‡§ú ‡§™‡§æ‡§†‡§µ‡§æ.",
        "no_transactions_found": "‡§Ö‡§≤‡•Ä‡§ï‡§°‡•Ä‡§≤ ‡§ï‡•ã‡§£‡§§‡•á‡§π‡•Ä ‡§µ‡•ç‡§Ø‡§µ‡§π‡§æ‡§∞ ‡§Ü‡§¢‡§≥‡§≤‡•á ‡§®‡§æ‡§π‡•Ä‡§§.",
        "image_received_stock_update": "‡§á‡§Æ‡•á‡§ú ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ù‡§æ‡§≤‡•Ä! ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§¶‡•ç‡§Ø‡§Ø‡§æ‡§µ‡§§ ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§∏‡•Å‡§∞‡•Ç ‡§Ü‡§π‡•á...",
        "stock_update_success": "‚úÖ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ø‡§∂‡§∏‡•ç‡§µ‡•Ä‡§∞‡§ø‡§§‡•ç‡§Ø‡§æ ‡§Ö‡§¶‡•ç‡§Ø‡§Ø‡§æ‡§µ‡§ø‡§§ ‡§ù‡§æ‡§≤‡§æ: {updates}.",
        "stock_update_fail": "‚ùå ‡§á‡§Æ‡•á‡§ú‡§Æ‡§ß‡•Ç‡§® ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§¶‡•ç‡§Ø‡§Ø‡§æ‡§µ‡§ø‡§§ ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§§ ‡§Ö‡§Ø‡§∂‡§∏‡•ç‡§µ‡•Ä. ‡§§‡•ç‡§∞‡•Å‡§ü‡•Ä: {error_msg}",
        "file_download_error": "‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§á‡§Æ‡•á‡§ú ‡§°‡§æ‡§â‡§®‡§≤‡•ã‡§° ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§§ ‡§Ö‡§Ø‡§∂‡§∏‡•ç‡§µ‡•Ä: {error_msg}. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.",
        "low_stock_alert": "‚ö†Ô∏è ‡§ï‡§Æ‡•Ä ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§≤‡§∞‡•ç‡§ü! ‡§ñ‡§æ‡§≤‡•Ä‡§≤ ‡§µ‡§∏‡•ç‡§§‡•Ç ‡§ï‡§Æ‡•Ä ‡§π‡•ã‡§§ ‡§Ü‡§π‡•á‡§§:\n{low_stock_items_list}\n‡§≤‡§µ‡§ï‡§∞‡§ö ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§ï‡§∞‡§æ‡•§",
        "welcome": "‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞! ‡§Æ‡•Ä ‡§§‡•Å‡§Æ‡§ö‡§æ ‡§á‡§®‡•ç‡§µ‡•ç‡§π‡•á‡§Ç‡§ü‡§∞‡•Ä ‡§Æ‡•Ö‡§®‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§¨‡•â‡§ü ‡§Ü‡§π‡•á. ‡§Æ‡•Ä ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§≤‡§æ ‡§ï‡§∂‡•Ä ‡§Æ‡§¶‡§§ ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•ã?",
        "stock_updated": "{item_name} ‡§ö‡§æ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ø‡§∂‡§∏‡•ç‡§µ‡•Ä‡§∞‡§ø‡§§‡•ç‡§Ø‡§æ ‡§Ö‡§¶‡•ç‡§Ø‡§Ø‡§æ‡§µ‡§ø‡§§ ‡§ù‡§æ‡§≤‡§æ. ‡§∏‡§ß‡•ç‡§Ø‡§æ‡§ö‡•Ä ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} ‡§ö‡•Ä ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡•Ä ‡§ó‡•á‡§≤‡•Ä. ‡§â‡§∞‡•ç‡§µ‡§∞‡§ø‡§§ ‡§∏‡•ç‡§ü‡•â‡§ï: {current_quantity} {unit}. ‡§è‡§ï‡•Ç‡§£ ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§∞‡§ï‡•ç‡§ï‡§Æ: {selling_amount}. ‡§®‡§´‡§æ: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} ‡§ö‡•Ä ‡§ñ‡§∞‡•á‡§¶‡•Ä ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡•Ä ‡§ó‡•á‡§≤‡•Ä. ‡§®‡§µ‡•Ä‡§® ‡§∏‡•ç‡§ü‡•â‡§ï: {current_quantity} {unit}. ‡§ï‡§ø‡§Ç‡§Æ‡§§: {cost_price_per_unit} ‡§™‡•ç‡§∞‡§§‡§ø {unit}.",
        "item_not_found": "'{item_name}' ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡§ß‡•ç‡§Ø‡•á ‡§Ü‡§¢‡§≥‡§≤‡•á ‡§®‡§æ‡§π‡•Ä. ‡§§‡•Å‡§Æ‡•ç‡§π‡•Ä ‡§§‡•á ‡§ú‡•ã‡§°‡•Ç ‡§á‡§ö‡•ç‡§õ‡§ø‡§§‡§æ ‡§ï‡§æ?",
        "unknown_command": "‡§Æ‡§≤‡§æ ‡§∏‡§Æ‡§ú‡§≤‡•á ‡§®‡§æ‡§π‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ '‡§Æ‡§¶‡§§' ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ.",
        "current_stock": "{item_name} ‡§ö‡§æ ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡•ç‡§ü‡•â‡§ï: {current_quantity} {unit}.",
        "all_stock_items": "‡§§‡•Å‡§Æ‡§ö‡§æ ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡•ç‡§ü‡•â‡§ï:\n{stock_list}",
        "daily_summary": "{date} ‡§∏‡§æ‡§†‡•Ä ‡§¶‡•à‡§®‡§ø‡§ï ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂:\n‡§è‡§ï‡•Ç‡§£ ‡§µ‡§ø‡§ï‡•ç‡§∞‡•Ä: {total_sales}\n‡§è‡§ï‡•Ç‡§£ ‡§®‡§´‡§æ: {total_profit}\n{sales_details}",
        "low_stock_alert": "‚ö†Ô∏è ‡§ï‡§Æ‡•Ä ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§≤‡§∞‡•ç‡§ü! ‡§ñ‡§æ‡§≤‡•Ä‡§≤ ‡§µ‡§∏‡•ç‡§§‡•Ç ‡§ï‡§Æ‡•Ä ‡§π‡•ã‡§§ ‡§Ü‡§π‡•á‡§§:\n{low_stock_items_list}\n‡§≤‡§µ‡§ï‡§∞‡§ö ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§ö‡§æ ‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§ï‡§∞‡§æ‡•§",
        "call_initiated": "{item_name} ‡§ö‡•ç‡§Ø‡§æ {quantity} {unit} ‡§∏‡§æ‡§†‡•Ä {supplier_name} ({supplier_phone_number}) ‡§≤‡§æ ‡§ï‡•â‡§≤ ‡§∏‡•Å‡§∞‡•Ç ‡§ï‡•á‡§≤‡§æ ‡§ú‡§æ‡§§ ‡§Ü‡§π‡•á. ‡§ë‡§∞‡•ç‡§°‡§∞‡§ö‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡•Ä ‡§ù‡§æ‡§≤‡•ç‡§Ø‡§æ‡§µ‡§∞ ‡§Æ‡•Ä ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§≤‡§æ ‡§∏‡•Ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡•á‡§®.",
        "order_confirmation_prompt": "‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§≤‡§æ ‡§ï‡•ã‡§£‡§§‡•ç‡§Ø‡§æ ‡§µ‡§∏‡•ç‡§§‡•Ç ‡§Ü‡§£‡§ø ‡§™‡•Å‡§∞‡§µ‡§†‡§æ‡§¶‡§æ‡§∞‡§æ‡§∏‡§æ‡§†‡•Ä ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡§æ‡§Ø‡§ö‡§æ ‡§Ü‡§π‡•á? ‡§â‡§¶‡§æ‡§π‡§∞‡§£: '‡§™‡•Å‡§∞‡§µ‡§†‡§æ‡§¶‡§æ‡§∞ A ‡§ï‡§°‡•Ç‡§® 10 ‡§ï‡§ø‡§≤‡•ã ‡§§‡§æ‡§Ç‡§¶‡•Ç‡§≥ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡§∞‡§æ'.",
        "order_confirmed_shopkeeper": "‚úÖ {item_name} ‡§ö‡•ç‡§Ø‡§æ {quantity} {unit} ‡§ö‡§æ {supplier_name} ‡§ï‡§°‡•Ç‡§® ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ù‡§æ‡§≤‡§æ ‡§Ü‡§π‡•á. ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Ö‡§¶‡•ç‡§Ø‡§Ø‡§æ‡§µ‡§ø‡§§ ‡§ù‡§æ‡§≤‡§æ ‡§Ü‡§π‡•á. 2 ‡§¶‡§ø‡§µ‡§∏‡§æ‡§Ç‡§§ ‡§µ‡§ø‡§§‡§∞‡§£ ‡§Ö‡§™‡•á‡§ï‡•ç‡§∑‡§ø‡§§ ‡§Ü‡§π‡•á.",
        "order_failed_shopkeeper": "‚ùå {item_name} ‡§ö‡•ç‡§Ø‡§æ {supplier_name} ‡§ï‡§°‡•Ç‡§® ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§§ ‡§Ö‡§Ø‡§∂‡§∏‡•ç‡§µ‡•Ä. ‡§ï‡§æ‡§∞‡§£: {reason}"
    }
}


SUPPLIERS = {
    "Supplier A": {
        "phone": "+919971129359",
        "items": {
            "‡§ö‡§æ‡§µ‡§≤": {"price_per_unit": 45.0, "unit": "kg"},
            "‡§Ü‡§ü‡§æ": {"price_per_unit": 30.0, "unit": "kg"},
            "‡§∏‡•Ç‡§ú‡•Ä": {"price_per_unit": 40.0, "unit": "kg"},
            "‡§∞‡§æ‡§ú‡§Æ‡§æ": {"price_per_unit": 120.0, "unit": "kg"},
            "‡§Æ‡•Ç‡§Ç‡§ó ‡§¶‡§æ‡§≤": {"price_per_unit": 90.0, "unit": "kg"},
            "‡§â‡§°‡§º‡§¶ ‡§¶‡§æ‡§≤": {"price_per_unit": 100.0, "unit": "kg"},
        }
    },
    "Supplier B": {
        "phone": "+919988776655",
        "items": {
            "‡§ö‡§æ‡§µ‡§≤": {"price_per_unit": 47.0, "unit": "kg"},
            "‡§Ü‡§ü‡§æ": {"price_per_unit": 28.0, "unit": "kg"},
            "‡§∏‡•Ç‡§ú‡•Ä": {"price_per_unit": 42.0, "unit": "kg"},
            "‡§∞‡§æ‡§ú‡§Æ‡§æ": {"price_per_unit": 118.0, "unit": "kg"},
            "‡§Æ‡•Ç‡§Ç‡§ó ‡§¶‡§æ‡§≤": {"price_per_unit": 92.0, "unit": "kg"},
            "‡§â‡§°‡§º‡§¶ ‡§¶‡§æ‡§≤": {"price_per_unit": 98.0, "unit": "kg"},
        }
    },
    "Supplier C": {
        "phone": "+917788990011",
        "items": {
            "‡§ö‡§æ‡§µ‡§≤": {"price_per_unit": 46.0, "unit": "kg"},
            "‡§Ü‡§ü‡§æ": {"price_per_unit": 31.0, "unit": "kg"},
            "‡§∏‡•Ç‡§ú‡•Ä": {"price_per_unit": 39.0, "unit": "kg"},
            "‡§∞‡§æ‡§ú‡§Æ‡§æ": {"price_per_unit": 125.0, "unit": "kg"},
            "‡§Æ‡•Ç‡§Ç‡§ó ‡§¶‡§æ‡§≤": {"price_per_unit": 88.0, "unit": "kg"},
            "‡§â‡§°‡§º‡§¶ ‡§¶‡§æ‡§≤": {"price_per_unit": 105.0, "unit": "kg"},
        }
    }
}

class DownloadError(Exception):
    pass

async def find_cheapest_supplier_for_item(item_name: str, item_unit: str) -> dict | None:
    cheapest_supplier = None
    min_price = float('inf')

    # Normalize the item_name and item_unit for better matching
    normalized_item_name = item_name.lower().strip()
    normalized_item_unit = item_unit.lower().strip()

    print(f"DEBUG_SUPPLIER: Searching for cheapest supplier for '{normalized_item_name}' ({normalized_item_unit}).")

    for supplier_name, supplier_info in SUPPLIERS.items():
        for supplier_item_name, item_details in supplier_info["items"].items():
            normalized_supplier_item_name = supplier_item_name.lower().strip()
            supplier_item_unit = item_details["unit"].lower().strip()

            # Use fuzzy matching for item names
            name_score = max(fuzz.token_sort_ratio(normalized_item_name, normalized_supplier_item_name),
                             fuzz.partial_ratio(normalized_item_name, normalized_supplier_item_name))
            
            # Consider a high threshold for fuzzy matching to ensure accuracy
            if name_score >= 80 and normalized_item_unit == supplier_item_unit: # Also ensure units match
                price = item_details["price_per_unit"]
                print(f"DEBUG_SUPPLIER: Found match with {supplier_name} for '{supplier_item_name}' (score: {name_score}). Price: {price} {supplier_item_unit}")

                if price < min_price or (price == min_price and supplier_info["phone"] == "+919971129359"):
                    min_price = price
                    cheapest_supplier = {
                        "supplier_name": supplier_name,
                        "phone": supplier_info["phone"],
                        "item_name": supplier_item_name,
                        "price_per_unit": price,
                        "unit": supplier_item_unit
                    }
    
    if cheapest_supplier:
        print(f"DEBUG_SUPPLIER: Cheapest supplier found: {cheapest_supplier['supplier_name']} for {cheapest_supplier['item_name']} at ‚Çπ{cheapest_supplier['price_per_unit']}/{cheapest_supplier['unit']}")
    else:
        print(f"DEBUG_SUPPLIER: No cheapest supplier found for '{normalized_item_name}' ({normalized_item_unit}).")

    return cheapest_supplier

@retry(stop=stop_after_attempt(3), wait=wait_fixed(2), retry=retry_if_exception_type(DownloadError))
def download_media_with_retry(media_url: str, file_path: str):
    print(f"Attempting to download media from: {media_url}")
    response = requests.get(media_url, auth=(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN), timeout=10)
    print(f"Download response status code: {response.status_code}")
    response.raise_for_status()

    if not response.content:
        raise DownloadError(f"Downloaded content from {media_url} is empty.")

    with open(file_path, 'wb') as f:
        f.write(response.content)
    print(f"Media downloaded successfully to {file_path}")

async def send_whatsapp_message(to_number: str, message_body: str):
    if to_number == TWILIO_WHATSAPP_NUMBER:
        print(f"DEBUG: Skipping sending message to self ({to_number}). Message: {message_body}")
        return
    try:
        print(f"DEBUG: Attempting to send WhatsApp message to {to_number} from {TWILIO_WHATSAPP_NUMBER}. Message: {message_body}")
        message = await asyncio.to_thread(
            twilio_client.messages.create,
            to=to_number,
            from_=TWILIO_WHATSAPP_NUMBER,
            body=message_body
        )
        print(f"DEBUG: WhatsApp message sent successfully. SID: {message.sid}")
    except Exception as e:
        print(f"ERROR: Failed to send WhatsApp message to {to_number}: {e}")

@app.route("/whatsapp", methods=["POST"])
async def whatsapp_webhook():
    sender_id = request.form.get('From', '')
    message_body = request.form.get('Body', '')
    media_url = request.form.get('MediaUrl0', None)
    media_content_type = request.form.get('MediaContentType0', None)
    current_date = date.today()

    print(f"DEBUG_WEBHOOK: Received message. MediaUrl0: {media_url}, MediaContentType0: {media_content_type}")

    detected_language = 'en'
    original_transcription = ""
    english_translation = ""

    should_return_early = False

    balance_keywords = ["balance", "account", "kitna", "total", "shilak", "rupai", "money", "‡§ñ‡§æ‡§§‡§æ", "‡§ï‡§ø‡§§‡§®‡•á ‡§™‡•à‡§∏‡•á ‡§π‡•à‡§Ç", "how much money", "kitni rakam hai", "‡§∂‡§ø‡§≤‡•ç‡§≤‡§ï", "‡§∞‡§ï‡•ç‡§ï‡§Æ"]
    earnings_keywords = ["kamai", "earnings", "profit", "aaj kii", "today's", "‡§ï‡§ø‡§§‡§®‡•Ä ‡§ï‡§Æ‡§æ‡§à ‡§π‡•Å‡§à", "‡§Ü‡§ú ‡§ï‡•Ä ‡§ï‡§Æ‡§æ‡§à", "‡§´‡§æ‡§Ø‡§¶‡§æ", "‡§ï‡§Æ‡§à", "how much did you earn today", "how much you earn today", "total sales today", "total earned today", "‡§Ü‡§ú ‡§ï‡§Æ‡§à", "‡§ï‡§Æ‡§à", "aaj ki kamai", "how much today earnings"]

    cleaned_original_transcription = ""
    cleaned_english_translation = ""

    if media_url:
        if media_content_type and 'audio' in media_content_type:
            try:
                audio_file_path = f"./temp_audio_{sender_id.replace(':', '_')}.ogg"
                download_media_with_retry(media_url, audio_file_path)

                mp3_file_path = audio_file_path.replace(".ogg", ".mp3")
                AudioSegment.from_file(audio_file_path).export(mp3_file_path, format="mp3")
                os.remove(audio_file_path)

                transcription_result = transcribe_audio(mp3_file_path)
                os.remove(mp3_file_path)

                original_transcription = transcription_result["original_transcription"]
                english_translation = transcription_result["english_translation"]
                detected_language = language_map.get(transcription_result["detected_language"], 'en')
                print(f"Detected language: {detected_language}")
                print(f"Original Transcription: {original_transcription}")
                print(f"English Translation: {english_translation}")

                cleaned_original_transcription = re.sub(r'[^\w\s]', '', original_transcription, flags=re.IGNORECASE | re.UNICODE).lower().strip() if original_transcription else ''
                cleaned_english_translation = re.sub(r'[^\w\s]', '', english_translation, flags=re.IGNORECASE | re.UNICODE).lower().strip() if english_translation else ''

            except Exception as e:
                print(f"Error during voice note processing: {e}")
                reply_message = MESSAGES[detected_language]["file_error"].format(error_msg=str(e))
                await send_whatsapp_message(sender_id, reply_message)
                should_return_early = True
                original_transcription = ""
                english_translation = ""

        elif media_content_type and 'image' in media_content_type:
            try:
                image_file_path = f"./temp_image_{sender_id.replace(':', '_')}.jpg"
                download_media_with_retry(media_url, image_file_path)

                await send_whatsapp_message(sender_id, MESSAGES[detected_language]["image_received_stock_update"])

                extracted_bill_data = extract_items_from_bill_image(image_file_path)
                os.remove(image_file_path)

                bill_type = extracted_bill_data.get("bill_type", "unknown")
                extracted_items = extracted_bill_data.get("items", [])
                detected_language_from_bill = extracted_bill_data.get("detected_language", 'en')

                detected_language = language_map.get(detected_language_from_bill, 'en')
                print(f"DEBUG: Detected language from bill: {detected_language_from_bill} -> Normalized: {detected_language}")

                print(f"DEBUG: Extracted bill type: {bill_type}")
                print(f"DEBUG: Extracted items: {extracted_items}")

                if extracted_items:
                    update_messages = []

                    if bill_type == "unknown":
                        if any(item.get("cost_price_per_unit") is not None for item in extracted_items):
                            bill_type = "purchase"
                        elif any(item.get("selling_price_per_unit") is not None for item in extracted_items):
                            reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg="Sales via image are not supported. Please send sales details (item name, quantity, selling price) via voice note or text.")
                            await send_whatsapp_message(sender_id, reply_message)
                            should_return_early = True

                    if bill_type == "purchase":
                        total_bill_expense = 0.0
                        for item in extracted_items:
                            item_name = item.get("item_name")
                            quantity = item.get("quantity")
                            unit = item.get("unit", "pcs")
                            cost_price_per_unit = item.get("cost_price_per_unit")

                            if item_name and isinstance(quantity, (int, float)) and cost_price_per_unit is not None:
                                print(f"DEBUG: Processing purchase item: {item_name}, quantity={float(quantity)} {unit}, cost_price_per_unit={cost_price_per_unit}")
                                await update_stock_item(sender_id, item_name, float(quantity), unit, cost_price_per_unit)
                                update_messages.append(f"{item_name}: {quantity} {unit}")

                                quantity_for_expense_calc = float(quantity)

                                total_bill_expense += quantity_for_expense_calc * float(cost_price_per_unit)

                        if update_messages:
                            if total_bill_expense > 0:
                                expense_data = {
                                    "date": current_date.strftime('%Y-%m-%d'),
                                    "type": "expense",
                                    "amount": total_bill_expense,
                                    "item": f"Stock purchase via bill ({len(update_messages)} items)"
                                }
                                await save_transaction(expense_data, sender_id)
                                update_messages.append(f"Total expense of ‚Çπ{total_bill_expense:.2f} recorded.")

                            reply_message = MESSAGES[detected_language]["stock_update_success"].format(updates="\n".join(update_messages))
                            await send_whatsapp_message(sender_id, reply_message)
                            should_return_early = True
                        else:
                            reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg="Could not extract any valid items with cost prices from the purchase bill.")
                            await send_whatsapp_message(sender_id, reply_message)
                            should_return_early = True

                    elif bill_type == "sale":
                        reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg="Sales bills cannot be processed via image. Please send sales information via voice note or text (item name, quantity, selling price).")
                        await send_whatsapp_message(sender_id, reply_message)
                        should_return_early = True

                    else:
                        reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg="Could not extract any valid items or clear pricing information from the image to determine bill type.")
                        await send_whatsapp_message(sender_id, reply_message)
                        should_return_early = True

                else:
                    reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg="Could not extract any items from the image.")
                    await send_whatsapp_message(sender_id, reply_message)
                    should_return_early = True

            except Exception as e:
                print(f"Error during image processing: {e}")
                print(f"DEBUG: Type of exception e: {type(e)}")
                print(f"DEBUG: Content of exception e: {e}")
                reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg=str(e))
                await send_whatsapp_message(sender_id, reply_message)
                should_return_early = True
        else:
            print(f"Unsupported media type received: {media_content_type}")
            reply_message = MESSAGES[detected_language]["unsupported_media"].format(media_type=media_content_type)
            await send_whatsapp_message(sender_id, reply_message)
            should_return_early = True

    if should_return_early:
        return str(MessagingResponse())

    if message_body and not should_return_early:
        original_transcription = message_body
        english_translation = message_body
        print(f"Received text message: {message_body}")
        detected_language = 'en'
        cleaned_original_transcription = re.sub(r'[^\w\s]', '', original_transcription, flags=re.IGNORECASE | re.UNICODE).lower().strip() if original_transcription else ''
        cleaned_english_translation = re.sub(r'[^\w\s]', '', english_translation, flags=re.IGNORECASE | re.UNICODE).lower().strip() if english_translation else ''

    if should_return_early:
        return str(MessagingResponse())

    if not should_return_early:
        print(f"DEBUG_APP: should_return_early at start of main processing block: {should_return_early}")

        if detected_language != 'en' and english_translation:
            text_for_extraction = english_translation
            print(f"DEBUG: Using English translation for extraction (prioritized due to non-English detected language): {text_for_extraction}")
        elif original_transcription:
            text_for_extraction = original_transcription
            print(f"DEBUG: Using original transcription for extraction (default or English detected): {text_for_extraction}")
        elif english_translation:
            text_for_extraction = english_translation
            print(f"DEBUG: Using English translation for extraction (fallback): {text_for_extraction}")
        else:
            text_for_extraction = ""
            print("DEBUG: No text available for extraction.")

        is_balance_inquiry = any(keyword in cleaned_original_transcription or keyword in cleaned_english_translation for keyword in balance_keywords)
        is_earnings_inquiry = any(keyword in cleaned_original_transcription or keyword in cleaned_english_translation for keyword in earnings_keywords)

        if is_earnings_inquiry:
            today_sales, today_sales_transactions = await get_daily_sales_summary(sender_id, current_date)

            sales_details_list = []
            if today_sales_transactions:
                for txn in today_sales_transactions:
                    txn_item = txn.get("item", "N/A")
                    txn_amount = f'{txn.get("amount", 0.0):.2f}'
                    sales_details_list.append(f"‚Ä¢ {txn_item}: ‚Çπ{txn_amount}")
                sales_details_str = "\n".join(sales_details_list)
            else:
                sales_details_str = MESSAGES[detected_language].get("no_sales_found_today", "No sales found today.")

            reply_message = MESSAGES[detected_language]["earnings_summary"].format(
                total_sales=today_sales,
                sales_details=sales_details_str
            )
            await send_whatsapp_message(sender_id, reply_message)
            should_return_early = True

        elif is_balance_inquiry:
            total_balance, recent_transactions = await get_user_transactions_summary(sender_id)

            transactions_summary_list = []
            for txn in recent_transactions:
                txn_date = txn.get("transaction_date", "N/A")
                txn_type = txn.get("transaction_type", "N/A").capitalize()
                txn_amount = f'{txn.get("amount", "N/A"):.2f}' if isinstance(txn.get("amount"), (int, float)) else "N/A"
                txn_item = txn.get("item", "")

                formatted_txn_amount = txn_amount
                formatted_txn_date = txn_date

                summary_line = f"‚Ä¢ Date: {formatted_txn_date}, Type: {txn_type}, Amount: ‚Çπ{formatted_txn_amount}"
                if txn_item:
                    summary_line += f" ({txn_item})"
                transactions_summary_list.append(summary_line)

            transactions_summary_str = "\n".join(transactions_summary_list) if transactions_summary_list else MESSAGES[detected_language].get("no_transactions_found", "No recent transactions found.")

            reply_message = MESSAGES[detected_language]["balance_inquiry"].format(
                balance=total_balance,
                transactions_summary=transactions_summary_str
            )

            await send_whatsapp_message(sender_id, reply_message)
            should_return_early = True

        elif (english_translation or original_transcription):
            if detected_language != 'en' and english_translation:
                text_for_extraction = english_translation
                print(f"DEBUG: Using English translation for extraction (prioritized due to non-English detected language): {text_for_extraction}")
            elif original_transcription:
                text_for_extraction = original_transcription
                print(f"DEBUG: Using original transcription for extraction (default or English detected): {text_for_extraction}")
            elif english_translation:
                text_for_extraction = english_translation
                print(f"DEBUG: Using English translation for extraction (fallback): {text_for_extraction}")
            else:
                text_for_extraction = ""
                print("DEBUG: No text available for extraction.")

            if not text_for_extraction:
                print("ERROR_APP: No valid text available for extraction after selection logic.")
                await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])
                should_return_early = True
                return str(MessagingResponse()) # Return early

            print(f"DEBUG: Text for structured data extraction: {text_for_extraction}")
            try:
                raw_extracted_content = extract_structured_data(text_for_extraction, current_date)
                print(f"DEBUG_APP: Raw extracted content (from data_extractor): {raw_extracted_content}")
                extracted_data = copy.deepcopy(raw_extracted_content)
                print(f"DEBUG_APP: Extracted structured data (after direct deep copy): {extracted_data}")
            except Exception as e:
                print(f"ERROR_APP: Exception during data extraction or type checking: {e}")
                print(f"ERROR_APP: Type of exception: {type(e)}")
                extracted_data = {}
                should_return_early = True

            if isinstance(extracted_data, dict) and extracted_data:
                await _process_transaction_sync(
                    extracted_data,
                    sender_id,
                    detected_language,
                    current_date,
                    original_transcription,
                    english_translation
                )
            else:
                await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])
                should_return_early = True
        else:
            await send_whatsapp_message(sender_id, MESSAGES[detected_language]["transcribe_fail"])
            should_return_early = True

    print("DEBUG_APP: whatsapp_webhook function completing.")
    return str(MessagingResponse())

async def _translate_text_to_target_language(text: str, target_language: str) -> str:
    try:
        prompt = f"""Translate the following text into {target_language}. Respond only with the translated text.
Text: {text}"""
        response = client.chat.completions.create(
            model="gpt-3.5-turbo-0125",
            messages=[
                {"role": "system", "content": "You are a helpful assistant that translates text."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.0
        )
        translated_text = response.choices[0].message.content.strip()
        print(f"DEBUG_TRANSLATION: Original: '{text}', Translated to {target_language}: '{translated_text}'")
        return translated_text
    except Exception as e:
        print(f"ERROR_TRANSLATION: Error translating text: {e}")
        return text

async def _process_transaction_sync(extracted_data: dict, sender_id: str, detected_language: str, current_date: date, original_transcription: str, english_translation: str):
    print(f"DEBUG_APP: Entering synchronous transaction processing block with data: {extracted_data}")
    transaction_type = extracted_data.get("type", "").lower()
    print(f"DEBUG: Identified transaction type: {transaction_type}")

    profit_keywords = ["profit", "‡§Æ‡•Å‡§®‡§æ‡§´‡§æ", "labh", "‡§´‡§æ‡§Øda", "profitability", "‡§≤‡§æ‡§≠"]
    should_show_profit = any(keyword in original_transcription.lower() for keyword in profit_keywords) or \
                        any(keyword in english_translation.lower() for keyword in profit_keywords)

    if transaction_type == "sale":
        sales_summary_messages = []
        unprocessed_items_messages = []
        total_sales_amount = 0.0
        total_profit = 0.0

        items_sold = extracted_data.get("items_sold", [])
        if items_sold:
            stock_levels = await get_stock_levels(sender_id)
            stock_map = {f"{item['item_name']}-{item['unit']}": item for item in stock_levels}
            print(f"DEBUG_STOCK: Current stock_levels: {stock_levels}")
            print(f"DEBUG_STOCK: Current stock_map keys: {list(stock_map.keys())}")

            target_stock_language = "hi"

            for item in items_sold:
                item_name = item.get("item_name")
                quantity = item.get("quantity")
                unit = item.get("unit", "pcs")
                selling_amount = item.get("selling_amount")

                print(f"DEBUG_ITEM_PROCESSING: Processing extracted item: {{'item_name': '{item_name}', 'quantity': {quantity}, 'unit': '{unit}', 'selling_amount': {selling_amount}}}")

                if item_name and isinstance(quantity, (int, float)) and isinstance(selling_amount, (int, float)):
                    stock_item_name_for_lookup = item_name

                    contains_latin = bool(re.search(r'[a-zA-Z]', item_name))

                    if contains_latin and target_stock_language == "hi":
                        translated_item_name = await _translate_text_to_target_language(item_name, target_stock_language)
                        stock_item_name_for_lookup = translated_item_name
                        print(f"DEBUG: Extracted item name '{item_name}' contains Latin characters and target stock language is Hindi. Translated to '{translated_item_name}' for stock lookup.")
                    elif detected_language != target_stock_language:
                        translated_item_name = await _translate_text_to_target_language(item_name, target_stock_language)
                        stock_item_name_for_lookup = translated_item_name
                        print(f"DEBUG: Incoming item '{item_name}' (detected_lang={detected_language}) translated to '{translated_item_name}' (target_lang={target_stock_language}) for stock lookup.")
                    else:
                        print(f"DEBUG: Incoming item '{item_name}' (detected_lang={detected_language}) is already in target stock language ({target_stock_language}) or no translation needed. No translation performed.")

                    best_match_item_name = None
                    best_match_score = 0.0

                    print(f"DEBUG_FUZZY: Starting fuzzy match for '{stock_item_name_for_lookup}'")
                    for stock_item_obj in stock_levels:
                        item_name_in_stock = stock_item_obj['item_name']
                        current_score = max(fuzz.token_sort_ratio(stock_item_name_for_lookup.lower(), item_name_in_stock.lower()),
                                            fuzz.partial_ratio(stock_item_name_for_lookup.lower(), item_name_in_stock.lower()))
                        print(f"DEBUG_FUZZY: Comparing '{stock_item_name_for_lookup}' with stock item '{item_name_in_stock}'. Score: {current_score}")

                        if current_score > best_match_score:
                            best_match_score = current_score
                            best_match_item_name = item_name_in_stock

                    print(f"DEBUG_FUZZY: Best fuzzy match for '{stock_item_name_for_lookup}': '{best_match_item_name}' with score {best_match_score}")

                    if best_match_item_name and best_match_score >= 40:
                        original_lookup_name_before_fuzzy = stock_item_name_for_lookup
                        stock_item_name_for_lookup = best_match_item_name
                        print(f"DEBUG_FUZZY: Fuzzy match successful. Using '{stock_item_name_for_lookup}' (originally '{original_lookup_name_before_fuzzy}') for stock lookup.")
                    else:
                        print(f"DEBUG_FUZZY: No strong fuzzy match found for '{stock_item_name_for_lookup}' (score: {best_match_score}). Proceeding with original lookup name.")
                        pass

                    print(f"DEBUG_ITEM_MATCH: Attempting to find final stock item for '{stock_item_name_for_lookup}' with effective unit '{unit}'")
                    stock_key = f"{stock_item_name_for_lookup}-{unit}"

                    final_stock_item = None
                    if stock_key in stock_map:
                        final_stock_item = stock_map[stock_key]
                        print(f"DEBUG_ITEM_MATCH: Found exact match in stock_map for key: '{stock_key}'. Item: {final_stock_item}")
                    else:
                        print(f"DEBUG_ITEM_MATCH: No exact match in stock_map for key: '{stock_key}'. Attempting fuzzy unit match.")
                        for existing_stock_key, existing_stock_item in stock_map.items():
                            if fuzz.token_sort_ratio(stock_item_name_for_lookup.lower(), existing_stock_item['item_name'].lower()) >= 80:
                                final_stock_item = existing_stock_item
                                stock_key = existing_stock_key
                                unit = existing_stock_item['unit']
                                print(f"DEBUG_ITEM_MATCH: Found fuzzy item name match with stock item '{existing_stock_item['item_name']}' (unit: '{existing_stock_item['unit']}'). Using this item.")
                                break

                    print(f"DEBUG_FINAL_ITEM_CHECK: final_stock_item before not found check: {final_stock_item}")

                    if not final_stock_item:
                        debug_info = f"Original extracted: {item_name}"
                        if detected_language != target_stock_language:
                            debug_info += f", Translated (if applicable): {original_lookup_name_before_fuzzy if 'original_lookup_name_before_fuzzy' in locals() else item_name}"
                        if best_match_item_name:
                            debug_info += f", Fuzzy matched (if applicable): {best_match_item_name}"
                        debug_info += f", Unit: {unit}"
                        unprocessed_items_messages.append(f"'{item_name}' is not in stock. ({debug_info}). Sale not recorded.")
                        continue

                    if final_stock_item and 'unit' in final_stock_item:
                        unit = final_stock_item['unit']
                        print(f"DEBUG_UNIT: Final effective unit for transaction '{item_name}': '{unit}'. (Original extracted unit: '{item.get('unit', 'pcs')}')")


                    delta_for_update = -float(quantity)

                    await update_stock_item(sender_id, stock_item_name_for_lookup, delta_for_update, unit, None)

                    sale_data = {
                        "date": extracted_data.get("date", current_date.strftime('%Y-%m-%d')),
                        "type": "sale",
                        "amount": selling_amount,
                        "item": f"{stock_item_name_for_lookup} ({quantity} {item.get('unit', 'pcs')})"
                    }
                    await save_transaction(sale_data, sender_id)

                    total_sales_amount += selling_amount

                    cost_price_per_unit = None
                    if final_stock_item.get("cost_price_per_unit") is not None:
                        cost_price_per_unit = float(final_stock_item["cost_price_per_unit"])

                    profit_for_item = 0.0
                    if cost_price_per_unit is not None:
                        profit_for_item = selling_amount - (float(quantity) * cost_price_per_unit)
                        total_profit += profit_for_item

                    if should_show_profit and cost_price_per_unit is not None:
                        sales_summary_messages.append(f"{final_stock_item['item_name']}: ‚Çπ{selling_amount:.2f} (Profit: ‚Çπ{profit_for_item:.2f})")
                    else:
                        sales_summary_messages.append(f"{final_stock_item['item_name']}: ‚Çπ{selling_amount:.2f}")

            print(f"DEBUG_REPLY: sales_summary_messages: {sales_summary_messages}")
            print(f"DEBUG_REPLY: unprocessed_items_messages: {unprocessed_items_messages}")

            final_reply_parts = []
            if sales_summary_messages:
                success_item_summary = "\n".join(sales_summary_messages)
                item_details = f"Total Profit: ‚Çπ{total_profit:.2f}\n{success_item_summary}" if should_show_profit and total_profit > 0 else success_item_summary
                success_message = MESSAGES[detected_language]["sale_success"].format(amount=total_sales_amount, item_details=item_details)
                final_reply_parts.append(success_message)

            if unprocessed_items_messages:
                error_message = "‚ùå Some items were not processed:\n" + "\n".join(unprocessed_items_messages)
                final_reply_parts.append(error_message)

            print(f"DEBUG_REPLY: final_reply_parts before join: {final_reply_parts}")
            if final_reply_parts:
                reply_message = "\n\n".join(final_reply_parts)
                await send_whatsapp_message(sender_id, reply_message)
            else:
                await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])
        else:
            await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])

    elif transaction_type == "purchase":
        purchase_summary_messages = []
        total_purchase_expense = 0.0

        items_purchased = extracted_data.get("items_purchased", [])
        if items_purchased:
            for item in items_purchased:
                item_name = item.get("item_name")
                quantity = item.get("quantity")
                unit = item.get("unit", "pcs")
                cost_price_per_unit = item.get("cost_price_per_unit") # Corrected key

                if item_name and isinstance(quantity, (int, float)) and cost_price_per_unit is not None:
                    await update_stock_item(sender_id, item_name, float(quantity), unit, cost_price_per_unit)
                    purchase_summary_messages.append(f"{item_name}: {quantity} {unit} @ ‚Çπ{cost_price_per_unit:.2f}/{unit}")

                    total_purchase_expense += float(quantity) * float(cost_price_per_unit)

            if purchase_summary_messages:
                if total_purchase_expense > 0:
                    expense_data = {
                        "date": extracted_data.get("date", current_date.strftime('%Y-%m-%d')),
                        "type": "expense",
                        "amount": total_purchase_expense,
                        "item": f"Stock purchase ({len(purchase_summary_messages)} items)"
                    }
                    await save_transaction(expense_data, sender_id)
                    purchase_summary_messages.append(f"Total expense of ‚Çπ{total_purchase_expense:.2f} recorded.")

                reply_message = MESSAGES[detected_language]["stock_update_success"].format(updates="\n".join(purchase_summary_messages))
                await send_whatsapp_message(sender_id, reply_message)
            else:
                await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])
        else:
            await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])

    elif transaction_type == "expense":
        amount = extracted_data.get("amount")
        description = extracted_data.get("description", "")
        if isinstance(amount, (int, float)):
            expense_data = {
                "date": extracted_data.get("date", current_date.strftime('%Y-%m-%d')), "type": "expense",
                "amount": amount, "item": description
            }
            await save_transaction(expense_data, sender_id)

            if description:
                reply_message = MESSAGES[detected_language]["expense_success"].format(amount=amount, item=description)
            else:
                reply_message = MESSAGES[detected_language]["expense_success_no_item"].format(amount=amount)
            await send_whatsapp_message(sender_id, reply_message)
        else:
            await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])
    elif transaction_type == "order_confirmation":
        item_name = extracted_data.get("item_name")
        quantity = extracted_data.get("quantity")
        unit = extracted_data.get("unit", "pcs")
        supplier_name = extracted_data.get("supplier_name")

        if item_name and isinstance(quantity, (int, float)) and supplier_name:
            print(f"DEBUG_ORDER_CONFIRMATION: Received order confirmation for {quantity} {unit} of {item_name} from {supplier_name}.")
            
            supplier_phone_number = None
            supplier_item_cost_price = None

            # Find supplier details from SUPPLIERS dictionary
            for sup_name, sup_info in SUPPLIERS.items():
                if fuzz.ratio(supplier_name.lower(), sup_name.lower()) >= 80: # Fuzzy match for supplier name
                    supplier_phone_number = sup_info["phone"]
                    # Try to find cost price for the item from this supplier
                    for sup_item_name, item_details in sup_info["items"].items():
                        if fuzz.ratio(item_name.lower(), sup_item_name.lower()) >= 80 and unit.lower() == item_details["unit"].lower():
                            supplier_item_cost_price = item_details["price_per_unit"]
                            break
                    break

            if supplier_phone_number:
                call_initiated = await initiate_outbound_call(
                    to_number=supplier_phone_number,
                    item_name=item_name,
                    quantity=quantity,
                    unit=unit,
                    supplier_name=supplier_name,
                    user_id=sender_id,
                    detected_language="hi" # Force Hindi for outbound calls
                )

                if call_initiated:
                    reply_message = MESSAGES[detected_language]["call_initiated"].format(
                        item_name=item_name,
                        quantity=quantity,
                        unit=unit,
                        supplier_name=supplier_name,
                        supplier_phone_number=supplier_phone_number
                    )
                    await send_whatsapp_message(sender_id, reply_message)
                else:
                    print(f"ERROR: Failed to initiate call to {supplier_name} for {item_name}.")
                    reply_message = MESSAGES[detected_language]["order_failed_shopkeeper"].format(
                        item_name=item_name,
                        supplier_name=supplier_name,
                        reason="Failed to initiate call."
                    )
                    await send_whatsapp_message(sender_id, reply_message)
            else:
                reply_message = MESSAGES[detected_language]["item_not_found"].format(item_name=f"{item_name} (Supplier: {supplier_name})")
                await send_whatsapp_message(sender_id, reply_message)
        else:
            reply_message = MESSAGES[detected_language]["extract_fail"]
            await send_whatsapp_message(sender_id, reply_message)
    else:
        await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])

async def check_low_stock_and_alert():
    print("DEBUG_SCHEDULER: Running low stock check...")
    try:
        response = await asyncio.to_thread(supabase.from_("stock_items").select("user_id").execute)
        if response.data:
            unique_user_ids = list(set([item['user_id'] for item in response.data]))
            print(f"DEBUG_SCHEDULER: Found unique user IDs: {unique_user_ids}")
        else:
            unique_user_ids = []
            print("DEBUG_SCHEDULER: No user IDs found in stock_items table.")

        for user_id in unique_user_ids:
            print(f"DEBUG_SCHEDULER: Checking low stock for user_id: {user_id}")
            low_stock_items = await get_low_stock_items(user_id)
            if low_stock_items:
                low_stock_messages = []
                print(f"DEBUG_SCHEDULER: Low stock items found for {user_id}: {low_stock_items}")
                for item in low_stock_items:
                    alert_item_name = item.get('item_name', 'Unknown Item')
                    alert_message_lang = 'hi' # Default to Hindi for now

                    # Define translated terms based on alert_message_lang
                    if alert_message_lang == 'hi':
                        min_text = "‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ"
                        cheapest_text = "‡§∏‡§¨‡§∏‡•á ‡§∏‡§∏‡•ç‡§§‡§æ"
                        call_text = "‡§ï‡•â‡§≤"
                    else: # Default to English
                        min_text = "Min"
                        cheapest_text = "Cheapest"
                        call_text = "Call"

                    if bool(re.search(r'[a-zA-Z]', alert_item_name)) and alert_message_lang == 'hi':
                        alert_item_name = await _translate_text_to_target_language(alert_item_name, alert_message_lang)

                    supplier_info = await find_cheapest_supplier_for_item(alert_item_name, item['unit'])
                    supplier_details = ""
                    if supplier_info:
                        supplier_name = supplier_info["supplier_name"]
                        price = supplier_info["price_price_per_unit"]
                        supplier_phone = supplier_info["phone"]
                        supplier_details = f" ({cheapest_text}: {supplier_name}, ‚Çπ{price:.2f}/{item['unit']}, {call_text}: {supplier_phone})"

                    low_stock_messages.append(f"‚Ä¢ {alert_item_name}: {item['quantity']} {item['unit']} ({min_text}: {item['min_quantity_threshold']} {item['unit']}){supplier_details}")
                
                alert_message = MESSAGES[alert_message_lang]["low_stock_alert"].format(
                    low_stock_items_list="\n".join(low_stock_messages))
                print(f"DEBUG_SCHEDULER: Prepared alert message for {user_id}: {alert_message}")
                await send_whatsapp_message(user_id, alert_message)
                print(f"DEBUG_SCHEDULER: Sent low stock alert to {user_id}.")
            else:
                print(f"DEBUG_SCHEDULER: No low stock items found for {user_id}.")
    except Exception as e:
        print(f"ERROR_SCHEDULER: Error during low stock check: {e}")

# Dictionary to store call states (e.g., conversation history, order details)
# In a production environment, this would be stored in a database.
call_states = {}

async def generate_speech_from_text(text: str, voice: str = "nova", model: str = "tts-1", is_ssml: bool = False) -> str:
    """Generates speech from text using OpenAI's TTS API and returns the audio file path."""
    try:
        # Ensure the audio directory exists
        audio_dir = "./audio"
        os.makedirs(audio_dir, exist_ok=True)

        # Generate a unique filename to avoid conflicts
        unique_id = f"{asyncio.current_task().get_name()}_{os.urandom(4).hex()}"
        speech_file_path = os.path.join(audio_dir, f"response_{unique_id}.mp3")

        input_text = text

        with client.audio.speech.with_streaming_response.create(
            model=model,
            voice=voice,
            input=input_text
        ) as response:
            response.stream_to_file(speech_file_path)
        print(f"DEBUG_TTS: Generated speech to {speech_file_path} (SSML: {is_ssml})")
        return speech_file_path
    except Exception as e:
        print(f"ERROR_TTS: Failed to generate speech from text '{text}': {e}")
        return "" # Return empty string on failure

async def transcribe_speech_from_url(audio_url: str) -> str:
    """Transcribes speech from an audio URL using OpenAI's Whisper API."""
    try:
        temp_audio_path = f"./temp_call_audio_{os.urandom(4).hex()}.wav"
        print(f"DEBUG_WHISPER: Downloading audio from {audio_url} to {temp_audio_path}")
        response = requests.get(audio_url, stream=True)
        response.raise_for_status()
        with open(temp_audio_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        print(f"DEBUG_WHISPER: Downloaded audio to {temp_audio_path}")

        with open(temp_audio_path, "rb") as audio_file:
            transcription = await asyncio.to_thread(
                client.audio.transcriptions.create,
                model="whisper-1",
                file=audio_file
            )
        os.remove(temp_audio_path)
        print(f"DEBUG_WHISPER: Transcription result: {transcription.text}")
        return transcription.text
    except Exception as e:
        print(f"ERROR_WHISPER: Failed to transcribe speech from {audio_url}: {e}")
        return ""

async def get_openai_response(conversation_history: list, temperature: float = 0.5, max_tokens: int = 150) -> str:
    """Gets a response from OpenAI's GPT model."""
    try:
        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo",
            messages=conversation_history,
            temperature=temperature,
            max_tokens=max_tokens
        )
        return response.choices[0].message.content
    except Exception as e:
        print(f"ERROR_OPENAI_RESPONSE: Failed to get OpenAI response: {e}")
        return "I'm sorry, I'm having trouble understanding right now. Please try again."

@app.route("/twilio_voice_webhook", methods=['POST'])
async def twilio_voice_webhook():
    voice_response = VoiceResponse()

    # Extract call context from URL parameters
    item_name = request.args.get("item_name")
    quantity = request.args.get("quantity")
    unit = request.args.get("unit")
    supplier_name = request.args.get("supplier_name")
    user_id = request.args.get("user_id")
    detected_language = request.args.get("detected_language")
    call_sid = request.form.get('CallSid')

    print(f"DEBUG_TWILIO_WEBHOOK: Received Twilio Voice webhook for CallSid: {call_sid}")
    print(f"DEBUG_TWILIO_WEBHOOK: Call context: item_name={item_name}, quantity={quantity}, unit={unit}, supplier_name={supplier_name}, user_id={user_id}, detected_language={detected_language}")

    # Initialize conversation history for this call_sid if it doesn't exist
    if call_sid not in call_states:
        call_states[call_sid] = {
            "conversation_history": [
                {"role": "system", "content": f"""
                You are a friendly, helpful, and polite AI assistant representing Gupta Kirana Store. 
                Your goal is to confirm orders, delivery times, and prices. 
                Speak naturally and politely in Hindi. Be concise and clear. 
                If you don't get all the details, explain what's missing and politely ask the supplier to confirm.
                
                Conversation flow:
                1. First say: '‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Æ‡•à‡§Ç ‡§ó‡•Å‡§™‡•ç‡§§‡§æ ‡§ï‡§ø‡§∞‡§æ‡§®‡§æ ‡§∏‡•ç‡§ü‡•ã‡§∞ ‡§∏‡•á ‡§∞‡§Æ‡§æ ‡§¨‡§æ‡§§ ‡§ï‡§∞ ‡§∞‡§π‡•Ä ‡§π‡•Ç‡§Å‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Æ‡•à‡§Ç {supplier_name} ‡§∏‡•á ‡§¨‡§æ‡§§ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•Ä ‡§π‡•Ç‡§Å?'
                2. If the right person is on the line, ask: '‡§¨‡§π‡•Å‡§§-‡§¨‡§π‡•Å‡§§ ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶‡•§ ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•ã {item_name} ‡§ï‡•á ‡§∏‡•ç‡§ü‡•â‡§ï ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§™‡•Ç‡§õ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•â‡§≤ ‡§ï‡§∞ ‡§∞‡§π‡•Ä ‡§π‡•Ç‡§Å‡•§'
                3. Then ask: '‡§π‡§Æ‡§æ‡§∞‡•á ‡§™‡§æ‡§∏ {item_name} ‡§ï‡•Ä ‡§ï‡§Æ‡•Ä ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™‡§ï‡•á ‡§™‡§æ‡§∏ ‡§Ö‡§≠‡•Ä {quantity} {unit} {item_name} ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§π‡•à? ‡§î‡§∞ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§Æ‡•Å‡§ù‡•á {item_name} ‡§ï‡§æ ‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§Æ‡•Ç‡§≤‡•ç‡§Ø ‡§™‡•ç‡§∞‡§§‡§ø {unit} ‡§¨‡§§‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç?'
                4. If the item is available and price is confirmed, say: '‡§¨‡§π‡•Å‡§§ ‡§Ö‡§ö‡•ç‡§õ‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§π‡§Æ‡§æ‡§∞‡•á ‡§≤‡§ø‡§è {quantity} {unit} {item_name} ‡§¨‡•Å‡§ï ‡§ï‡§∞ ‡§¶‡•á‡§Ç‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§°‡§ø‡§≤‡•Ä‡§µ‡§∞‡•Ä ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§Æ‡§æ‡§®‡§ø‡§§ ‡§∏‡§Æ‡§Ø ‡§¨‡§§‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç?'
                5. If item is not available or price is too high, say: '‡§†‡•Ä‡§ï ‡§π‡•à, ‡§∏‡§Æ‡§ù‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶‡•§ ‡§Æ‡•à‡§Ç ‡§¶‡•Å‡§ï‡§æ‡§® ‡§ï‡•á ‡§Æ‡§æ‡§≤‡§ø‡§ï ‡§ï‡•ã ‡§∏‡•Ç‡§ö‡§ø‡§§ ‡§ï‡§∞ ‡§¶‡•Ç‡§Å‡§ó‡•Ä‡•§'
                6. If supplier confirms booking, say: '‡§¨‡§π‡•Å‡§§-‡§¨‡§π‡•Å‡§§ ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§π‡§Æ ‡§°‡§ø‡§≤‡•Ä‡§µ‡§∞‡•Ä ‡§ï‡§æ ‡§á‡§Ç‡§§‡§ú‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á‡•§ ‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞‡•§'
                
                Important notes:
                - Only speak one or two sentences at a time
                - Wait for the supplier's response before continuing
                - Be natural and conversational
                - If you don't understand, politely ask for clarification
                - If there's silence, ask if they can hear you
                - If the call is breaking up, ask them to speak up or call back
                - Always be polite and professional
                """}
            ],
            "order_details": {
                "item_name": item_name,
                "quantity": quantity,
                "unit": unit,
                "supplier_name": supplier_name,
                "user_id": user_id,
                "detected_language": detected_language,
                "confirmed_price": None,
                "confirmed_delivery_time": None,
                "order_confirmed_status": False,
                "conversation_stage": "initial_greeting",
                "retry_count": 0
            }
        }
    
    # Get the current call state
    call_state = call_states[call_sid]
    
    # Only send the initial greeting if we're at the start of the conversation
    if call_state["order_details"]["conversation_stage"] == "initial_greeting":
        # First message to the supplier
        initial_message = MESSAGES[detected_language]["call_initiated"].format(
            supplier_name=supplier_name
        )
        call_state["conversation_history"].append({"role": "assistant", "content": initial_message})
        
        # Wrap the initial message in SSML to introduce a pause
        ssml_initial_message = f"<speak>{initial_message}<break time=\"1s\"/></speak>"
        speech_file_path = await generate_speech_from_text(ssml_initial_message, voice="nova", is_ssml=True)
        
        # Update conversation stage
        call_state["order_details"]["conversation_stage"] = "waiting_for_response"
    else:
        # This is a subsequent message in the conversation
        # Get the last assistant message to repeat it
        last_messages = [msg for msg in call_state["conversation_history"] if msg["role"] == "assistant"]
        if last_messages:
            last_message = last_messages[-1]["content"]
            speech_file_path = await generate_speech_from_text(f"<speak>{last_message}<break time=\"1s\"/></speak>", voice="nova", is_ssml=True)
    
    # Always include a gather to listen for the supplier's response
    if speech_file_path:
        audio_url = f"{BASE_URL}/audio/{os.path.basename(speech_file_path)}"
        voice_response.play(url=audio_url)
        print(f"DEBUG_TWILIO_WEBHOOK: Playing generated audio from {audio_url}")
    elif 'initial_message' in locals():
        print("ERROR_TWILIO_WEBHOOK: TTS generation failed. Falling back to <Say>.")
        voice_response.say(initial_message, voice='Polly.Aditi', language='hi-IN')
    
    # Add a small pause before gathering input
    voice_response.pause(length=1)
    
    # Gather speech from the supplier with increased timeout and better error handling
    gather_action_url = f"{BASE_URL}/handle_twilio_speech?call_sid={call_sid}"
    voice_response.gather(
        input='speech',
        timeout=10,  # Increased from 5 to 10 seconds
        speechTimeout='auto',
        action=gather_action_url,
        method='POST',
        actionOnEmptyResult=True,  # Important to handle cases where no speech is detected
        enhanced=True,  # Use enhanced speech recognition
        speechModel='phone_call',  # Optimize for phone call quality
        language='hi-IN'  # Specify Hindi language for better recognition
    )
    
    # If no input is received, redirect back to the same URL to try again
    query_string = request.query_string.decode()
    voice_response.redirect(
        method='POST',
        url=f"{BASE_URL}/twilio_voice_webhook?{query_string}"
    )
    
    print(f"DEBUG_TWILIO_WEBHOOK: TwiML response: {str(voice_response)}")
    return str(voice_response)

@app.route("/handle_twilio_speech", methods=['POST'])
async def handle_twilio_speech():
    voice_response = VoiceResponse()
    call_sid = request.args.get('call_sid')
    speech_result = request.form.get('SpeechResult')
    
    print(f"DEBUG_TWILIO_SPEECH: Received speech for CallSid: {call_sid}. SpeechResult: {speech_result}")

    if call_sid not in call_states:
        print(f"ERROR_TWILIO_SPEECH: Call SID {call_sid} not found in call_states")
        voice_response.say("Sorry, an application error occurred. Please call back later.", voice='Polly.Aditi', language='hi-IN')
        voice_response.hangup()
        return str(voice_response)

    current_call_state = call_states[call_sid]
    conversation_history = current_call_state["conversation_history"]
    order_details = current_call_state["order_details"]
    
    # Reset retry count if we got a response
    order_details['retry_count'] = 0
    
    # If no speech was detected, handle it gracefully
    if not speech_result or speech_result.strip() == '':
        print("WARNING_TWILIO_SPEECH: No speech detected or empty response")
        
        # Increment retry count
        order_details['retry_count'] = order_details.get('retry_count', 0) + 1
        
        # If we've retried too many times, end the call
        if order_details['retry_count'] > 2:
            response_text = "‡§Æ‡§æ‡§´‡§º ‡§ï‡•Ä‡§ú‡§ø‡§è, ‡§π‡§Æ ‡§Ü‡§™‡§ï‡•ã ‡§∏‡•Å‡§® ‡§®‡§π‡•Ä‡§Ç ‡§™‡§æ ‡§∞‡§π‡•á ‡§π‡•à‡§Ç‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§¨‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§ï‡•â‡§≤ ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶‡•§"
            voice_response.say(response_text, voice='Polly.Aditi', language='hi-IN')
            voice_response.hangup()
            return str(voice_response)
        
        # Otherwise, ask the supplier to speak again
        response_text = "‡§Æ‡§æ‡§´‡§º ‡§ï‡•Ä‡§ú‡§ø‡§è, ‡§Æ‡•à‡§Ç‡§®‡•á ‡§Ü‡§™‡§ï‡•ã ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§®‡§π‡•Ä‡§Ç ‡§∏‡•Å‡§®‡§æ‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç?"
        conversation_history.append({"role": "assistant", "content": response_text})
        
        # Generate speech from text
        speech_file_path = await generate_speech_from_text(response_text, voice="nova")
        
        # Add the speech to the response
        if speech_file_path:
            audio_url = f"{BASE_URL}/audio/{os.path.basename(speech_file_path)}"
            voice_response.play(url=audio_url)
            print(f"DEBUG_TWILIO_SPEECH: Playing generated audio from {audio_url}")
        else:
            print("WARNING_TWILIO_SPEECH: TTS generation failed. Falling back to default TTS.")
            voice_response.say(response_text, voice='Polly.Aditi', language='hi-IN')
        
        # Add a small pause before next action
        voice_response.pause(length=1)
        
        if order_details.get("order_confirmed_status", False):
            # If order is confirmed, end the call gracefully
            voice_response.say("‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶, ‡§Ü‡§™‡§ï‡§æ ‡§¶‡§ø‡§® ‡§∂‡•Å‡§≠ ‡§π‡•ã‡•§", voice='Polly.Aditi', language='hi-IN')
            voice_response.hangup()
            # Clean up call state after a short delay
            async def cleanup_call_state():
                await asyncio.sleep(5)  # Wait for the call to end
                if call_sid in call_states:
                    del call_states[call_sid]
                    print(f"DEBUG_TWILIO_SPEECH: Cleaned up call state for {call_sid}")
            asyncio.create_task(cleanup_call_state())
            return str(voice_response)
        else:
            # Continue the conversation
            gather_action_url = f"{BASE_URL}/handle_twilio_speech?call_sid={call_sid}"
            voice_response.gather(
                input='speech',
                timeout=10,
                speechTimeout='auto',
                action=gather_action_url,
                method='POST',
                actionOnEmptyResult=True,
                enhanced=True,
                speechModel='phone_call',
                language='hi-IN'
            )
            # Add a redirect as a fallback in case gather fails
            redirect_params = {
                'item_name': order_details['item_name'],
                'quantity': order_details['quantity'],
                'unit': order_details['unit'],
                'supplier_name': order_details['supplier_name'],
                'user_id': order_details['user_id'],
                'detected_language': order_details['detected_language']
            }
            encoded_redirect = urllib.parse.urlencode(redirect_params)
            voice_response.redirect(
                method='POST',
                url=f"{BASE_URL}/twilio_voice_webhook?{encoded_redirect}"
            )
        return str(voice_response)

    # Process the speech result
    if speech_result:
        # Add user's speech to conversation history
        conversation_history.append({"role": "user", "content": speech_result})
        
        try:
            # Get response from OpenAI
            openai_response_text = await get_openai_response(conversation_history)
            text_to_speak = openai_response_text.strip()
            
            # Check for empty response
            if not text_to_speak:
                print("ERROR_TWILIO_SPEECH: OpenAI returned an empty response.")
                text_to_speak = "‡§Æ‡§æ‡§´‡§º ‡§ï‡•Ä‡§ú‡§ø‡§è, ‡§ï‡•Å‡§õ ‡§§‡§ï‡§®‡•Ä‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§•‡•ã‡§°‡§º‡•Ä ‡§¶‡•á‡§∞ ‡§¨‡§æ‡§¶ ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§"
            
            # Add assistant's response to conversation history
            conversation_history.append({"role": "assistant", "content": text_to_speak})
            
            # Generate speech from text
            speech_file_path = await generate_speech_from_text(text_to_speak, voice="nova")
            
            # Check if this is an order confirmation
            confirmation_phrases = ["order confirmed", "confirmed the order", "‡§¨‡•Å‡§ï ‡§ï‡§∞ ‡§¶‡•á‡§Ç", "‡§π‡§æ‡§Ç ‡§¨‡•Å‡§ï ‡§ï‡§∞ ‡§¶‡•ã", 
                                 "‡§†‡•Ä‡§ï ‡§π‡•à, ‡§¨‡•Å‡§ï ‡§ï‡§∞ ‡§¶‡•ã", "‡§°‡§ø‡§≤‡•Ä‡§µ‡§∞‡•Ä ‡§ï‡§æ ‡§á‡§Ç‡§§‡§ú‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á", "‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡•Ä ‡§™‡•Å‡§∑‡•ç‡§ü‡§ø ‡§π‡•ã ‡§ó‡§à ‡§π‡•à"]
            order_confirmed = any(phrase in text_to_speak.lower() for phrase in confirmation_phrases)
            
            if order_confirmed:
                order_details["order_confirmed_status"] = True
                print("DEBUG_TWILIO_SPEECH: Detected order confirmation phrase.")
                
                # Send WhatsApp confirmation (in background, don't wait for it to complete)
                async def send_whatsapp_confirmation():
                    try:
                        print("DEBUG_TWILIO_SPEECH: Order confirmed. Sending WhatsApp...")
                        whatsapp_message = MESSAGES["hi"]["order_confirmed_shopkeeper"].format(
                            item_name=order_details["item_name"], 
                            quantity=order_details["quantity"], 
                            unit=order_details["unit"], 
                            supplier_name=order_details["supplier_name"]
                        )
                        await send_whatsapp_message(order_details["user_id"], whatsapp_message)
                        print("DEBUG_TWILIO_SPEECH: WhatsApp confirmation sent successfully")
                    except Exception as e:
                        print(f"ERROR_TWILIO_SPEECH: Failed to send WhatsApp: {str(e)}")
                        # If WhatsApp fails, we'll just log it and continue with the call
                
                # Start WhatsApp sending in the background
                asyncio.create_task(send_whatsapp_confirmation())
                
                # Ask for delivery time
                delivery_prompt = "‡§ï‡•É‡§™‡§Ø‡§æ ‡§°‡§ø‡§≤‡•Ä‡§µ‡§∞‡•Ä ‡§ï‡§æ ‡§∏‡§Æ‡§Ø ‡§¨‡§§‡§æ‡§è‡§Ç‡•§ ‡§ï‡§ø‡§§‡§®‡•á ‡§¶‡§ø‡§®‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§°‡§ø‡§≤‡•Ä‡§µ‡§∞‡•Ä ‡§π‡•ã ‡§∏‡§ï‡§§‡•Ä ‡§π‡•à?"
                text_to_speak = f"{text_to_speak} {delivery_prompt}"
                speech_file_path = await generate_speech_from_text(text_to_speak, voice="nova")
                
                # Don't mark as confirmed yet, wait for delivery time confirmation
                order_confirmed = False
            
            # Add the speech to the response
            if speech_file_path:
                audio_url = f"{BASE_URL}/audio/{os.path.basename(speech_file_path)}"
                voice_response.play(url=audio_url)
                print(f"DEBUG_TWILIO_SPEECH: Playing generated audio from {audio_url}")
            else:
                print("WARNING_TWILIO_SPEECH: TTS generation failed. Falling back to default TTS.")
                voice_response.say(text_to_speak, voice='Polly.Aditi', language='hi-IN')
            
            # Add a small pause before next action
            voice_response.pause(length=1)
            
            if order_confirmed:
                # After getting delivery time, confirm and end the call
                voice_response.say("‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶, ‡§Ü‡§™‡§ï‡§æ ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§ ‡§Ü‡§™‡§ï‡•ã ‡§è‡§ï ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ‡•á‡§∂‡§® ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§™‡§∞ ‡§≠‡•á‡§ú ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§ ‡§Ü‡§™‡§ï‡§æ ‡§¶‡§ø‡§® ‡§∂‡•Å‡§≠ ‡§π‡•ã‡•§", 
                                 voice='Polly.Aditi', 
                                 language='hi-IN')
                voice_response.hangup()
                
                # Clean up call state after a short delay
                async def cleanup_call_state():
                    await asyncio.sleep(5)  # Wait for the call to end
                    if call_sid in call_states:
                        del call_states[call_sid]
                        print(f"DEBUG_TWILIO_SPEECH: Cleaned up call state for {call_sid}")
                
                asyncio.create_task(cleanup_call_state())
            else:
                # Continue the conversation
                gather_action_url = f"{BASE_URL}/handle_twilio_speech?call_sid={call_sid}"
                voice_response.gather(
                    input='speech',
                    timeout=10,
                    speechTimeout='auto',
                    action=gather_action_url,
                    method='POST',
                    actionOnEmptyResult=True,
                    enhanced=True,
                    speechModel='phone_call',
                    language='hi-IN'
                )
                
                # Add a redirect as a fallback in case gather fails
                params = {
                    'item_name': order_details['item_name'],
                    'quantity': order_details['quantity'],
                    'unit': order_details['unit'],
                    'supplier_name': order_details['supplier_name'],
                    'user_id': order_details['user_id'],
                    'detected_language': order_details['detected_language']
                }
                encoded_params = urllib.parse.urlencode(params)
                voice_response.redirect(
                    method='POST',
                    url=f"{BASE_URL}/twilio_voice_webhook?{encoded_params}"
                )
            
        except Exception as e:
            print(f"ERROR_TWILIO_SPEECH: Error processing OpenAI response: {str(e)}")
            error_msg = "‡§Æ‡§æ‡§´‡§º ‡§ï‡•Ä‡§ú‡§ø‡§è, ‡§ï‡•Å‡§õ ‡§§‡§ï‡§®‡•Ä‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§•‡•ã‡§°‡§º‡•Ä ‡§¶‡•á‡§∞ ‡§¨‡§æ‡§¶ ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§"
            voice_response.say(error_msg, voice='Polly.Aditi', language='hi-IN')
            voice_response.hangup()
            
            # Clean up call state on error
            if call_sid in call_states:
                del call_states[call_sid]
                print(f"DEBUG_TWILIO_SPEECH: Call state cleaned up for {call_sid} due to error")
            if any(phrase in text_to_speak.lower() for phrase in confirmation_phrases):
                order_details["order_confirmed_status"] = True
                print("DEBUG_TWILIO_SPEECH: Detected order confirmation phrase.")
                
                # Send WhatsApp confirmation
                try:
                    print("DEBUG_TWILIO_SPEECH: Order confirmed. Sending WhatsApp and ending the call.")
                    whatsapp_message = MESSAGES["hi"]["order_confirmed_shopkeeper"].format(
                        item_name=order_details["item_name"], 
                        quantity=order_details["quantity"], 
                        unit=order_details["unit"], 
                        supplier_name=order_details["supplier_name"]
                    )
                    await send_whatsapp_message(order_details["user_id"], whatsapp_message)
                    
                    # Add confirmation to the response
                    text_to_speak += " ‡§Ü‡§™‡§ï‡•ã ‡§è‡§ï ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ‡•á‡§∂‡§® ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§™‡§∞ ‡§≠‡•á‡§ú ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§ ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶!"
                    speech_file_path = await generate_speech_from_text(text_to_speak, voice="nova")
                except Exception as e:
                    print(f"ERROR_TWILIO_SPEECH: Failed to send WhatsApp: {str(e)}")
                    text_to_speak += " ‡§≤‡•á‡§ï‡§ø‡§® ‡§µ‡•ç‡§π‡§æ‡§ü‡•ç‡§∏‡§è‡§™ ‡§ï‡§®‡•ç‡§´‡§∞‡•ç‡§Æ‡•á‡§∂‡§® ‡§≠‡•á‡§ú‡§®‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Æ‡•à‡§®‡•ç‡§Ø‡•Å‡§Ö‡§≤ ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§ö‡•á‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§"

            speech_file_path = await generate_speech_from_text(text_to_speak, voice="nova")
            if speech_file_path:
                voice_response.play(url=f"{BASE_URL}/audio/{os.path.basename(speech_file_path)}")
            else:
                voice_response.say(text_to_speak, voice='Polly.Aditi', language='hi-IN')
            
            voice_response.hangup()
            if call_sid in call_states: 
                del call_states[call_sid]
            return str(voice_response)
            
    else: # No speech was detected by <Gather>
        text_to_speak = "‡§Æ‡§æ‡§´‡§º ‡§ï‡•Ä‡§ú‡§ø‡§è, ‡§Æ‡•Å‡§ù‡•á ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∏‡•Å‡§®‡§æ‡§à ‡§®‡§π‡•Ä‡§Ç ‡§¶‡•Ä‡•§ ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§¶‡•ã‡§π‡§∞‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç?"
        conversation_history.append({"role": "assistant", "content": text_to_speak})

    # --- This block now runs for ALL continuing conversation turns ---
    ssml_response = f"<speak>{text_to_speak}<break time=\"1s\"/></speak>"
    speech_file_path = await generate_speech_from_text(ssml_response, voice="nova", is_ssml=True)
    
    if speech_file_path:
        voice_response.play(url=f"{BASE_URL}/audio/{os.path.basename(speech_file_path)}")
    else:
        voice_response.say(text_to_speak, voice='Polly.Aditi', language='hi-IN')

    # *** FIX: Always re-gather to keep the conversation going ***
    action_url = f"{BASE_URL}/handle_twilio_speech?call_sid={call_sid}"
    voice_response.gather(input='speech', speechTimeout='auto', action=action_url, method='POST')
    
    print(f"DEBUG_TWILIO_SPEECH: TwiML response (Continue): {str(voice_response)}")
    return str(voice_response)


@app.route("/audio/<filename>")
def serve_audio(filename):
    print(f"DEBUG: Serving audio file: {filename}")
    try:
        return send_from_directory('audio', filename)
    except Exception as e:
        print(f"ERROR: Failed to serve audio file {filename}: {str(e)}")
        return ("Audio file not found", 404)

# Function to run the scheduler in its own event loop
def _run_scheduler():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.call_soon_threadsafe(scheduler.start)
    loop.run_forever()

# Shut down the scheduler when the Flask app stops
@app.teardown_appcontext
def shutdown_scheduler(exception=None):
    if scheduler.running:
        scheduler.shutdown()
        print("Scheduler for low stock alerts has been shut down.")

async def generate_local_insights():
    """Generates local insights and personalized recommendations for all shopkeepers with stock, including weather-based, festival-based, and low-stock alerts."""
    print("DEBUG_INSIGHTS: Generating local insights...")
    unique_user_ids_raw = await get_all_unique_user_ids_with_stock()
    unique_user_ids = unique_user_ids_raw # Corrected: unique_user_ids_raw already contains strings

    # Fetch global data once
    latitude = SHOPKEEPER_LOCATION["latitude"]
    longitude = SHOPKEEPER_LOCATION["longitude"]
    weather_data = await get_weather_forecast(latitude, longitude)
    festivals_data = await get_festivals_from_llm(days_in_advance=60) # Increased days_in_advance to 60 for more festivals

    for user_id in unique_user_ids:
        print(f"DEBUG_INSIGHTS: Generating insights for user: {user_id}")
        insights = []
        recommendations = []
        all_recommended_item_names = set() # To keep track of all recommended items

        stock_levels = await get_stock_levels(user_id)
        stock_map = {item['item_name'].lower(): item for item in stock_levels}

        # --- Weather-based Insights and Recommendations ---
        if weather_data:
            current_temp = weather_data["current"]["temperature_2m"]
            print(f"DEBUG_WEATHER: Current temperature: {current_temp}¬∞C") # Added debug log for current temperature

            if current_temp > 30:
                insights.append("It's hot today!")

                # Get generic weather-based item suggestions from LLM
                generic_weather_recommendation_prompt = f"""Based on hot weather, suggest 2-3 popular items (not necessarily from any specific inventory) that a shopkeeper should promote. 
Respond as a comma-separated list of item names only, with no additional text."""
                llm_generic_weather_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests popular items based on weather conditions."},
                        {"role": "user", "content": generic_weather_recommendation_prompt}
                    ],
                    temperature=1.0,
                    max_tokens=100
                )
                generic_weather_recommended_items_str = llm_generic_weather_recommendation_response.choices[0].message.content.strip()
                print(f"DEBUG_LLM_RECOMMENDATION: LLM suggested generic items for hot weather: {generic_weather_recommended_items_str}")

                if generic_weather_recommended_items_str:
                    for item_name in [item.strip() for item in generic_weather_recommended_items_str.split(',')]:
                        all_recommended_item_names.add(item_name.lower())
                
                # Original inventory-specific recommendations (if still desired in primary recs)
                weather_recommendation_prompt = f"""Based on hot weather, suggest 2-3 specific items from the following inventory that a shopkeeper should promote. 
Inventory: {', '.join(stock_map.keys())}.
Respond as a comma-separated list of item names only, with no additional text. If no relevant items, respond with 'None'."""

                print(f"DEBUG_LLM_RECOMMENDATION: Prompt sent to LLM for hot weather: {weather_recommendation_prompt}") # Added logging for the prompt

                llm_weather_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests inventory items based on weather conditions."},
                        {"role": "user", "content": weather_recommendation_prompt}
                    ],
                    temperature=1.0, 
                    max_tokens=100
                )
                weather_recommended_items_str = llm_weather_recommendation_response.choices[0].message.content.strip()
                
                print(f"DEBUG_LLM_RECOMMENDATION: LLM recommended for hot weather: {weather_recommended_items_str}")

                if weather_recommended_items_str and weather_recommended_items_str.lower() != 'none':
                    weather_recommended_items_list = [item.strip().lower() for item in weather_recommended_items_str.split(',')]
                    found_weather_recommendations = False
                    for recommended_item_name in weather_recommended_items_list:
                        matched_item = next((item_name for item_name in stock_map if fuzz.token_sort_ratio(recommended_item_name, item_name) >= 70), None)
                        if matched_item:
                            item_details = stock_map[matched_item]
                            suggested_price = item_details.get("cost_price_per_unit", 0) * 1.20 # 20% markup for weather items
                            recommendations.append(f"Suggest selling {item_details['item_name']} for ‚Çπ{suggested_price:.2f} per {item_details['unit']} due to hot weather.")
                            # all_recommended_item_names.add(item_details['item_name'].lower()) # Already added above for generic
                            found_weather_recommendations = True
                    if not found_weather_recommendations:
                        # Ensure at least one recommendation is added for weather even if specific inventory items aren't matched
                        recommendations.append(f"Consider stocking popular items like {weather_recommended_items_str if weather_recommended_items_str else 'cold drinks and ice cream'} due to hot weather.")
                else:
                    recommendations.append("Consider stocking cold drinks and ice cream due to hot weather.")
                print("DEBUG_WEATHER_RECOMMENDATIONS_GENERATED: Weather-based recommendations added.") # Debug log

            elif current_temp < 15:
                insights.append("It's chilly!")

                # Get generic weather-based item suggestions from LLM
                generic_weather_recommendation_prompt = f"""Based on chilly weather, suggest 2-3 popular items (not necessarily from any specific inventory) that a shopkeeper should promote. 
Respond as a comma-separated list of item names only, with no additional text."""
                llm_generic_weather_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests popular items based on weather conditions."},
                        {"role": "user", "content": generic_weather_recommendation_prompt}
                    ],
                    temperature=1.0,
                    max_tokens=100
                )
                generic_weather_recommended_items_str = llm_generic_weather_recommendation_response.choices[0].message.content.strip()
                print(f"DEBUG_LLM_RECOMMENDATION: LLM suggested generic items for chilly weather: {generic_weather_recommended_items_str}")

                if generic_weather_recommended_items_str:
                    for item_name in [item.strip() for item in generic_weather_recommended_items_str.split(',')]:
                        all_recommended_item_names.add(item_name.lower())

                # Original inventory-specific recommendations (if still desired in primary recs)
                weather_recommendation_prompt = f"""Based on chilly weather, suggest 2-3 specific items from the following inventory that a shopkeeper should promote. 
Inventory: {', '.join(stock_map.keys())}.
Respond as a comma-separated list of item names only, with no additional text. If no relevant items, respond with 'None'."""

                print(f"DEBUG_LLM_RECOMMENDATION: Prompt sent to LLM for chilly weather: {weather_recommendation_prompt}") # Added logging for the prompt

                llm_weather_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests inventory items based on weather conditions."},
                        {"role": "user", "content": weather_recommendation_prompt}
                    ],
                    temperature=1.0, 
                    max_tokens=100
                )
                weather_recommended_items_str = llm_weather_recommendation_response.choices[0].message.content.strip()
                print(f"DEBUG_LLM_RECOMMENDATION: LLM recommended for chilly weather: {weather_recommended_items_str}")

                if weather_recommended_items_str and weather_recommended_items_str.lower() != 'none':
                    weather_recommended_items_list = [item.strip().lower() for item in weather_recommended_items_str.split(',')]
                    found_weather_recommendations = False
                    for recommended_item_name in weather_recommended_items_list:
                        matched_item = next((item_name for item_name in stock_map if fuzz.token_sort_ratio(recommended_item_name, item_name) >= 70), None)
                        if matched_item:
                            item_details = stock_map[matched_item]
                            suggested_price = item_details.get("cost_price_per_unit", 0) * 1.15 # 15% markup for weather items
                            recommendations.append(f"Suggest selling {item_details['item_name']} for ‚Çπ{suggested_price:.2f} per {item_details['unit']} due to chilly weather.")
                            # all_recommended_item_names.add(item_details['item_name'].lower()) # Already added above for generic
                            found_weather_recommendations = True
                    if not found_weather_recommendations:
                        # Ensure at least one recommendation is added for weather even if specific inventory items aren't matched
                        recommendations.append(f"Consider stocking popular items like {weather_recommended_items_str if weather_recommended_items_str else 'warm beverages and comfort food'} due to chilly weather.")
                else:
                    recommendations.append("Consider stocking warm beverages and comfort food due to chilly weather.")
                print("DEBUG_WEATHER_RECOMMENDATIONS_GENERATED: Weather-based recommendations added.") # Debug log

        # --- Festival-based Insights and Recommendations ---
        if festivals_data:
            for festival in festivals_data[:5]: # Limit to 5 festivals
                festival_name = festival.get("name")
                festival_date_info = festival.get("date", "")
                insights.append(f"Upcoming festival: {festival_name} (around {festival_date_info}).")

                # Get generic festival-based item suggestions from LLM
                generic_festival_recommendation_prompt = f"""For the upcoming festival '{festival_name}' (around {festival_date_info}), suggest 2-3 generic items (not necessarily from any specific inventory) that a shopkeeper should promote. 
Consider items that are commonly used as ingredients for sweets, special dishes, traditional offerings, or festive decorations during Indian festivals. 
Respond as a comma-separated list of item names only, with no additional text."""
                llm_generic_festival_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests popular items for Indian festivals."},
                        {"role": "user", "content": generic_festival_recommendation_prompt}
                    ],
                    temperature=1.0,
                    max_tokens=100
                )
                generic_festival_recommended_items_str = llm_generic_festival_recommendation_response.choices[0].message.content.strip()
                print(f"DEBUG_LLM_RECOMMENDATION: LLM suggested generic items for {festival_name}: {generic_festival_recommended_items_str}")

                if generic_festival_recommended_items_str:
                    for item_name in [item.strip() for item in generic_festival_recommended_items_str.split(',')]:
                        all_recommended_item_names.add(item_name.lower())

                # Original inventory-specific recommendations (if still desired in primary recs)
                inventory_items = ", ".join(stock_map.keys())
                recommendation_prompt = f"""For the upcoming festival '{festival_name}' (around {festival_date_info}), suggest 2-3 specific items from the following inventory that a shopkeeper should promote. 
Consider items that are commonly used as ingredients for sweets, special dishes, or other relevant preparations during Indian festivals.
Inventory: {inventory_items}.
Respond as a comma-separated list of item names only, with no additional text. If no relevant items, respond with 'None'."""
                
                print(f"DEBUG_LLM_RECOMMENDATION: Prompt sent to LLM for {festival_name}: {recommendation_prompt}") # Added logging for the prompt

                llm_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests inventory items for festivals."},
                        {"role": "user", "content": recommendation_prompt}
                    ],
                    temperature=1.0, 
                    max_tokens=100
                )

                recommended_items_str = llm_recommendation_response.choices[0].message.content.strip()

                print(f"DEBUG_LLM_RECOMMENDATION: LLM recommended for {festival_name}: {recommended_items_str}")

                if recommended_items_str and recommended_items_str.lower() != 'none':
                    recommended_items_list = [item.strip().lower() for item in recommended_items_str.split(',')]
                    found_recommendations = False
                    for recommended_item_name in recommended_items_list:
                        matched_item = next((item_name for item_name in stock_map if fuzz.token_sort_ratio(recommended_item_name, item_name) >= 70), None)
                        if matched_item:
                            item_details = stock_map[matched_item]
                            suggested_price = item_details.get("cost_price_per_unit", 0) * 1.15 # 15% markup for festival items
                            recommendations.append(f"Promote {item_details['item_name']} for {festival_name} at ‚Çπ{suggested_price:.2f} per {item_details['unit']}.")
                            all_recommended_item_names.add(item_details['item_name'].lower())
                            found_recommendations = True
                    if not found_recommendations:
                        recommendations.append(f"Consider stocking items like {recommended_items_str} for the upcoming {festival_name}.")
                else:
                    recommendations.append(f"Consider stocking general festival items for the upcoming {festival_name}.")
        
        # --- Low Stock Alert (Integrated) ---
        critical_low_stock_items = []
        for item_name, item_details in stock_map.items():
            if item_details.get("quantity", 0) < item_details.get("min_quantity_threshold", 0):
                critical_low_stock_items.append(item_details)

        recommended_items_for_stocking_consideration = set()
        for recommended_item_name in all_recommended_item_names:
            recommended_items_for_stocking_consideration.add(recommended_item_name)
        
        low_stock_alert_message = ""
        low_stock_message_parts = []

        if critical_low_stock_items:
            print(f"DEBUG_INSIGHTS: Found critical low stock items for {user_id}: {critical_low_stock_items}")
            low_stock_message_parts.append("‚ö†Ô∏è **‡§ï‡§Æ ‡§∏‡•ç‡§ü‡•â‡§ï ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡•Ä!** ‡§®‡§ø‡§Æ‡•ç‡§®‡§≤‡§ø‡§ñ‡§ø‡§§ ‡§Ü‡§á‡§ü‡§Æ ‡§ï‡§Æ ‡§π‡•ã ‡§∞‡§π‡•á ‡§π‡•à‡§Ç:") # Bold for emphasis
            for item in critical_low_stock_items:
                item_name = item['item_name']
                quantity = item['quantity']
                unit = item['unit']
                min_threshold = item['min_quantity_threshold']

                cheapest_supplier_info = await find_cheapest_supplier_for_item(item_name, unit)
                supplier_details = ""
                if cheapest_supplier_info:
                    supplier_name = cheapest_supplier_info["supplier_name"]
                    price = cheapest_supplier_info["price_per_unit"]
                    supplier_phone = cheapest_supplier_info["phone"]
                    supplier_details = f" (‡§∏‡§¨‡§∏‡•á ‡§∏‡§∏‡•ç‡§§‡§æ: {supplier_name}, ‚Çπ{price:.2f}/{unit}, ‡§ï‡•â‡§≤: {supplier_phone})"
                low_stock_message_parts.append(f"‚Ä¢ {item_name}: {quantity} {unit} (‡§®‡•ç‡§Ø‡•Ç‡§®‡§§‡§Æ: {min_threshold} {unit}){supplier_details}")
            low_stock_message_parts.append("‡§ú‡§≤‡•ç‡§¶ ‡§π‡•Ä ‡§ë‡§∞‡•ç‡§°‡§∞ ‡§ï‡§∞‡§®‡•á ‡§™‡§∞ ‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§ï‡§∞‡•á‡§Ç‡•§") # Closing sentence
        
        if recommended_items_for_stocking_consideration:
            if low_stock_message_parts: # Add a separator if there are critical low stock items
                low_stock_message_parts.append("\n") 
            low_stock_message_parts.append("‚ú® **‡§µ‡§ø‡§ö‡§æ‡§∞ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ö‡§®‡•Å‡§∂‡§Ç‡§∏‡§ø‡§§ ‡§Ü‡§á‡§ü‡§Æ:**") # New section title
            
            # Prioritize items not in stock, then add other recommended items, limit to 5
            not_in_stock_items = []
            in_stock_items = []
            for rec_item_name in recommended_items_for_stocking_consideration:
                if rec_item_name in stock_map:
                    item_details = stock_map[rec_item_name]
                    if item_details.get("quantity", 0) <= 0: # Treat zero quantity as not in stock for recommendation purposes
                        not_in_stock_items.append(rec_item_name)
                    else:
                        in_stock_items.append(rec_item_name)
                else:
                    not_in_stock_items.append(rec_item_name)
            
            # Combine and limit the list
            final_recommended_items = not_in_stock_items + in_stock_items
            for rec_item_name in final_recommended_items[:5]: # Limit to 5 items
                if rec_item_name in stock_map:
                    item_details = stock_map[rec_item_name]
                    status = "(‡§Ü‡§™‡§ï‡•á ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•á‡§Ç)" if item_details.get("quantity", 0) > 0 else "(‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç/‡§ï‡§Æ)"
                    low_stock_message_parts.append(f"‚Ä¢ {item_details['item_name']} {status}")
                else:
                    low_stock_message_parts.append(f"‚Ä¢ {rec_item_name} (‡§Ü‡§™‡§ï‡•á ‡§∏‡•ç‡§ü‡•â‡§ï ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç)")

        if low_stock_message_parts:
            low_stock_alert_message = "\n".join(low_stock_message_parts)

        # --- Construct and Send Final Message ---
        final_message_parts = []
        if insights:
            final_message_parts.append("--- Local Insights ---")
            final_message_parts.extend([f"- {insight}" for insight in insights])
        if recommendations:
            final_message_parts.append("\n--- Recommendations for you ---")
            final_message_parts.extend([f"- {rec}" for rec in recommendations])
        
        # Append low stock alert after insights and recommendations
        if low_stock_alert_message:
            if final_message_parts: # Add a separator if there are previous messages
                final_message_parts.append("\n") 
            final_message_parts.append("--- Stocking Suggestions ---") # Changed section title
            final_message_parts.append(low_stock_alert_message)

        final_message_body = "\n".join(final_message_parts)

        if final_message_body:
            await send_whatsapp_message(user_id, final_message_body)
        else:
            print(f"DEBUG_INSIGHTS: No specific local insights or recommendations generated for {user_id} at this time.")

if __name__ == "__main__":
    # Initialize and start the scheduler when the app starts
    if not scheduler.running:
        scheduler.add_job(generate_local_insights, 'interval', seconds=30)
        # Removed the low stock alert scheduler job
        # scheduler.add_job(check_low_stock_and_alert, 'interval', seconds=30, id='check_low_stock_and_alert', replace_existing=True)
        scheduler_thread = Thread(target=_run_scheduler)
        scheduler_thread.daemon = True
        scheduler_thread.start()
        print("Scheduler for low stock alerts has been started in a separate thread.")

    # Run the Flask app
    # Using debug=True is helpful for development as it provides detailed errors
    # and automatically reloads the server when you make code changes.
    # Make sure to set debug=False for a production environment.
    app.run(debug=True, host="0.0.0.0", port=5000)