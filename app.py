import asyncio
import copy
from datetime import date, datetime, timedelta
import logging
import os
import re
import urllib.parse
from threading import Thread

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from dotenv import load_dotenv
from flask import Flask, request, send_from_directory
from fuzzywuzzy import fuzz
from openai import OpenAI
from pydub import AudioSegment
import requests
from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_fixed
from twilio.rest import Client
from twilio.twiml.messaging_response import MessagingResponse
from twilio.twiml.voice_response import VoiceResponse
# import google.generativeai as genai # Removed Google Generative AI import

from call_handler import initiate_outbound_call
from data_extractor import (
    extract_items_from_bill_image,
    extract_structured_data,
    transcribe_audio,
)
from supabase_client import (
    get_daily_sales_summary,
    get_low_stock_items,
    get_stock_levels,
    get_user_transactions_summary,
    save_transaction,
    supabase,
    update_stock_item,
    get_all_unique_user_ids_with_stock,
)
from weather_events_api import get_weather_forecast, get_festivals_from_llm

# FFmpeg path configuration
ffmpeg_bin_path = r"C:\Users\singh\Downloads\ffmpeg-8.0-essentials_build\ffmpeg-8.0-essentials_build\bin"
if ffmpeg_bin_path not in os.environ["PATH"]:
    os.environ["PATH"] += os.pathsep + ffmpeg_bin_path
    print(f"DEBUG: Added {ffmpeg_bin_path} to PATH for Flask app.")

load_dotenv()

# !! IMPORTANT !!
# Replace this with your actual public URL (e.g., from ngrok or your deployed server)
BASE_URL = "https://523af0195609.ngrok-free.app"

SHOPKEEPER_LOCATION = {"latitude": 28.7041, "longitude": 77.1025} # Default to Delhi, India
DEFAULT_LANGUAGE = "hi" # Define default language

client = OpenAI() # Re-initialize OpenAI client
# Removed Google Generative AI client configuration
# genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
# gemini_model = genai.GenerativeModel("gemini-2.5-pro") # Removed Gemini model initialization

app = Flask(__name__)
scheduler = AsyncIOScheduler() # Initialize scheduler here

TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID")
TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")
TWILIO_WHATSAPP_NUMBER = os.getenv("TWILIO_WHATSAPP_NUMBER")
TWILIO_PHONE_NUMBER = os.getenv("TWILIO_PHONE_NUMBER") # Twilio Voice enabled phone number
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

twilio_client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)

# Configure logging
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

language_map = {"en": "en", "english": "en", "hi": "hi", "hindi": "hi",
                "pa": "pa", "punjabi": "pa", "gu": "gu", "gujarati": "gu",
                "ta": "ta", "tamil": "ta", "te": "te", "telugu": "te",
                "bn": "bn", "bengali": "bn", "mr": "mr", "marathi": "mr",
                "ur": "hi", "urdu": "hi"}

MESSAGES = {
    "en": {
        "sale_success": "тЬЕ Sale of тВ╣{amount:.2f} recorded for:\n{item_details}",
        "sale_success_no_item": "тЬЕ Sale of тВ╣{amount:.2f} added to your records.",
        "expense_success": "тЬЕ Expense of тВ╣{amount} ({item}) recorded.",
        "expense_success_no_item": "тЬЕ Expense of тВ╣{amount} recorded.",
        "balance_inquiry": "ЁЯУК Your current digital khata balance is тВ╣{balance:.2f}.\n\nRecent Transactions:\n{transactions_summary}",
        "earnings_summary": "ЁЯУИ Today's total sales: тВ╣{total_sales:.2f}.\n\nToday's transactions:\n{sales_details}",
        "extract_fail": "Could not extract structured data from your message. Please be more specific (e.g., 'Sold 1kg sugar for 50 rupees').",
        "transcribe_fail": "Could not understand your voice note. The audio quality might be poor or not in a supported language.",
        "download_fail": "Failed to download your voice note: {error_msg}. Please try again.",
        "network_error": "A network error occurred while downloading your voice note: {error_msg}. Please try again.",
        "file_error": "There was an issue with the voice note file: {error_msg}. Please try sending it again.",
        "unexpected_error": "An unexpected error occurred while processing your voice note. Please try again.",
        "no_voice_note": "Please send a voice note for transaction processing or a text message for balance inquiry.",
        "unsupported_media": "Unsupported media type: {media_type}. Please send a voice note or an image.",
        "no_transactions_found": "No recent transactions found.",
        "no_sales_found_today": "No sales found today.",
        "image_received_stock_update": "Image received! Processing for stock update...",
        "stock_update_success": "тЬЕ Stock updated successfully for: {updates}.",
        "stock_update_fail": "тЭМ Failed to update stock from image. Error: {error_msg}",
        "file_download_error": "Failed to download your image: {error_msg}. Please try again.",
        "welcome": "Hello! I'm your inventory management bot. How can I help you?",
        "stock_updated": "Stock for {item_name} updated successfully. Current quantity: {current_quantity} {unit}.",
        "sale_recorded": "Sale of {quantity} {unit} of {item_name} recorded. Remaining stock: {current_quantity} {unit}. Total sale amount: {selling_amount}. Profit: {profit}.",
        "purchase_recorded": "Purchase of {quantity} {unit} of {item_name} recorded. New stock: {current_quantity} {unit}. Cost: {cost_price_per_unit} per {unit}.",
        "item_not_found": "'{item_name}' not found in stock. Would you like to add it?",
        "unknown_command": "I didn't understand that. Please try again or type 'help'.",
        "current_stock": "Current stock for {item_name}: {current_quantity} {unit}.",
        "all_stock_items": "Your current stock:\n{stock_list}",
        "daily_summary": "Daily Sales Summary for {date}:\nTotal Sales: {total_sales}\nTotal Profit: {total_profit}\n{sales_details}",
        "low_stock_alert": "тЪая╕П Low stock alert! The following items are running low:\n{low_stock_items_list}\nPlease consider ordering soon.",
        "call_initiated": "Initiating call to {supplier_name} at {supplier_phone_number} for {quantity} {unit} of {item_name}. I will notify you once the order is confirmed.",
        "order_confirmation_prompt": "Which item and supplier would you like to confirm an order for? Example: 'Order 10 kg rice from Supplier A'.",
        "order_confirmed_shopkeeper": "тЬЕ Order for {quantity} {unit} of {item_name} from {supplier_name} confirmed. Expect delivery in 2 days.",
        "order_failed_shopkeeper": "тЭМ Failed to confirm order for {item_name} from {supplier_name}. Reason: {reason}"
    },
    "hi": {
        "sale_success": "тЬЕ тВ╣{amount:.2f} рдХреА рдмрд┐рдХреНрд░реА рджрд░реНрдЬ рдХреА рдЧрдИ:\n{item_details}",
        "sale_success_no_item": "тЬЕ рдЖрдкрдХреЗ рдбрд┐рдЬрд┐рдЯрд▓ рдЦрд╛рддреЗ рдореЗрдВ тВ╣{amount:.2f} рдХреА рдмрд┐рдХреНрд░реА рджрд░реНрдЬ рдХреА рдЧрдИред",
        "expense_success": "тЬЕ рдЖрдкрдХреЗ рдбрд┐рдЬрд┐рдЯрд▓ рдЦрд╛рддреЗ рдореЗрдВ тВ╣{amount} ({item}) рдХрд╛ рдЦрд░реНрдЪ рджрд░реНрдЬ рдХрд┐рдпрд╛ рдЧрдпрд╛ред",
        "expense_success_no_item": "тЬЕ рдЖрдкрдХреЗ рдбрд┐рдЬрд┐рдЯрд▓ рдЦрд╛рддреЗ рдореЗрдВ тВ╣{amount} рдХрд╛ рдЦрд░реНрдЪ рджрд░реНрдЬ рдХрд┐рдпрд╛ рдЧрдпрд╛ред",
        "balance_inquiry": "ЁЯУК рдЖрдкрдХреЗ рдбрд┐рдЬрд┐рдЯрд▓ рдЦрд╛рддреЗ рдореЗрдВ рд╡рд░реНрддрдорд╛рди рд╢реЗрд╖ рд░рд╛рд╢рд┐ тВ╣{balance:.2f} рд╣реИред\n\nрдкрд┐рдЫрд▓реЗ рд▓реЗрдирджреЗрди:\n{transactions_summary}",
        "earnings_summary": "ЁЯУИ рдЖрдЬ рдХреА рдХреБрд▓ рдмрд┐рдХреНрд░реА: тВ╣{total_sales:.2f}ред\n\nрдЖрдЬ рдХреЗ рд▓реЗрдирджреЗрди:\n{sales_details}",
        "extract_fail": "рдЖрдкрдХреЗ рд╕рдВрджреЗрд╢ рд╕реЗ рдЬрд╛рдирдХрд╛рд░реА рдирд╣реАрдВ рдирд┐рдХрд╛рд▓реА рдЬрд╛ рд╕рдХреАред рдХреГрдкрдпрд╛ рдЕрдзрд┐рдХ рд╡рд┐рд╢рд┐рд╖реНрдЯ рд░рд╣реЗрдВ (рдЙрджрд╛рд╣рд░рдг рдХреЗ рд▓рд┐рдП, '50 рд░реБрдкрдпреЗ рдореЗрдВ 1 рдХрд┐рд▓реЛ рдЪреАрдиреА рдмреЗрдЪреА')ред",
        "transcribe_fail": "рдЖрдкрдХреЗ рд╡реЙрдЗрд╕ рдиреЛрдЯ рдХреЛ рд╕рдордЭрд╛ рдирд╣реАрдВ рдЬрд╛ рд╕рдХрд╛ред рдСрдбрд┐рдпреЛ рдЧреБрдгрд╡рддреНрддрд╛ рдЦрд░рд╛рдм рд╣реЛ рд╕рдХрддреА рд╣реИ рдпрд╛ рдпрд╣ рд╕рдорд░реНрдерд┐рдд рднрд╛рд╖рд╛ рдореЗрдВ рдирд╣реАрдВ рд╣реИред",
        "download_fail": "рдЖрдкрдХрд╛ рд╡реЙрдЗрд╕ рдиреЛрдЯ рдбрд╛рдЙрдирд▓реЛрдб рдирд╣реАрдВ рд╣реЛ рд╕рдХрд╛: {error_msg}ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
        "network_error": "рдЖрдкрдХрд╛ рд╡реЙрдЗрд╕ рдиреЛрдЯ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░рддреЗ рд╕рдордп рдиреЗрдЯрд╡рд░реНрдХ рддреНрд░реБрдЯрд┐ рд╣реБрдИ: {error_msg}ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
        "file_error": "рд╡реЙрдЗрд╕ рдиреЛрдЯ рдлрд╝рд╛рдЗрд▓ рдореЗрдВ рд╕рдорд╕реНрдпрд╛ рдереА: {error_msg}ред рдХреГрдкрдпрд╛ рдЗрд╕реЗ рдлрд┐рд░ рд╕реЗ рднреЗрдЬреЗрдВред",
        "unexpected_error": "рдПрдХ рдЕрдкреНрд░рддреНрдпрд╛рд╢рд┐рдд рддреНрд░реБрдЯрд┐ рд╣реБрдИред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
        "no_voice_note": "рдХреГрдкрдпрд╛ рд▓реЗрдирджреЗрди рдХреЗ рд▓рд┐рдП рдПрдХ рд╡реЙрдЗрд╕ рдиреЛрдЯ рднреЗрдЬреЗрдВ рдпрд╛ рд╢реЗрд╖ рд░рд╛рд╢рд┐ рдЬрд╛рдирдиреЗ рдХреЗ рд▓рд┐рдП рдЯреЗрдХреНрд╕реНрдЯ рдореИрд╕реЗрдЬ рдХрд░реЗрдВред",
        "unsupported_media": "рдЕрд╕рдорд░реНрдерд┐рдд рдореАрдбрд┐рдпрд╛ рдкреНрд░рдХрд╛рд░: {media_type}ред рдХреГрдкрдпрд╛ рдПрдХ рд╡реЙрдЗрд╕ рдиреЛрдЯ рдпрд╛ рдПрдХ рдЗрдореЗрдЬ рднреЗрдЬреЗрдВред",
        "no_transactions_found": "рдХреЛрдИ рд╣рд╛рд▓рд┐рдпрд╛ рд▓реЗрдирджреЗрди рдирд╣реАрдВ рдорд┐рд▓рд╛ред",
        "no_sales_found_today": "рдЖрдЬ рдХреЛрдИ рдмрд┐рдХреНрд░реА рджрд░реНрдЬ рдирд╣реАрдВ рдХреА рдЧрдИред",
        "image_received_stock_update": "рдЫрд╡рд┐ рдкреНрд░рд╛рдкреНрдд рд╣реБрдИ! рд╕реНрдЯреЙрдХ рдЕрдкрдбреЗрдЯ рдХреЗ рд▓рд┐рдП рдкреНрд░рд╕рдВрд╕реНрдХрд░рдг рд╣реЛ рд░рд╣рд╛ рд╣реИ...",
        "stock_update_success": "тЬЕ рд╕реНрдЯреЙрдХ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЕрдкрдбреЗрдЯ рдХрд┐рдпрд╛ рдЧрдпрд╛: {updates}.",
        "stock_update_fail": "тЭМ рдЫрд╡рд┐ рд╕реЗ рд╕реНрдЯреЙрдХ рдЕрдкрдбреЗрдЯ рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред рддреНрд░реБрдЯрд┐: {error_msg}",
        "file_download_error": "рдЖрдкрдХреА рдЫрд╡рд┐ рдбрд╛рдЙрдирд▓реЛрдб рдирд╣реАрдВ рд╣реЛ рд╕рдХреА: {error_msg}ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
        "welcome": "рдирдорд╕реНрддреЗ! рдореИрдВ рдЖрдкрдХреА рдЗрдиреНрд╡реЗрдВрдЯреНрд░реА рдкреНрд░рдмрдВрдзрди рдмреЙрдЯ рд╣реВрдБред рдореИрдВ рдЖрдкрдХреА рдХреИрд╕реЗ рдорджрдж рдХрд░ рд╕рдХрддреА рд╣реВрдБ?",
        "stock_updated": "{item_name} рдХрд╛ рд╕реНрдЯреЙрдХ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЕрдкрдбреЗрдЯ рдХрд┐рдпрд╛ рдЧрдпрд╛ред рд╡рд░реНрддрдорд╛рди рдорд╛рддреНрд░рд╛: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} рдХреА рдмрд┐рдХреНрд░реА рджрд░реНрдЬ рдХреА рдЧрдИред рд╢реЗрд╖ рд╕реНрдЯреЙрдХ: {current_quantity} {unit}. рдХреБрд▓ рдмрд┐рдХреНрд░реА рд░рд╛рд╢рд┐: {selling_amount}. рд▓рд╛рдн: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} рдХреА рдЦрд░реАрдж рджрд░реНрдЬ рдХреА рдЧрдИред рдирдпрд╛ рд╕реНрдЯреЙрдХ: {current_quantity} {unit}. рд▓рд╛рдЧрдд: {cost_price_per_unit} рдкреНрд░рддрд┐ {unit}.",
        "item_not_found": "'{item_name}' рдЖрдЗрдЯрдо рд╕реНрдЯреЙрдХ рдореЗрдВ рдирд╣реАрдВ рдорд┐рд▓рд╛ред рдХреНрдпрд╛ рдЖрдк рдЗрд╕реЗ рдЬреЛрдбрд╝рдирд╛ рдЪрд╛рд╣реЗрдВрдЧреЗ?",
        "unknown_command": "рдореБрдЭреЗ рд╕рдордЭ рдирд╣реАрдВ рдЖрдпрд╛ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВ рдпрд╛ 'рд╕рд╣рд╛рдпрддрд╛' рдЯрд╛рдЗрдк рдХрд░реЗрдВред",
        "current_stock": "{item_name} рдХрд╛ рд╡рд░реНрддрдорд╛рди рд╕реНрдЯреЙрдХ: {current_quantity} {unit}.",
        "all_stock_items": "рдЖрдкрдХрд╛ рд╡рд░реНрддрдорд╛рди рд╕реНрдЯреЙрдХ:\n{stock_list}",
        "daily_summary": "{date} рдХреЗ рд▓рд┐рдП рджреИрдирд┐рдХ рдмрд┐рдХреНрд░реА рд╕рд╛рд░рд╛рдВрд╢:\nрдХреБрд▓ рдмрд┐рдХреНрд░реА: {total_sales}\nрдХреБрд▓ рд▓рд╛рдн: {total_profit}\n{sales_details}",
        "low_stock_alert": "тЪая╕П рдХрдо рд╕реНрдЯреЙрдХ рдЪреЗрддрд╛рд╡рдиреА! рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рдЖрдЗрдЯрдо рдХрдо рд╣реЛ рд░рд╣реЗ рд╣реИрдВ:\n{low_stock_items_list}\nрдЬрд▓реНрдж рд╣реА рдСрд░реНрдбрд░ рдХрд░рдиреЗ рдкрд░ рд╡рд┐рдЪрд╛рд░ рдХрд░реЗрдВред",
        "call_initiated": "рдирдорд╕реНрддреЗ, рдореИрдВ рдЧреБрдкреНрддрд╛ рдХрд┐рд░рд╛рдирд╛ рд╕реНрдЯреЛрд░ рд╕реЗ рд░рдорд╛ рдмрд╛рдд рдХрд░ рд░рд╣реА рд╣реВрдБред рдХреНрдпрд╛ рдореИрдВ {supplier_name} рд╕реЗ рдмрд╛рдд рдХрд░ рд╕рдХрддреА рд╣реВрдБ?",
        "order_confirmation_prompt": "рдЖрдк рдХрд┐рд╕ рдЖрдЗрдЯрдо рдФрд░ рдЖрдкреВрд░реНрддрд┐рдХрд░реНрддрд╛ рдХреЗ рд▓рд┐рдП рдСрд░реНрдбрд░ рдХреА рдкреБрд╖реНрдЯрд┐ рдХрд░рдирд╛ рдЪрд╛рд╣реЗрдВрдЧреЗ? рдЙрджрд╛рд╣рд░рдг: 'рд╕рдкреНрд▓рд╛рдпрд░ рдП рд╕реЗ 10 рдХрд┐рд▓реЛ рдЪрд╛рд╡рд▓ рдСрд░реНрдбрд░ рдХрд░реЗрдВ'ред",
        "order_confirmed_shopkeeper": "тЬЕ {item_name} рдХреЗ {quantity} {unit} рдХрд╛ {supplier_name} рд╕реЗ рдСрд░реНрдбрд░ рдкреБрд╖реНрдЯ рд╣реЛ рдЧрдпрд╛ рд╣реИред рд╕реНрдЯреЙрдХ рдЕрдкрдбреЗрдЯ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред рдбрд┐рд▓реАрд╡рд░реА 2 рджрд┐рдиреЛрдВ рдореЗрдВ рдЕрдкреЗрдХреНрд╖рд┐рдд рд╣реИред",
        "order_failed_shopkeeper": "тЭМ Failed to confirm order for {item_name} from {supplier_name}. Reason: {reason}"
    },
    "pa": { # Punjabi messages
        "sale_success": "тЬЕ ридрйБри╣ри╛рибрйЗ рибри┐риЬрйАриЯри▓ риЦри╛ридрйЗ ри╡ри┐рй▒риЪ тВ╣{amount:.2f} ({item}) рижрйА ри╡ри┐риХри░рйА рижри░риЬ риХрйАридрйА риЧриИред",
        "sale_success_no_item": "тЬЕ ридрйБри╣ри╛рибрйЗ рибри┐риЬрйАриЯри▓ риЦри╛ридрйЗ ри╡ри┐рй▒риЪ тВ╣{amount:.2f} рижрйА ри╡ри┐риХри░рйА рижри░риЬ риХрйАридрйА риЧриИред",
        "expense_success": "тЬЕ ридрйБри╣ри╛рибрйЗ рибри┐риЬрйАриЯри▓ риЦри╛ридрйЗ ри╡ри┐рй▒риЪ тВ╣{amount} ({item}) рижри╛ риЦри░риЪ рижри░риЬ риХрйАридри╛ риЧри┐риЖред",
        "expense_success_no_item": "тЬЕ ридрйБри╣ри╛рибрйЗ рибри┐риЬрйАриЯри▓ риЦри╛ридрйЗ ри╡ри┐рй▒риЪ тВ╣{amount} рижри╛ риЦри░риЪ рижри░риЬ риХрйАридри╛ риЧри┐риЖред",
        "balance_inquiry": "ЁЯУК ридрйБри╣ри╛рибрйЗ рибри┐риЬрйАриЯри▓ риЦри╛ридрйЗ ри╡ри┐рй▒риЪ ри╡ри░ридриори╛рии римриХри╛риЗриЖ тВ╣{balance:.2f} ри╣рйИред\n\nрикри┐риЫри▓рйЗ ри▓рйИриг-рижрйЗриг:\n{transactions_summary}",
        "extract_fail": "ридрйБри╣ри╛рибрйЗ ри╕рйБриирйЗри╣рйЗ ридрйЛриВ риЬри╛ригриХри╛ри░рйА риири╣рйАриВ риХрй▒риврйА риЬри╛ ри╕риХрйАред риХри┐ри░рикри╛ риХри░риХрйЗ ри╕рикри╕ри╝риЯ римрйЛри▓рйЛред",
        "transcribe_fail": "ридрйБри╣ри╛рибрйЗ ри╡рйМриЗри╕ риирйЛриЯ риирйВрй░ риЯрйНри░ри╛риВри╕риХрйНри░ри╛риИрим риЬри╛риВ риЕриирйБри╡ри╛риж риири╣рйАриВ риХрйАридри╛ риЬри╛ ри╕риХри┐риЖред риЖрибрйАриУ риЧрйБригри╡рй▒ридри╛ риЦри░ри╛рим ри╣рйЛ ри╕риХрижрйА ри╣рйИред",
        "download_fail": "ридрйБри╣ри╛рибри╛ ри╡рйМриЗри╕ риирйЛриЯ рибри╛риКриири▓рйЛриб риири╣рйАриВ ри╣рйЛ ри╕риХри┐риЖ: {error_msg}ред риХри┐ри░рикри╛ риХри░риХрйЗ рижрйБримри╛ри░ри╛ риХрйЛри╕ри╝ри┐ри╕ри╝ риХри░рйЛред",
        "network_error": "ридрйБри╣ри╛рибри╛ ри╡рйМриЗри╕ рдиреЛрдЯ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░рддреЗ рд╕рдордп рдиреЗрдЯрд╡рд░реНрдХ рддреНрд░реБрдЯрд┐ рд╣реБрдИ: {error_msg}ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
        "file_error": "ри╡рйМриЗри╕ риирйЛриЯ рилри╛риИри▓ ри╡ри┐рй▒риЪ ри╕риорй▒ри╕ри┐риЖ ри╕рйА: {error_msg}ред риХри┐ри░рикри╛ риХри░риХрйЗ риЗри╕риирйВрй░ рилри┐ри░ ридрйЛриВ ринрйЗриЬрйЛред",
        "unexpected_error": "ридрйБри╣ри╛рибрйЗ ри╡рйМриЗри╕ риирйЛриЯ риирйВрй░ рикрйНри░рйЛри╕рйИри╕ риХри░рижрйЗ ри╕риорйЗриВ риЗрй▒риХ риЕригриХри┐риЖри╕рйА риЧри▓ридрйА ри╣рйЛриИред риХри┐ри░рикри╛ риХри░риХрйЗ рижрйБримри╛ри░ри╛ риХрйЛри╕ри╝ри┐ри╕ри╝ риХри░рйЛред",
        "no_voice_note": "риХри┐ри░рикри╛ риХри░риХрйЗ риЯрйНри░ри╛риВриЬрйИриХри╕ри╝рии рикрйНри░рйЛри╕рйИри╕ри┐рй░риЧ ри▓риИ риЗрй▒риХ ри╡рйМриЗри╕ риирйЛриЯ ринрйЗриЬрйЛ риЬри╛риВ римриХри╛риЗриЖ рикрйБрй▒риЫриг ри▓риИ риЗрй▒риХ риЯрйИриХри╕риЯ ри╕рйБриирйЗри╣ри╛ ринрйЗриЬрйЛред",
        "unsupported_media": "риЕри╕риори░риери┐рид риорйАрибрйАриЖ риХри┐ри╕рио: {media_type}ред риХри┐ри░рикри╛ риХри░риХрйЗ риЗрй▒риХ ри╡рйМриЗри╕ риирйЛриЯ риЬри╛риВ риЗрй▒риХ риЪри┐рй▒ридри░ ринрйЗриЬрйЛред",
        "no_transactions_found": "риХрйЛриИ ри╣ри╛ри▓рйАриЖ ри▓рйИриг-рижрйЗриг риири╣рйАриВ риори┐ри▓ри┐риЖред",
        "image_received_stock_update": "ридри╕ри╡рйАри░ рикрйНри░ри╛рикрид ри╣рйЛриИ! ри╕риЯри╛риХ риЕрй▒рикрибрйЗриЯ ри▓риИ рикрйНри░риХри┐ри░ри┐риЖ риХрйАридрйА риЬри╛ ри░ри╣рйА ри╣рйИ...",
        "stock_update_success": "тЬЕ ри╕риЯри╛риХ ри╕рилри▓ридри╛рйНрикрйВри░рйНри╡риХ риЕрй▒рикрибрйЗриЯ риХрйАридри╛ риЧри┐риЖ: {updates}.",
        "stock_update_fail": "тЭМ ридри╕ри╡рйАри░ ридрйЛриВ ри╕риЯри╛риХ риЕрй▒рикрибрйЗриЯ риХри░рии ри╡ри┐рй▒риЪ риЕри╕рилри▓ред риЧри▓ридрйА: {error_msg}",
        "file_download_error": "ридрйБри╣ри╛рибрйА ридри╕ри╡рйАри░ рибри╛риКриири▓рйЛриб риири╣рйАриВ рд╣рйЛ ри╕риХрйА: {error_msg}ред риХри┐ри░рикри╛ риХри░риХрйЗ рижрйБримри╛ри░ри╛ риХрйЛри╕ри╝ри┐ри╕ри╝ риХри░рйЛред",
        "welcome": "ри╕рид ри╕рйНри░рйА риЕриХри╛ри▓! риорйИриВ ридрйБри╣ри╛рибри╛ риЗриири╡рйИриВриЯри░рйА рикрйНри░римрй░ризрии римрйЛриЯ ри╣ри╛риВред риорйИриВ ридрйБри╣ри╛рибрйА риХри┐р╡╜ риорижриж риХри░ ри╕риХрижри╛ ри╣ри╛риВ?",
        "stock_updated": "{item_name} рижри╛ ри╕риЯри╛риХ ри╕рилри▓ридри╛рикрйВри░ри╡риХ риЕрй▒рикрибрйЗриЯ риХрйАридри╛ риЧри┐риЖред риорйМриЬрйВрижри╛ риори╛ридри░ри╛: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} рижрйА ри╡ри┐риХри░рйА рижри░риЬ риХрйАридрйА риЧриИред римри╛риХрйА ри╕риЯри╛риХ: {current_quantity} {unit}. риХрйБрй▒ри▓ ри╡ри┐риХри░рйА ри░ри╛ри╕ри╝рйА: {selling_amount}. ри▓ри╛рин: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} рижрйА риЦри░рйАриж рижри░риЬ риХрйАридрйА риЧриИред риири╡рлЛ ри╕риЯри╛риХ: {current_quantity} {unit}. ри▓ри╛риЧрид: {cost_price_per_unit} рикрйНри░ридрйА {unit}.",
        "item_not_found": "'{item_name}' ри╕риЯри╛риХ ри╡ри┐рй▒риЪ рдирд╣реАрдВ рдорд┐рд▓рйА. рдХреНрдпрд╛ рдЖрдк рдЗрд╕реЗ рдЬреЛрдбрд╝рдирд╛ рдЪрд╛рд╣реЗрдВрдЧреЗ?",
        "unknown_command": "риорйИриирйВрй░ ри╕риориЭ риири╣рйАриВ риЖриЗриЖред риХри┐ри░рикри╛ риХри░риХрйЗ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВ рдпрд╛ 'рд╕рд╣рд╛рдпрддрд╛' рдЯрд╛рдЗрдк рдХрд░реЗрдВред",
        "current_stock": "{item_name} рижри╛ риорйМриЬрйВрижри╛ ри╕риЯри╛риХ: {current_quantity} {unit}.",
        "all_stock_items": "ридрйБри╣ри╛рибри╛ риорйМриЬрйВрижри╛ ри╕риЯри╛риХ:\n{stock_list}",
        "daily_summary": "{date} ри▓риИ ри░рйЛриЬри╝ри╛риири╛ ри╡ри┐риХри░рйА ри╕рй░риЦрйЗрик:\nриХрйБрй▒ри▓ ри╡ри┐риХри░рйА: {total_sales}\nриХрйБрй▒ри▓ ри▓ри╛рин: {total_profit}\n{sales_details}",
        "low_stock_alert": "тЪая╕П риШрй▒риЯ ри╕риЯри╛риХ риЪрйЗридри╛ри╡риирйА! ри╣рйЗриари╛риВ рижри┐рй▒ридрйАриЖриВ риЪрйАриЬри╝ри╛риВ риШрй▒риЯ ри╣рйЛ ри░ри╣рйАриЖриВ ри╣рии:\n{low_stock_items_list}\nриЬри▓рижрйА ри╣рйА риЖри░рибри░ риХри░рии римри╛ри░рйЗ ри╡ри┐риЪри╛ри░ риХри░рйЛред",
        "call_initiated": "{item_name} рижрйЗ {quantity} {unit} ри▓риИ {supplier_name} ({supplier_phone_number}) риирйВрй░ риХри╛ри▓ риХрйАридри╛ риЬри╛ ри░ри┐ри╣ри╛ ри╣рйИред риЖри░рибри░ рижрйА рикрйБри╕ри╝риЯрйА ри╣рйЛриг 'ридрйЗ риорйИриВ ридрйБри╣ри╛риирйВрй░ рд╕реВрдЪрд┐рдд рдХрд░реВрдВрдЧрд╛ред",
        "order_confirmation_prompt": "рдЖрдк рдХрд┐рд╕ рдЖрдЗрдЯрдо рдФрд░ рдЖрдкреВрд░реНрддрд┐рдХрд░реНрддрд╛ рдХреЗ рд▓рд┐рдП рдСрд░реНрдбрд░ рдХреА рдкреБрд╖реНрдЯрд┐ рдХрд░рдирд╛ рдЪрд╛рд╣реЗрдВрдЧреЗ? рдЙрджрд╛рд╣рд░рдг: 'рд╕рдкреНрд▓рд╛рдпрд░ рдП рд╕реЗ 10 рдХрд┐рд▓реЛ рдЪрд╛рд╡рд▓ рдСрд░реНрдбрд░ рдХрд░реЗрдВ'ред",
        "order_confirmed_shopkeeper": "тЬЕ {item_name} рдХреЗ {quantity} {unit} рдХрд╛ {supplier_name} рд╕реЗ рдСрд░реНрдбрд░ рдкреБрд╖реНрдЯ рд╣реЛ рдЧрдпрд╛ рд╣реИред рд╕реНрдЯреЙрдХ рдЕрдкрдбреЗрдЯ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред рдбрд┐рд▓реАрд╡рд░реА 2 рджрд┐рдиреЛрдВ рдореЗрдВ рдЕрдкреЗрдХреНрд╖рд┐рдд рд╣реИред",
        "order_failed_shopkeeper": "тЭМ Failed to confirm order for {item_name} from {supplier_name}. Reason: {reason}"
    },
    "gu": { # Gujarati messages
        "sale_success": "тЬЕ ркдркорк╛рк░рк╛ ркбрк┐ркЬрк┐ркЯрк▓ ркЦрк╛ркдрк╛ркорк╛ркВ тВ╣{amount:.2f} ({item}) ркирлА рк╡рлЗркЪрк╛ркг ркирлЛркВркзрк╛ркИ ркЫрлЗ.",
        "sale_success_no_item": "тЬЕ ркдркорк╛рк░рк╛ ркбрк┐ркЬрк┐ркЯрк▓ ркЦрк╛ркдрк╛ркорк╛ркВ тВ╣{amount:.2f} ркирлА рк╡рлЗркЪрк╛ркг ркирлЛркВркзрк╛ркИ ркЫрлЗ.",
        "expense_success": "тЬЕ ркдркорк╛рк░рк╛ ркбрк┐ркЬрк┐ркЯрк▓ ркЦрк╛ркдрк╛ркорк╛ркВ тВ╣{amount} ({item}) ркирлЛ ркЦрк░рлНркЪ ркирлЛркВркзрк╛ркпрлЛ ркЫрлЗ.",
        "expense_success_no_item": "тЬЕ ркдркорк╛рк░рк╛ ркбрк┐ркЬрк┐ркЯрк▓ ркЦрк╛ркдрк╛ркорк╛ркВ тВ╣{amount} ркирлЛ ркЦрк░рлНркЪ ркирлЛркВркзрк╛ркпрлЛ ркЫрлЗ.",
        "balance_inquiry": "ЁЯУК ркдркорк╛рк░рк╛ ркбрк┐ркЬрк┐ркЯрк▓ ркЦрк╛ркдрк╛ркорк╛ркВ рк╡рк░рлНркдркорк╛рки ркмрлЗрк▓рлЗркирлНрк╕ тВ╣{balance:.2f} ркЫрлЗред\n\nркЫрлЗрк▓рлНрк▓рк╛ рк╡рлНркпрк╡рк╣рк╛рк░рлЛ:\n{transactions_summary}",
        "extract_fail": "ркдркорк╛рк░рк╛ рк╡рлЙркЗрк╕ ркирлЛркЯркорк╛ркВркерлА ркорк╛рк╣рк┐ркдрлА ркХрк╛ркврлА рк╢ркХрк╛ркИ ркиркерлА. ркХрлГрккрк╛ ркХрк░рлАркирлЗ рк╕рлНрккрк╖рлНркЯ ркмрлЛрк▓рлЛ.",
        "transcribe_fail": "ркдркорк╛рк░рлЛ рк╡рлЙркЗрк╕ ркирлЛркЯ ркЯрлНрк░рк╛ркирлНрк╕ркХрлНрк░рк╛ркЗркм ркЕркерк╡рк╛ ркЕркирлБрк╡рк╛ркж ркХрк░рлА рк╢ркХрк╛ркпрлБркВ ркиркерлА. ркСркбрк┐ркпрлЛ ркЧрлБркгрк╡ркдрлНркдрк╛ ркиркмрк│рлА рк╣рлЛркИ рк╢ркХрлЗ ркЫрлЗ.",
        "download_fail": "ркдркорк╛рк░рлЛ рк╡рлЙркЗрк╕ ркирлЛркЯ ркбрк╛ркЙркирк▓рлЛркб ркеркИ рк╢ркХрлНркпрлЛ ркиркерлА: {error_msg}. ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклрк░рлА рккрлНрк░ркпрк╛рк╕ ркХрк░рлЛ.",
        "network_error": "ркдркорк╛рк░рлЛ рк╡рлЙркЗрк╕ ркирлЛркЯ ркбрк╛ркЙркирк▓рлЛркб ркХрк░ркдрлА рк╡ркЦркдрлЗ ркирлЗркЯрк╡рк░рлНркХ ркнрлВрк▓ ркеркИ: {error_msg}. ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклрк░рлА рккрлНрк░ркпрк╛рк╕ ркХрк░рлЛ.",
        "file_error": "рк╡рлЙркЗрк╕ ркирлЙркЯ рклрк╛ркЗрк▓ркорк╛ркВ рк╕ркори╕рлНркп рк╣ркдрлА: {error_msg}ред ркХрлГрккрк╛ ркХрк░рлАркирлЗ ркдрлЗркирлЗ рклрк░рлАркерлА ркорлЛркХрк▓рлЛ.",
        "unexpected_error": "ркдркорк╛рк░рк╛ рк╡рлЙркЗрк╕ ркирлЛркЯ рккрк░ рккрлНрк░ркХрлНрк░рк┐ркпрк╛ ркХрк░ркдрлА рк╡ркЦркдрлЗ ркЕркгрлНркзрк╛рк░рлА ркнрлВрк▓ ркеркИ. ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклрк░рлА рккрлНрк░ркпрк╛рк╕ ркХрк░рлЛ.",
        "no_voice_note": "ркХрлГрккрк╛ ркХрк░рлАркирлЗ рк╡рлНркпрк╡рк╣рк╛рк░ рккрлНрк░ркХрлНрк░рк┐ркпрк╛ ркорк╛ркЯрлЗ рк╡рлЙркЗрк╕ ркирлЛркЯ ркорлЛркХрк▓рлЛ ркЕркерк╡рк╛ ркмрлЗрк▓рлЗркирлНрк╕ рккрлВркЫрк╡рк╛ ркорк╛ркЯрлЗ ркЯрлЗркХрлНрк╕рлНркЯ рк╕ркВркжрлЗрк╢ ркорлЛркХрк▓рлЛ.",
        "unsupported_media": "ркЕрк╕ркорк░рлНркерк┐ркд ркорлАркбрк┐ркпрк╛ рккрлНрк░ркХрк╛рк░: {media_type}ред ркХрлГрккрк╛ ркХрк░рлАркирлЗ ркПркХ рк╡рлЙркЗрк╕ ркирлЛркЯ ркЕркерк╡рк╛ ркПркХ ркЫркмрлА ркорлЛркХрк▓рлЛред",
        "no_transactions_found": "ркХрлЛркИ ркдрк╛ркЬрлЗркдрк░ркирк╛ рк╡рлНркпрк╡рк╣рк╛рк░рлЛ ркорк│рлНркпрк╛ ркиркерлАред",
        "image_received_stock_update": "ркЫркмрлА рккрлНрк░рк╛рккрлНркд ркеркИ! рк╕рлНркЯрлЛркХ ркЕрккркбрлЗркЯ ркорк╛ркЯрлЗ рккрлНрк░ркХрлНрк░рк┐ркпрк╛ ркеркИ рк░рк╣рлА ркЫрлЗ...",
        "stock_update_success": "тЬЕ рк╕рлНркЯрлЛркХ рк╕рклрк│ркдрк╛рлНрикрйВрлВрк░рлНрк╡ркХ ркЕрккркбрлЗркЯ ркеркпрлЛ: {updates}.",
        "stock_update_fail": "тЭМ ркЫркмрлАркорк╛ркВркерлА рк╕рлНркЯрлЛркХ ркЕрккркбрлЗркЯ ркХрк░рк╡рк╛ркорк╛ркВ ркирк┐рк╖рлНрклрк│. ркнрлВрк▓: {error_msg}",
        "file_download_error": "ркдркорк╛рк░рлА ркЫркмрлА ркбрк╛ркЙркирк▓рлЛркб ркеркИ рк╢ркХрлА ркиркерлА: {error_msg}. ркХрлГрккрк╛ ркХрк░рлАркирлЗ рклрк░рлА рккрлНрк░ркпрк╛рк╕ ркХрк░рлЛ.",
        "welcome": "ркиркорк╕рлНркдрлЗ! рк╣рлБркВ ркдркорк╛рк░рлА ркЗркирлНрк╡рлЗркирлНркЯрлНрк░рлА ркорлЗркирлЗркЬркорлЗркирлНркЯ ркмрлЛркЯ ркЫрлБркВ. рк╣рлБркВ ркдркоркирлЗ ркХрлЗрк╡рлА рк░рлАркдрлЗ ркоркжркж ркХрк░рлА рк╢ркХрлБркВ?",
        "stock_updated": "{item_name} ркирлЛ рк╕рлНркЯрлЛркХ рк╕рлНрклрк│ркдрк╛рккрлВрк░рлНрк╡ркХ ркЕрккркбрлЗркЯ ркеркпрлЛ. рк╡рк░рлНркдркорк╛рки ркЬркерлНркерлЛ: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} ркирлБркВ рк╡рлЗркЪрк╛ркг ркирлЛркВркзрк╛ркИ. ркмрк╛ркХрлА рк╕рлНркЯрлЛркХ: {current_quantity} {unit}. ркХрлБрк▓ рк╡рлЗркЪрк╛ркг рк░ркХрко: {selling_amount}. ркирклрлЛ: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} ркирлА ркЦри░рлАркжрлА ркирлЛркВркзрк╛ркИ. ркирк╡рлЛ рк╕рлНркЯрлЛркХ: {current_quantity} {unit}. ркЦрк░рлНркЪ: {cost_price_per_unit} рикрйНри░ридрйА {unit}.",
        "item_not_found": "'{item_name}' рк╕рлНркЯрлЛркХ рк╡ри┐рй▒риЪ рдирд╣реАрдВ рдорд┐рд▓рйА. рдХреНрдпрд╛ рдЖрдк рдЗрд╕реЗ рдЬреЛрдбрд╝рдирд╛ рдЪрд╛рд╣реЗрдВрдЧреЗ?",
        "unknown_command": "риорйИриирйВрй░ рк╕риоркЭ ркири╣рйАркВ риЖркпрк╛. риХри┐ри░рикри╛ риХри░риХрйЗ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВ рдпрд╛ 'рд╕рд╣рд╛рдпрддрд╛' рдЯрд╛рдЗрдк рдХрд░реЗрдВред",
        "current_stock": "{item_name} ркжри╛ риорйМриЬрйВрижри╛ ри╕риЯри╛риХ: {current_quantity} {unit}.",
        "all_stock_items": "ридрйБри╣ри╛рибри╛ риорйМриЬрйВрижри╛ ри╕риЯри╛риХ:\n{stock_list}",
        "daily_summary": "{date} ри▓риИ ри░рйЛриЬри╝ри╛риири╛ ри╡ри┐риХри░рйА ри╕рй░риЦрйЗрик:\nриХрйБрй▒ри▓ ри╡ри┐риХри░рйА: {total_sales}\nриХрйБрй▒ри▓ ри▓ри╛рин: {total_profit}\n{sales_details}",
        "low_stock_alert": "тЪая╕П риШрй▒риЯ ри╕риЯри╛риХ риЪрйЗридри╛ри╡риирйА! ри╣рйЗриари╛риВ рижри┐рй▒ридрйАриЖриВ риЪрйАриЬри╝ри╛риВ риШрй▒риЯ ри╣рйЛ ри░ри╣рйАриЖриВ ри╣рии:\n{low_stock_items_list}\nриЬри▓рижрйА ри╣рйА риЖри░рибри░ риХри░рии римри╛ри░рйЗ ри╡ри┐риЪри╛ри░ риХри░рйЛред",
        "call_initiated": "{item_name} ркжрйЗ {quantity} {unit} рк▓риИ {supplier_name} ({supplier_phone_number}) ркирйВркВ ркХри╛рк▓ ркХрйАркдрк╛ ркЬрк╛ рк░ри┐рк╣рк╛ рк╣рйИред ркЖрк░рибрк░ ркжрйА рикрйБрк╕ри╝ркЯрйА рк╣рйЛркг 'ркдрйЗ ркорйИркВ ркдрйБри╣ри╛ркирйВркВ рд╕реВрдЪрд┐рдд ркХрк░рлВркВркЧрлЛред",
        "order_confirmation_prompt": "ркдркорлЗ ркХркИ рк╡рк╕рлНркдрлБ ркЕркирлЗ рк╕рккрлНрк▓рк╛ркпрк░ ркорк╛ркЯрлЗ ркУрк░рлНркбрк░ ркХркирлНрклрк░рлНрко ркХрк░рк╡рк╛ ркорк╛ркВркЧрлЛ ркЫрлЛ? ркЙркжрк╛рк╣рк░ркг: 'рк╕рккрлНрк▓рк╛ркпрк░ A рккрк╛рк╕рлЗркерлА 10 ркХрк┐рк▓рлЛ ркЪрлЛркЦрк╛ркирлЛ ркУрк░рлНркбрк░ ркХрк░рлЛ'.",
        "order_confirmed_shopkeeper": "тЬЕ {item_name} ркирк╛ {quantity} {unit} ркорк╛ркЯрлЗ {supplier_name} рккрк╛рк╕рлЗркерлА ркУрк░рлНркбрк░ ркХркирлНрклрк░рлНрко ркеркпрлЛ ркЫрлЗ. рк╕рлНркЯрлЛркХ ркЕрккркбрлЗркЯ ркХрк░рк╡рк╛ркорк╛ркВ ркЖрк╡рлНркпрлЛ ркЫрлЗ. 2 ркжрк┐рк╡рк╕ркорк╛ркВ ркбрк┐рк▓рк┐рк╡рк░рлА ркЕрккрлЗркХрлНрк╖рк┐ркд ркЫрлЗ.",
        "order_failed_shopkeeper": "тЭМ {item_name} ркирк╛ {supplier_name} рккрк╛рк╕рлЗркерлА ркУрк░рлНркбрк░ ркХркирлНрклрк░рлНрко ркХрк░рк╡рк╛ркорк╛ркВ ркирк┐рк╖рлНрклрк│. ркХрк╛рк░ркг: {reason}"
    },
    "te": { # Telugu messages
        "sale_success": "тЬЕ р░ор▒А р░бр░┐р░Ьр░┐р░Яр░▓р▒Н р░Цр░╛р░др░╛р░▓р▒Л тВ╣{amount:.2f} ({item}) р░Ер░ор▒Нр░ор░Хр░В р░Ьр▒Лр░бр░┐р░Вр░Ър░мр░бр░┐р░Вр░жр░┐.",
        "sale_success_no_item": "тЬЕ р░ор▒А р░бр░┐р░Ьр░┐р░Яр░▓р▒Н р░Цр░╛р░др░╛р░▓р▒Л тВ╣{amount:.2f} р░Ер░ор▒Нр░ор░Хр░В р░Ьр▒Лр░бр░┐р░Вр░Ър░мр░бр░┐р░Вр░жр░┐.",
        "expense_success": "тЬЕ р░ор▒А р░бр░┐р░Ьр░┐р░Яр░▓р▒Н р░Цр░╛р░др░╛р░▓р▒Л тВ╣{amount} ({item}) р░Цр░░р▒Нр░Ър▒Б р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░мр░бр░┐р░Вр░жр░┐.",
        "expense_success_no_item": "тЬЕ р░ор▒А р░бр░┐р░Ьр░┐р░Яр░▓р▒Н р░Цр░╛р░др░╛р░▓р▒Л тВ╣{amount} р░Цр░░р▒Нр░Ър▒Б р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░мр░бр░┐р░Вр░жр░┐.",
        "balance_inquiry": "ЁЯУК р░ор▒А р░бр░┐р░Ьр░┐р░Яр░▓р▒Н р░Цр░╛р░др░╛р░▓р▒Л р░кр▒Нр░░р░╕р▒Нр░др▒Бр░д р░мр▒Нр░пр░╛р░▓р▒Жр░ир▒Нр░╕р▒Н тВ╣{balance:.2f} р░Йр░Вр░жр░┐.\n\nр░др░╛р░Ьр░╛ р░▓р░╛р░╡р░╛р░жр▒Зр░╡р▒Ар░▓р▒Б:\n{transactions_summary}",
        "extract_fail": "р░ор▒А р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒Н р░ир▒Бр░Вр░бр░┐ р░бр▒Зр░Яр░╛р░ир▒Б р░╕р▒Зр░Хр░░р░┐р░Вр░Ър░▓р▒Зр░ор▒Б. р░жр░пр░Ър▒Зр░╕р░┐ р░╕р▒Нр░кр░╖р▒Нр░Яр░Вр░Чр░╛ р░ор░╛р░Яр▒Нр░▓р░╛р░бр░Вр░бр░┐.",
        "transcribe_fail": "р░ор▒А р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒НтАМр░ир▒Б р░▓р░┐р░кр▒Нр░пр░Вр░др░░р▒Ар░Хр░░р░┐р░Вр░Ър░бр░В р░▓р▒Зр░жр░╛ р░Ер░ир░ир▒Бр░╡р░жр░┐р░Вр░Ър░бр░В р░╕р░╛р░зр░пр░В р░Хр░╛р░▓р▒Зр░жр▒Б. р░Жр░бр░┐р░пр▒Л р░ир░╛р░гр▒Нр░пр░д р░др░Хр▒Нр░Хр▒Бр░╡р░Чр░╛ р░Йр░Вр░бр░╡р░Ър▒Нр░Ър▒Б.",
        "download_fail": "р░ор▒А р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒НтАМр░ир▒Б р░бр▒Мр░ир▒НтАМр░▓р▒Лр░бр▒Н р░Ър▒Зр░пр░бр░Вр░▓р▒Л р░╡р░┐р░лр░▓р░ор▒Ир░Вр░жр░┐: {error_msg}. р░жр░пр░Ър▒Зр░╕р░┐ р░ор░│р▒Нр░▓р▒А р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐.",
        "network_error": "р░ор▒А р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒НтАМр░ир▒Б р░бр▒Мр░ир▒НтАМр░▓р▒Лр░бр▒Н р░Ър▒Зр░╕р▒Нр░др▒Бр░ир▒Нр░ир░кр▒Нр░кр▒Бр░бр▒Б р░ир▒Жр░Яр▒НтАМр░╡р░░р▒Нр░Хр▒Н р░▓р▒Лр░кр░В р░╕р░Вр░нр░╡р░┐р░Вр░Ър░┐р░Вр░жр░┐: {error_msg}. р░жр░пр░Ър▒Зр░╕р░┐ р░ор░│р▒Нр░▓р▒А р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐.",
        "file_error": "р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒Н р░лр▒Ир░▓р▒НтАМр░▓р▒Л р░╕р░ор░╕р▒Нр░п р░Йр░Вр░жр░┐: {error_msg}. р░жр░пр░Ър▒Зр░╕р░┐ р░жр░╛р░ир▒Нр░ир░┐ р░ор░│р▒Нр░▓р▒А р░кр░Вр░кр░Вр░бр░┐.",
        "unexpected_error": "р░ор▒А р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒НтАМр░ир▒Б р░кр▒Нр░░р░╛р░╕р▒Жр░╕р▒Н р░Ър▒Зр░╕р▒Нр░др▒Бр░ир▒Нр░ир░кр▒Нр░кр▒Бр░бр▒Б р░Кр░╣р░┐р░Вр░Ър░ир░┐ р░▓р▒Лр░кр░В р░╕р░Вр░нр░╡р░┐р░Вр░Ър░┐р░Вр░жр░┐. р░жр░пр░Ър▒Зр░╕р░┐ р░ор░│р▒Нр░▓р▒А р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐.",
        "no_voice_note": "р░жр░пр░Ър▒Зр░╕р░┐ р░▓р░╛р░╡р░╛р░жр▒Зр░╡р▒Ар░▓ р░кр▒Нр░░р░╛р░╕р▒Жр░╕р░┐р░Вр░Чр▒Н р░Хр▒Лр░╕р░В р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒Н р░кр░Вр░кр░Вр░бр░┐ р░▓р▒Зр░жр░╛ р░мр▒Нр░пр░╛р░▓р▒Жр░ир▒Нр░╕р▒Н р░╡р░┐р░Ър░╛р░░р░г р░Хр▒Лр░╕р░В р░Яр▒Жр░Хр▒Нр░╕р▒Нр░Яр▒Н р░╕р░Вр░жрлЗр░╢р░В р░кр░Вр░кр░Вр░бр░┐.",
        "unsupported_media": "р░ор░жр▒Нр░жр░др▒Б р░▓р▒Зр░ир░┐ р░ор▒Ар░бр░┐р░пр░╛ р░░р░Хр░В: {media_type}ред р░жр░пр░Ър▒Зр░╕р░┐ р░╡р░╛р░пр░┐р░╕р▒Н р░ир▒Лр░Яр▒Н р░▓р▒Зр░жр░╛ р░Ър░┐р░др▒Нр░░р░╛р░ир▒Нр░ир░┐ р░кр░Вр░кр░Вр░бр░┐.",
        "no_transactions_found": "р░др░╛р░Ьр░╛ р░▓р░╛р░╡р░╛р░жр▒Зр░╡р▒Ар░▓р▒Б р░Пр░╡р▒А р░Хр░ир▒Бр░Чр▒Кр░ир░мр░бр░▓р▒Зр░жр▒Б.",
        "image_received_stock_update": "р░Ър░┐р░др▒Нр░░р░В р░╕р▒Нр░╡р▒Ар░Хр░░р░┐р░Вр░Ър░мр░бр░┐р░Вр░жр░┐! р░╕р▒Нр░Яр░╛р░Хр▒Н р░Ер░кр▒НтАМр░бр▒Зр░Яр▒Н р░Хр▒Лр░╕р░В р░кр▒Нр░░р░╛р░╕р▒Жр░╕р▒Н р░Ър▒Зр░пр░мр░бр▒Бр░др▒Лр░Вр░жр░┐...",
        "stock_update_success": "тЬЕ р░╕р▒Нр░Яр░╛р░Хр▒Н р░╡р░┐р░Ьр░пр░╡р░Вр░др░Вр░Чр░╛ р░ир░╡р▒Ар░Хр░░р░┐р░Вр░Ър░мр░бр░┐р░Вр░жр░┐: {updates}.",
        "stock_update_fail": "тЭМ р░Ър░┐р░др▒Нр░░р░В р░ир▒Бр░Вр░бр░┐ р░╕р▒Нр░Яр░╛р░Хр▒НтАМр░ир▒Б р░ир░╡р▒Ар░Хр░░р░┐р░Вр░Ър░бр░Вр░▓р▒Л р░╡р░┐р░лр░▓р░ор▒Ир░Вр░жр░┐. р░▓р▒Лр░кр░В: {error_msg}",
        "file_download_error": "р░ор▒А р░Ър░┐р░др▒Нр░░р░В р░бр▒Мр░ир▒НтАМр░▓р▒Лр░бр▒Н р░Ър▒Зр░пр░бр░Вр░▓р▒Л р░╡р░┐р░лр░▓р░ор▒Ир░Вр░жр░┐: {error_msg}. р░жр░пр░Ър▒Зр░╕р░┐ р░ор░│р▒Нр░▓р▒А р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐.",
        "welcome": "р░ир░ор░╕р▒Нр░Хр░╛р░░р░В! р░ир▒Зр░ир▒Б р░ор▒А р░Зр░ир▒Нр░╡р▒Жр░Вр░Яр░░р▒А р░ир░┐р░░р▒Нр░╡р░╣р░г р░мр░╛р░Яр▒Н р░ир░┐. р░ир▒Зр░ир▒Б р░ор▒Ар░Хр▒Б р░Ор░▓р░╛ р░╕р░╣р░╛р░пр░В р░Ър▒Зр░пр░Чр░▓р░ир▒Б?",
        "stock_updated": "{item_name} р░ир░┐р░▓р▒Нр░╡ р░╡р░┐р░Ьр░пр░╡р░Вр░др░Вр░Чр░╛ р░ир░╡р▒Ар░Хр░░р░┐р░Вр░Ър░мр░бр░┐р░Вр░жр░┐. р░кр▒Нр░░р░╕р▒Нр░др▒Бр░д р░кр░░р░┐р░ор░╛р░гр░В: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} р░Ер░ор▒Нр░ор░Хр░В р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░мр░бр░┐р░Вр░жр░┐. р░ор░┐р░Чр░┐р░▓р░┐р░и р░ир░┐р░▓р▒Нр░╡: {current_quantity} {unit}. р░ор▒Кр░др▒Нр░др░В р░Ер░ор▒Нр░ор░Хр░кр▒Б р░ор▒Кр░др▒Нр░др░В: {selling_amount}. р░▓р░╛р░нр░В: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} р░Хр▒Кр░ир▒Бр░Чр▒Лр░▓р▒Б р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░мр░бр░┐р░Вр░жр░┐. р░Хр▒Кр░др▒Нр░д р░ир░┐р░▓р▒Нр░╡: {current_quantity} {unit}. р░зр░░: {cost_price_per_unit} р░кр▒Нр░░р░др░┐ {unit}.",
        "item_not_found": "'{item_name}' р░ир░┐р░▓р▒Нр░╡р░▓р▒Л р░Хр░ир▒Бр░Чр▒Кр░ир░мр░бр░▓р▒Зр░жр▒Б. р░ор▒Ар░░р▒Б р░жр▒Ар░ир▒Нр░ир░┐ р░Ьр▒Лр░бр░┐р░Вр░Ър░╛р░▓р░ир▒Бр░Хр▒Бр░Вр░Яр▒Бр░ир▒Нр░ир░╛р░░р░╛?",
        "unknown_command": "р░ир░╛р░Хр▒Б р░Ер░░р▒Нр░ер░В р░Хр░╛р░▓р▒Зр░жр▒Б. р░жр░пр░Ър▒Зр░╕р░┐ р░ор░│р▒Нр░│р▒А р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐ р░▓р▒Зр░жр░╛ 'р░╕р░╣р░╛р░пр░В' р░Ер░ир░┐ р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐.",
        "current_stock": "{item_name} р░кр▒Нр░░р░╕р▒Нр░др▒Бр░д р░ир░┐р░▓р▒Нр░╡: {current_quantity} {unit}.",
        "all_stock_items": "р░ор▒А р░кр▒Нр░░р░╕р▒Нр░др▒Бр░д р░ир░┐р░▓р▒Нр░╡:\n{stock_list}",
        "daily_summary": "{date} р░Хр▒Лр░╕р░В р░░р▒Лр░Ьр▒Бр░╡р░╛р░░р▒А р░Ер░ор▒Нр░ор░Хр░╛р░▓ р░╕р░╛р░░р░╛р░Вр░╢р░В:\nр░ор▒Кр░др▒Нр░др░В р░Ер░ор▒Нр░ор░Хр░╛р░▓р▒Б: {total_sales}\nр░ор▒Кр░др▒Нр░др░В р░▓р░╛р░нр░В: {total_profit}\n{sales_details}",
        "low_stock_alert": "тЪая╕П р░др░Хр▒Нр░Хр▒Бр░╡ р░ир░┐р░▓р▒Нр░╡ р░╣р▒Жр░Ър▒Нр░Ър░░р░┐р░Х! р░Хр▒Нр░░р░┐р░Вр░жр░┐ р░Ер░Вр░╢р░╛р░▓р▒Б р░др░Хр▒Нр░Хр▒Бр░╡р░Чр░╛ р░Йр░ир▒Нр░ир░╛р░пр░┐:\n{low_stock_items_list}\nр░др▒Нр░╡р░░р░▓р▒Л р░Жр░░р▒Нр░бр░░р▒Н р░Ър▒Зр░пр░╛р░▓р░ир░┐ р░кр░░р░┐р░Чр░гр░┐р░Вр░Ър░Вр░бр░┐.",
        "call_initiated": "{item_name} р░пр▒Кр░Хр▒Нр░Х {quantity} {unit} р░Хр▒Лр░╕р░В {supplier_name} ({supplier_phone_number}) р░Хр▒Б р░Хр░╛р░▓р▒Н р░кр▒Нр░░р░╛р░░р░Вр░нр░┐р░Вр░Ър░мр░бр▒Бр░др▒Лр░Вр░жр░┐. р░Жр░░р▒Нр░бр░░р▒Н р░ир░┐р░░р▒Нр░зр░╛р░░р░┐р░Вр░Ър░мр░бр░┐р░и р░др░░р▒Нр░╡р░╛р░д р░ир▒Зр░ир▒Б р░ор▒Ар░Хр▒Б р░др▒Жр░▓р░┐р░пр░Ьр▒Зр░╕р▒Нр░др░╛р░ир▒Б.",
        "order_confirmation_prompt": "р░ор▒Ар░░р▒Б р░П р░╡р░╕р▒Нр░дрйБр░╡р▒Б р░ор░░р░┐р░пр▒Б р░╕р░░р░лр░░р░╛р░жр░╛р░░р▒Б р░Хр▒Лр░╕р░В р░Жр░░р▒Нр░бр░░р▒НтАМр░ир▒Б р░ир░┐р░░р▒Нр░зр░╛р░░р░┐р░Вр░Ър░╛р░▓р░ир▒Бр░Хр▒Бр░Вр░Яр▒Бр░ир▒Нр░ир░╛р░░р▒Б? р░Йр░жр░╛р░╣р░░р░г: 'р░╕р░кр▒Нр░▓р░пр░░р▒Н A р░ир▒Бр░Вр░бр░┐ 10 р░Хр░┐р░▓рлЛр░▓ р░мр░┐р░пр▒Нр░пр░В р░Жр░░р▒Нр░бр░░р▒Н р░Ър▒Зр░пр░Вр░бр░┐'.",
        "order_confirmed_shopkeeper": "тЬЕ {item_name} р░пр▒Кр░Хр▒Нр░Х {quantity} {unit} р░Хр▒Кр░░р░Хр▒Б {supplier_name} р░ир▒Бр░Вр░бр░┐ р░Жр░░р▒Нр░бр░░р▒Н р░ир░┐р░░р▒Нр░зр░╛р░░р░┐р░Вр░Ър░мр░бр░┐р░Вр░жр░┐. р░╕р▒Нр░Яр░╛р░Хр▒Н р░Ер░кр▒НтАМр░бр▒Зр░Яр▒Н р░Ър▒Зр░пр░мр░бр░┐р░Вр░жр░┐. 2 р░░р▒Лр░Ьр▒Бр░▓р░▓р▒Л р░бр▒Жр░▓р░┐р░╡р░░р▒А р░Жр░╢р░┐р░Вр░Ър░мр░бр▒Бр░др▒Бр░Вр░жр░┐.",
        "order_failed_shopkeeper": "тЭМ {item_name} р░пр▒Кр░Хр▒Нр░Х {supplier_name} р░ир▒Бр░Вр░бр░┐ р░Жр░░р▒Нр░бр░░р▒НтАМр░ир▒Б р░ир░┐р░░р▒Нр░зр░╛р░░р░┐р░Вр░Ър░бр░Вр░▓р▒Л р░╡р░┐р░лр░▓р░ор▒Ир░Вр░жр░┐. р░Хр░╛р░░р░гр░В: {reason}"
    },
    "bn": { # Bengali messages
        "sale_success": "тЬЕ ржЖржкржирж╛рж░ ржбрж┐ржЬрж┐ржЯрж╛рж▓ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ тВ╣{amount:.2f} ({item}) ржмрж┐ржХрзНрж░ржпрж╝ ржпрзЛржЧ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред",
        "sale_success_no_item": "тЬЕ ржЖржкржирж╛рж░ ржбрж┐ржЬрж┐ржЯрж╛рж▓ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ тВ╣{amount:.2f} ржмрж┐ржХрзНрж░ржпрж╝ ржпрзЛржЧ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред",
        "expense_success": "тЬЕ ржЖржкржирж╛рж░ ржбрж┐ржЬрж┐ржЯрж╛рж▓ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ тВ╣{amount} ({item}) ржЦрж░ржЪ рж░рзЗржХрж░рзНржб ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред",
        "expense_success_no_item": "тЬЕ ржЖржкржирж╛рж░ ржбрж┐ржЬрж┐ржЯрж╛рж▓ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ тВ╣{amount} ржЦрж░ржЪ рж░рзЗржХрж░рзНржб ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред",
        "balance_inquiry": "ЁЯУК ржЖржкржирж╛рж░ ржбрж┐ржЬрж┐ржЯрж╛рж▓ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗрж░ ржмрж░рзНрждржорж╛ржи ржмрзНржпрж╛рж▓рзЗржирзНрж╕ тВ╣{balance:.2f}ред\n\nрж╕рж╛ржорзНржкрзНрж░рждрж┐ржХ рж▓рзЗржиржжрзЗржи:\n{transactions_summary}",
        "extract_fail": "ржЖржкржирж╛рж░ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржерзЗржХрзЗ ржбрзЗржЯрж╛ ржПржХрзНрж╕ржЯрзНрж░рзНржпрж╛ржХрзНржЯ ржХрж░рж╛ ржпрж╛ржпрж╝ржирж┐ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрж░рж┐рж╖рзНржХрж╛рж░ ржХрж░рзЗ ржмрж▓рзБржиред",
        "transcribe_fail": "ржЖржкржирж╛рж░ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржЯрзНрж░рж╛ржирзНрж╕ржХрзНрж░рж╛ржЗржм ржмрж╛ ржЕржирзБржмрж╛ржж ржХрж░рж╛ ржпрж╛ржпрж╝ржирж┐ред ржЕржбрж┐ржУ ржЧрзБржгржорж╛ржи ржЦрж╛рж░рж╛ржк рж╣рждрзЗ ржкрж╛рж░рзЗред",
        "download_fail": "ржЖржкржирж╛рж░ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржбрж╛ржЙржирж▓рзЛржб ржХрж░рж╛ ржпрж╛ржпрж╝ржирж┐: {error_msg}ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред",
        "network_error": "ржЖржкржирж╛рж░ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржбрж╛ржЙржирж▓рзЛржб ржХрж░рж╛рж░ рж╕ржоржпрж╝ ржПржХржЯрж┐ ржирзЗржЯржУржпрж╝рж╛рж░рзНржХ рждрзНрж░рзБржЯрж┐ рж╣ржпрж╝рзЗржЫрзЗ: {error_msg}ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред",
        "file_error": "ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржлрж╛ржЗрж▓ржЯрж┐рждрзЗ ржПржХржЯрж┐ рж╕ржорж╕рзНржпрж╛ ржЫрж┐рж▓: {error_msg}ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржПржЯрж┐ ржЖржмрж╛рж░ ржкрж╛ржарж╛ржиред",
        "unexpected_error": "ржЖржкржирж╛рж░ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ ржХрж░рж╛рж░ рж╕ржоржпрж╝ ржПржХржЯрж┐ ржЕржкрзНрж░рждрзНржпрж╛рж╢рж┐ржд рждрзНрж░рзБржЯрж┐ ржШржЯрзЗржЫрзЗред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред",
        "no_voice_note": "рж▓рзЗржиржжрзЗржи ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ржХрж░ржгрзЗрж░ ржЬржирзНржп ржПржХржЯрж┐ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржкрж╛ржарж╛ржи ржЕржержмрж╛ ржмрзНржпрж╛рж▓рзЗржирзНрж╕ ржЬрж╛ржирждрзЗ ржПржХржЯрж┐ ржкрж╛ржарзНржп ржмрж╛рж░рзНрждрж╛ ржкрж╛ржарж╛ржиред",
        "unsupported_media": "ржЕрж╕ржорж░рзНржерж┐ржд ржорж┐ржбрж┐ржпрж╝рж╛ ржкрзНрж░ржХрж╛рж░: {media_type}ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржПржХржЯрж┐ ржнржпрж╝рзЗрж╕ ржирзЛржЯ ржмрж╛ ржПржХржЯрж┐ ржЫржмрж┐ ржкрж╛ржарж╛ржиред",
        "no_transactions_found": "ржХрзЛржирзЛ рж╕рж╛ржорзНржкрзНрж░рждрж┐ржХ рж▓рзЗржиржжрзЗржи ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред",
        "image_received_stock_update": "ржЫржмрж┐ ржЧрзГрж╣рзАржд рж╣ржпрж╝рзЗржЫрзЗ! рж╕рзНржЯржХ ржЖржкржбрзЗржЯрзЗрж░ ржЬржирзНржп ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...",
        "stock_update_success": "тЬЕ рж╕рзНржЯржХ рж╕ржлрж▓ржнрж╛ржмрзЗ ржЖржкржбрзЗржЯ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ: {updates}.",
        "stock_update_fail": "тЭМ ржЫржмрж┐ ржерзЗржХрзЗ рж╕рзНржЯржХ ржЖржкржбрзЗржЯ ржХрж░рждрзЗ ржмрзНржпрж░рзНрже рж╣ржпрж╝рзЗржЫрзЗред рждрзНрж░рзБржЯрж┐: {error_msg}",
        "file_download_error": "ржЖржкржирж╛рж░ ржЫржмрж┐ ржбрж╛ржЙржирж▓рзЛржб ржХрж░рж╛ ржпрж╛ржпрж╝ржирж┐: {error_msg}ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред",
        "low_stock_alert": "тЪая╕П ржХржо рж╕рзНржЯржХ рж╕рждрж░рзНржХрждрж╛! ржирж┐ржорзНржирж▓рж┐ржЦрж┐ржд ржЖржЗржЯрзЗржоржЧрзБрж▓рж┐ ржХржо рж╣ржЪрзНржЫрзЗ:\n{low_stock_items_list}\nрж╢рзАржШрзНрж░ржЗ ржЕрж░рзНржбрж╛рж░ ржХрж░рж╛рж░ ржХржерж╛ ржнрж╛ржмрзБржиред",
        "welcome": "ржиржорж╕рзНржХрж╛рж░! ржЖржорж┐ ржЖржкржирж╛рж░ ржЗржиржнрзЗржирзНржЯрж░рж┐ ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ ржмржЯред ржЖржорж┐ ржЖржкржирж╛ржХрзЗ ржХрж┐ржнрж╛ржмрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рждрзЗ ржкрж╛рж░рж┐?",
        "stock_updated": "{item_name} ржПрж░ рж╕рзНржЯржХ рж╕ржлрж▓ржнрж╛ржмрзЗ ржЖржкржбрзЗржЯ рж╣ржпрж╝рзЗржЫрзЗред ржмрж░рзНрждржорж╛ржи ржкрж░рж┐ржорж╛ржг: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} ржПрж░ ржмрж┐ржХрзНрж░ржпрж╝ рж░рзЗржХрж░рзНржб ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред ржЕржмрж╢рж┐рж╖рзНржЯ рж╕рзНржЯржХ: {current_quantity} {unit}. ржорзЛржЯ ржмрж┐ржХрзНрж░ржпрж╝ ржкрж░рж┐ржорж╛ржг: {selling_amount}. рж▓рж╛ржн: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} ржПрж░ ржХрзНрж░ржпрж╝ рж░рзЗржХрж░рзНржб ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред ржирждрзБржи рж╕рзНржЯржХ: {current_quantity} {unit}. ржЦрж░ржЪ: {cost_price_per_unit} ржкрзНрж░рждрж┐ {unit}.",
        "item_not_found": "'{item_name}' рж╕рзНржЯржХ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред ржЖржкржирж┐ ржХрж┐ ржПржЯрж┐ ржпрзЛржЧ ржХрж░рждрзЗ ржЪрж╛ржи?",
        "unknown_command": "ржЖржорж┐ ржмрзБржЭрждрзЗ ржкрж╛рж░рж┐ржирж┐ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи ржмрж╛ 'рж╕рж╛рж╣рж╛ржпрзНржп' ржЯрж╛ржЗржк ржХрж░рзБржиред",
        "current_stock": "{item_name} ржПрж░ ржмрж░рзНрждржорж╛ржи рж╕рзНржЯржХ: {current_quantity} {unit}.",
        "all_stock_items": "ржЖржкржирж╛рж░ ржмрж░рзНрждржорж╛ржи рж╕рзНржЯржХ:\n{stock_list}",
        "daily_summary": "{date} ржПрж░ ржЬржирзНржп ржжрзИржирж┐ржХ ржмрж┐ржХрзНрж░ржпрж╝ рж╕рж╛рж░рж╛ржВрж╢:\nржорзЛржЯ ржмрж┐ржХрзНрж░ржпрж╝: {total_sales}\nржорзЛржЯ рж▓рж╛ржн: {total_profit}\n{sales_details}",
        "low_stock_alert": "тЪая╕П ржХржо рж╕рзНржЯржХ рж╕рждрж░рзНржХрждрж╛! ржирж┐ржорзНржирж▓рж┐ржЦрж┐ржд ржЖржЗржЯрзЗржоржЧрзБрж▓рж┐ ржХржо рж╣ржЪрзНржЫрзЗ:\n{low_stock_items_list}\nрж╢рзАржШрзНрж░ржЗ ржЕрж░рзНржбрж╛рж░ ржХрж░рж╛рж░ ржХржерж╛ ржнрж╛ржмрзБржиред",
        "call_initiated": "{item_name} ржПрж░ {quantity} {unit} ржПрж░ ржЬржирзНржп {supplier_name} ({supplier_phone_number}) ржХрзЗ ржХрж▓ рж╢рзБрж░рзБ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗред ржЕрж░рзНржбрж╛рж░ ржирж┐рж╢рзНржЪрж┐ржд рж╣ржУржпрж╝рж╛рж░ ржкрж░рзЗ ржЖржорж┐ ржЖржкржирж╛ржХрзЗ ржЬрж╛ржирж╛ржмрзЛред",
        "order_confirmation_prompt": "ржЖржкржирж┐ ржХрзЛржи ржЖржЗржЯрзЗржо ржПржмржВ рж╕рж░ржмрж░рж╛рж╣ржХрж╛рж░рзАрж░ ржЬржирзНржп ржЕрж░рзНржбрж╛рж░ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рждрзЗ ржЪрж╛ржи? ржЙржжрж╛рж╣рж░ржг: 'рж╕рж╛ржкрзНрж▓рж╛ржпрж╝рж╛рж░ ржП ржерзЗржХрзЗ 10 ржХрзЗржЬрж┐ ржЪрж╛рж▓ ржЕрж░рзНржбрж╛рж░ ржХрж░рзБржи'.",
        "order_confirmed_shopkeeper": "тЬЕ {item_name} ржПрж░ {quantity} {unit} ржПрж░ ржЬржирзНржп {supplier_name} ржерзЗржХрзЗ ржЕрж░рзНржбрж╛рж░ ржирж┐рж╢рзНржЪрж┐ржд рж╣ржпрж╝рзЗржЫрзЗред рж╕рзНржЯржХ ржЖржкржбрзЗржЯ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред 2 ржжрж┐ржирзЗрж░ ржоржзрзНржпрзЗ ржбрзЗрж▓рж┐ржнрж╛рж░рж┐ ржЖрж╢рж╛ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗред",
        "order_failed_shopkeeper": "тЭМ {item_name} ржПрж░ {supplier_name} ржерзЗржХрзЗ ржЕрж░рзНржбрж╛рж░ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рж╛ ржпрж╛ржпрж╝ржирж┐ред ржХрж╛рж░ржг: {reason}"
    },
    "mr": { # Marathi messages
        "sale_success": "тЬЕ рддреБрдордЪреНрдпрд╛ рдбрд┐рдЬрд┐рдЯрд▓ рдЦрд╛рддреНрдпрд╛рдд тВ╣{amount:.2f} ({item}) рдЪреА рд╡рд┐рдХреНрд░реА рдиреЛрдВрджрд╡рд▓реА рдЧреЗрд▓реА рдЖрд╣реЗ.",
        "sale_success_no_item": "тЬЕ рддреБрдордЪреНрдпрд╛ рдбрд┐рдЬрд┐рдЯрд▓ рдЦрд╛рддреНрдпрд╛рдд тВ╣{amount:.2f} рдЪреА рд╡рд┐рдХреНрд░реА рдиреЛрдВрджрд╡рд▓реА рдЧреЗрд▓реА рдЖрд╣реЗ.",
        "expense_success": "тЬЕ рддреБрдордЪреНрдпрд╛ рдбрд┐рдЬрд┐рдЯрд▓ рдЦрд╛рддреНрдпрд╛рдд тВ╣{amount} ({item}) рдЪрд╛ рдЦрд░реНрдЪ рдиреЛрдВрджрд╡рд▓рд╛ рдЧреЗрд▓рд╛ рдЖрд╣реЗ.",
        "expense_success_no_item": "тЬЕ рддреБрдордЪреНрдпрд╛ рдбрд┐рдЬрд┐рдЯрд▓ рдЦрд╛рддреНрдпрд╛рдд тВ╣{amount} рдЪрд╛ рдЦрд░реНрдЪ рдиреЛрдВрджрд╡рд▓рд╛ рдЧреЗрд▓рд╛ рдЖрд╣реЗ.",
        "balance_inquiry": "ЁЯУК рддреБрдордЪреНрдпрд╛ рдбрд┐рдЬрд┐рдЯрд▓ рдЦрд╛рддреНрдпрд╛рддреАрд▓ рд╕рдзреНрдпрд╛рдЪреА рд╢рд┐рд▓реНрд▓рдХ тВ╣{balance:.2f} рдЖрд╣реЗ.\n\nрдЕрд▓реАрдХрдбреАрд▓ рд╡реНрдпрд╡рд╣рд╛рд░:\n{transactions_summary}",
        "extract_fail": "рддреБрдордЪреНрдпрд╛ рд╡реНрд╣реЙрдЗрд╕ рдиреЛрдЯрдордзреВрди рдбреЗрдЯрд╛ рдХрд╛рдврддрд╛ рдЖрд▓рд╛ рдирд╛рд╣реА. рдХреГрдкрдпрд╛ рд╕реНрдкрд╖реНрдЯ рдмреЛрд▓рд╛.",
        "transcribe_fail": "рддреБрдордЪрд╛ рд╡реНрд╣реЙрдЗрд╕ рдиреЛрдЯ рдЯреНрд░рд╛рдиреНрд╕рдХреНрд░рд╛рдЗрдм рдХрд┐рдВрд╡рд╛ рдЕрдиреБрд╡рд╛рджрд┐рдд рдХрд░рддрд╛ рдЖрд▓рд╛ рдирд╛рд╣реА. рдСрдбрд┐рдУ рдЧреБрдгрд╡рддреНрддрд╛ рдЦрд░рд╛рдм рдЕрд╕реВ рд╢рдХрддреЗ.",
        "download_fail": "рддреБрдордЪреЗ рд╡реНрд╣реЙрдЗрд╕ рдиреЛрдЯ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░рдгреНрдпрд╛рдд рдЕрдпрд╢рд╕реНрд╡реА: {error_msg}. рдХреГрдкрдпрд╛ рдкреБрдиреНрд╣рд╛ рдкреНрд░рдпрддреНрди рдХрд░рд╛.",
        "network_error": "рддреБрдордЪреЗ рд╡реНрд╣реЙрдЗрд╕ рдиреЛрдЯ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░рддрд╛рдирд╛ рдиреЗрдЯрд╡рд░реНрдХ рддреНрд░реБрдЯрд┐ рдЖрд▓реА: {error_msg}. рдХреГрдкрдпрд╛ рдкреБрдиреНрд╣рд╛ рдкреНрд░рдпрддреНрди рдХрд░рд╛.",
        "file_error": "рд╡реНрд╣реЙрдЗрд╕ рдиреЛрдЯ рдлрд╛рдЗрд▓реНрдордзреНрдпреЗ рд╕рдорд╕реНрдпрд╛ рд╣реЛрддреА: {error_msg}. рдХреГрдкрдпрд╛ рддреА рдкреБрдиреНрд╣рд╛ рдкрд╛рдард╡рд╛.",
        "unexpected_error": "рддреБрдордЪреНрдпрд╛ рд╡реНрд╣реЙрдЗрд╕ рдиреЛрдЯрд╡рд░ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рддрд╛рдирд╛ рдЕрдирдкреЗрдХреНрд╖рд┐рдд рддреНрд░реБрдЯреА рдЖрд▓реА. рдХреГрдкрдпрд╛ рдкреБрдиреНрд╣рд╛ рдкреНрд░рдпрддреНрди рдХрд░рд╛.",
        "no_voice_note": "рдХреГрдкрдпрд╛ рд╡реНрдпрд╡рд╣рд╛рд░рд╛рдЪреНрдпрд╛ рдкреНрд░рдХреНрд░рд┐рдпреЗрд╕рд╛рдареА рд╡реНрд╣реЙрдЗрд╕ рдиреЛрдЯ рдкрд╛рдард╡рд╛ рдХрд┐рдВрд╡рд╛ рд╢рд┐рд▓реНрд▓рдХ рдЪреМрдХрд╢реАрд╕рд╛рдареА рдордЬрдХреВрд░ рд╕рдВрджреЗрд╢ рдкрд╛рдард╡рд╛.",
        "unsupported_media": "рдЕрд╕рдорд░реНрдерд┐рдд рдореАрдбрд┐рдпрд╛ рдкреНрд░рдХрд╛рд░: {media_type}. рдХреГрдкрдпрд╛ рд╡реНрд╣реЙрдЗрд╕ рдиреЛрдЯ рдХрд┐рдВрд╡рд╛ рдЗрдореЗрдЬ рдкрд╛рдард╡рд╛.",
        "no_transactions_found": "рдЕрд▓реАрдХрдбреАрд▓ рдХреЛрдгрддреЗрд╣реА рд╡реНрдпрд╡рд╣рд╛рд░ рдЖрдврд│рд▓реЗ рдирд╛рд╣реАрдд.",
        "image_received_stock_update": "рдЗрдореЗрдЬ рдкреНрд░рд╛рдкреНрдд рдЭрд╛рд▓реА! рд╕реНрдЯреЙрдХ рдЕрджреНрдпрдпрд╛рд╡рдд рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдкреНрд░рдХреНрд░рд┐рдпрд╛ рд╕реБрд░реВ рдЖрд╣реЗ...",
        "stock_update_success": "тЬЕ рд╕реНрдЯреЙрдХ рдпрд╢рд╕реНрд╡реАрд░рд┐рддреНрдпрд╛ рдЕрджреНрдпрдпрд╛рд╡рд┐рдд рдЭрд╛рд▓рд╛: {updates}.",
        "stock_update_fail": "тЭМ рдЗрдореЗрдЬрдордзреВрди рд╕реНрдЯреЙрдХ рдЕрджреНрдпрдпрд╛рд╡рд┐рдд рдХрд░рдгреНрдпрд╛рдд рдЕрдпрд╢рд╕реНрд╡реА. рддреНрд░реБрдЯреА: {error_msg}",
        "file_download_error": "рддреБрдордЪреА рдЗрдореЗрдЬ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░рдгреНрдпрд╛рдд рдЕрдпрд╢рд╕реНрд╡реА: {error_msg}. рдХреГрдкрдпрд╛ рдкреБрдиреНрд╣рд╛ рдкреНрд░рдпрддреНрди рдХрд░рд╛.",
        "low_stock_alert": "тЪая╕П рдХрдореА рд╕реНрдЯреЙрдХ рдЕрд▓рд░реНрдЯ! рдЦрд╛рд▓реАрд▓ рд╡рд╕реНрддреВ рдХрдореА рд╣реЛрдд рдЖрд╣реЗрдд:\n{low_stock_items_list}\nрд▓рд╡рдХрд░рдЪ рдСрд░реНрдбрд░ рдХрд░рдгреНрдпрд╛рдЪрд╛ рд╡рд┐рдЪрд╛рд░ рдХрд░рд╛ред",
        "welcome": "рдирдорд╕реНрдХрд╛рд░! рдореА рддреБрдордЪрд╛ рдЗрдиреНрд╡реНрд╣реЗрдВрдЯрд░реА рдореЕрдиреЗрдЬрдореЗрдВрдЯ рдмреЙрдЯ рдЖрд╣реЗ. рдореА рддреБрдореНрд╣рд╛рд▓рд╛ рдХрд╢реА рдорджрдд рдХрд░реВ рд╢рдХрддреЛ?",
        "stock_updated": "{item_name} рдЪрд╛ рд╕реНрдЯреЙрдХ рдпрд╢рд╕реНрд╡реАрд░рд┐рддреНрдпрд╛ рдЕрджреНрдпрдпрд╛рд╡рд┐рдд рдЭрд╛рд▓рд╛. рд╕рдзреНрдпрд╛рдЪреА рд╕рдВрдЦреНрдпрд╛: {current_quantity} {unit}.",
        "sale_recorded": "{quantity} {unit} {item_name} рдЪреА рд╡рд┐рдХреНрд░реА рдиреЛрдВрджрд╡рд▓реА рдЧреЗрд▓реА. рдЙрд░реНрд╡рд░рд┐рдд рд╕реНрдЯреЙрдХ: {current_quantity} {unit}. рдПрдХреВрдг рд╡рд┐рдХреНрд░реА рд░рдХреНрдХрдо: {selling_amount}. рдирдлрд╛: {profit}.",
        "purchase_recorded": "{quantity} {unit} {item_name} рдЪреА рдЦрд░реЗрджреА рдиреЛрдВрджрд╡рд▓реА рдЧреЗрд▓реА. рдирд╡реАрди рд╕реНрдЯреЙрдХ: {current_quantity} {unit}. рдХрд┐рдВрдордд: {cost_price_per_unit} рдкреНрд░рддрд┐ {unit}.",
        "item_not_found": "'{item_name}' рд╕реНрдЯреЙрдХ рдордзреНрдпреЗ рдЖрдврд│рд▓реЗ рдирд╛рд╣реА. рддреБрдореНрд╣реА рддреЗ рдЬреЛрдбреВ рдЗрдЪреНрдЫрд┐рддрд╛ рдХрд╛?",
        "unknown_command": "рдорд▓рд╛ рд╕рдордЬрд▓реЗ рдирд╛рд╣реА. рдХреГрдкрдпрд╛ рдкреБрдиреНрд╣рд╛ рдкреНрд░рдпрддреНрди рдХрд░рд╛ рдХрд┐рдВрд╡рд╛ 'рдорджрдд' рдЯрд╛рдЗрдк рдХрд░рд╛.",
        "current_stock": "{item_name} рдЪрд╛ рд╡рд░реНрддрдорд╛рди рд╕реНрдЯреЙрдХ: {current_quantity} {unit}.",
        "all_stock_items": "рддреБрдордЪрд╛ рд╡рд░реНрддрдорд╛рди рд╕реНрдЯреЙрдХ:\n{stock_list}",
        "daily_summary": "{date} рд╕рд╛рдареА рджреИрдирд┐рдХ рд╡рд┐рдХреНрд░реА рд╕рд╛рд░рд╛рдВрд╢:\nрдПрдХреВрдг рд╡рд┐рдХреНрд░реА: {total_sales}\nрдПрдХреВрдг рдирдлрд╛: {total_profit}\n{sales_details}",
        "low_stock_alert": "тЪая╕П рдХрдореА рд╕реНрдЯреЙрдХ рдЕрд▓рд░реНрдЯ! рдЦрд╛рд▓реАрд▓ рд╡рд╕реНрддреВ рдХрдореА рд╣реЛрдд рдЖрд╣реЗрдд:\n{low_stock_items_list}\nрд▓рд╡рдХрд░рдЪ рдСрд░реНрдбрд░ рдХрд░рдгреНрдпрд╛рдЪрд╛ рд╡рд┐рдЪрд╛рд░ рдХрд░рд╛ред",
        "call_initiated": "{item_name} рдЪреНрдпрд╛ {quantity} {unit} рд╕рд╛рдареА {supplier_name} ({supplier_phone_number}) рд▓рд╛ рдХреЙрд▓ рд╕реБрд░реВ рдХреЗрд▓рд╛ рдЬрд╛рдд рдЖрд╣реЗ. рдСрд░реНрдбрд░рдЪреА рдкреБрд╖реНрдЯреА рдЭрд╛рд▓реНрдпрд╛рд╡рд░ рдореА рддреБрдореНрд╣рд╛рд▓рд╛ рд╕реВрдЪрд┐рдд рдХрд░реЗрди.",
        "order_confirmation_prompt": "рддреБрдореНрд╣рд╛рд▓рд╛ рдХреЛрдгрддреНрдпрд╛ рд╡рд╕реНрддреВ рдЖрдгрд┐ рдкреБрд░рд╡рдард╛рджрд╛рд░рд╛рд╕рд╛рдареА рдСрд░реНрдбрд░ рдирд┐рд╢реНрдЪрд┐рдд рдХрд░рд╛рдпрдЪрд╛ рдЖрд╣реЗ? рдЙрджрд╛рд╣рд░рдг: 'рдкреБрд░рд╡рдард╛рджрд╛рд░ A рдХрдбреВрди 10 рдХрд┐рд▓реЛ рддрд╛рдВрджреВрд│ рдСрд░реНрдбрд░ рдХрд░рд╛'.",
        "order_confirmed_shopkeeper": "тЬЕ {item_name} рдЪреНрдпрд╛ {quantity} {unit} рдЪрд╛ {supplier_name} рдХрдбреВрди рдСрд░реНрдбрд░ рдирд┐рд╢реНрдЪрд┐рдд рдЭрд╛рд▓рд╛ рдЖрд╣реЗ. рд╕реНрдЯреЙрдХ рдЕрджреНрдпрдпрд╛рд╡рд┐рдд рдЭрд╛рд▓рд╛ рдЖрд╣реЗ. 2 рджрд┐рд╡рд╕рд╛рдВрдд рд╡рд┐рддрд░рдг рдЕрдкреЗрдХреНрд╖рд┐рдд рдЖрд╣реЗ.",
        "order_failed_shopkeeper": "тЭМ {item_name} рдЪреНрдпрд╛ {supplier_name} рдХрдбреВрди рдСрд░реНрдбрд░ рдирд┐рд╢реНрдЪрд┐рдд рдХрд░рдгреНрдпрд╛рдд рдЕрдпрд╢рд╕реНрд╡реА. рдХрд╛рд░рдг: {reason}"
    }
}


SUPPLIERS = {
    "Supplier A": {
        "phone": "+919971129359",
        "items": {
            "рдЪрд╛рд╡рд▓": {"price_per_unit": 45.0, "unit": "kg"},
            "рдЖрдЯрд╛": {"price_per_unit": 30.0, "unit": "kg"},
            "рд╕реВрдЬреА": {"price_per_unit": 40.0, "unit": "kg"},
            "рд░рд╛рдЬрдорд╛": {"price_per_unit": 120.0, "unit": "kg"},
            "рдореВрдВрдЧ рджрд╛рд▓": {"price_per_unit": 90.0, "unit": "kg"},
            "рдЙрдбрд╝рдж рджрд╛рд▓": {"price_per_unit": 100.0, "unit": "kg"},
        }
    },
    "Supplier B": {
        "phone": "+919988776655",
        "items": {
            "рдЪрд╛рд╡рд▓": {"price_per_unit": 47.0, "unit": "kg"},
            "рдЖрдЯрд╛": {"price_per_unit": 28.0, "unit": "kg"},
            "рд╕реВрдЬреА": {"price_per_unit": 42.0, "unit": "kg"},
            "рд░рд╛рдЬрдорд╛": {"price_per_unit": 118.0, "unit": "kg"},
            "рдореВрдВрдЧ рджрд╛рд▓": {"price_per_unit": 92.0, "unit": "kg"},
            "рдЙрдбрд╝рдж рджрд╛рд▓": {"price_per_unit": 98.0, "unit": "kg"},
        }
    },
    "Supplier C": {
        "phone": "+917788990011",
        "items": {
            "рдЪрд╛рд╡рд▓": {"price_per_unit": 46.0, "unit": "kg"},
            "рдЖрдЯрд╛": {"price_per_unit": 31.0, "unit": "kg"},
            "рд╕реВрдЬреА": {"price_per_unit": 39.0, "unit": "kg"},
            "рд░рд╛рдЬрдорд╛": {"price_per_unit": 125.0, "unit": "kg"},
            "рдореВрдВрдЧ рджрд╛рд▓": {"price_per_unit": 88.0, "unit": "kg"},
            "рдЙрдбрд╝рдж рджрд╛рд▓": {"price_per_unit": 105.0, "unit": "kg"},
        }
    }
}

class DownloadError(Exception):
    pass

async def find_cheapest_supplier_for_item(item_name: str, item_unit: str) -> dict | None:
    cheapest_supplier = None
    min_price = float('inf')

    # Normalize the item_name and item_unit for better matching
    normalized_item_name = item_name.lower().strip()
    normalized_item_unit = item_unit.lower().strip()

    print(f"DEBUG_SUPPLIER: Searching for cheapest supplier for '{normalized_item_name}' ({normalized_item_unit}).")

    for supplier_name, supplier_info in SUPPLIERS.items():
        for supplier_item_name, item_details in supplier_info["items"].items():
            normalized_supplier_item_name = supplier_item_name.lower().strip()
            supplier_item_unit = item_details["unit"].lower().strip()

            # Use fuzzy matching for item names
            name_score = max(fuzz.token_sort_ratio(normalized_item_name, normalized_supplier_item_name),
                             fuzz.partial_ratio(normalized_item_name, normalized_supplier_item_name))
            
            # Consider a high threshold for fuzzy matching to ensure accuracy
            if name_score >= 80 and normalized_item_unit == supplier_item_unit: # Also ensure units match
                price = item_details["price_per_unit"]
                print(f"DEBUG_SUPPLIER: Found match with {supplier_name} for '{supplier_item_name}' (score: {name_score}). Price: {price} {supplier_item_unit}")

                if price < min_price or (price == min_price and supplier_info["phone"] == "+919971129359"):
                    min_price = price
                    cheapest_supplier = {
                        "supplier_name": supplier_name,
                        "phone": supplier_info["phone"],
                        "item_name": supplier_item_name,
                        "price_per_unit": price,
                        "unit": supplier_item_unit
                    }
    
    if cheapest_supplier:
        print(f"DEBUG_SUPPLIER: Cheapest supplier found: {cheapest_supplier['supplier_name']} for {cheapest_supplier['item_name']} at тВ╣{cheapest_supplier['price_per_unit']}/{cheapest_supplier['unit']}")
    else:
        print(f"DEBUG_SUPPLIER: No cheapest supplier found for '{normalized_item_name}' ({normalized_item_unit}).")

    return cheapest_supplier

@retry(stop=stop_after_attempt(3), wait=wait_fixed(2), retry=retry_if_exception_type(DownloadError))
def download_media_with_retry(media_url: str, file_path: str):
    print(f"Attempting to download media from: {media_url}")
    response = requests.get(media_url, auth=(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN), timeout=10)
    print(f"Download response status code: {response.status_code}")
    response.raise_for_status()

    if not response.content:
        raise DownloadError(f"Downloaded content from {media_url} is empty.")

    with open(file_path, 'wb') as f:
        f.write(response.content)
    print(f"Media downloaded successfully to {file_path}")

async def send_whatsapp_message(to_number: str, message_body: str):
    if to_number == TWILIO_WHATSAPP_NUMBER:
        print(f"DEBUG: Skipping sending message to self ({to_number}). Message: {message_body}")
        return
    try:
        print(f"DEBUG: Attempting to send WhatsApp message to {to_number} from {TWILIO_WHATSAPP_NUMBER}. Message: {message_body}")
        message = await asyncio.to_thread(
            twilio_client.messages.create,
            to=to_number,
            from_=TWILIO_WHATSAPP_NUMBER,
            body=message_body
        )
        print(f"DEBUG: WhatsApp message sent successfully. SID: {message.sid}")
    except Exception as e:
        print(f"ERROR: Failed to send WhatsApp message to {to_number}: {e}")

@app.route("/whatsapp", methods=["POST"])
async def whatsapp_webhook():
    sender_id = request.form.get('From', '')
    message_body = request.form.get('Body', '')
    media_url = request.form.get('MediaUrl0', None)
    media_content_type = request.form.get('MediaContentType0', None)
    current_date = date.today()

    print(f"DEBUG_WEBHOOK: Received message. MediaUrl0: {media_url}, MediaContentType0: {media_content_type}")

    detected_language = 'en'
    original_transcription = ""
    english_translation = ""

    should_return_early = False

    balance_keywords = ["balance", "account", "kitna", "total", "shilak", "rupai", "money", "рдЦрд╛рддрд╛", "рдХрд┐рддрдиреЗ рдкреИрд╕реЗ рд╣реИрдВ", "how much money", "kitni rakam hai", "рд╢рд┐рд▓реНрд▓рдХ", "рд░рдХреНрдХрдо"]
    earnings_keywords = ["kamai", "earnings", "profit", "aaj kii", "today's", "рдХрд┐рддрдиреА рдХрдорд╛рдИ рд╣реБрдИ", "рдЖрдЬ рдХреА рдХрдорд╛рдИ", "рдлрд╛рдпрджрд╛", "рдХрдордИ", "how much did you earn today", "how much you earn today", "total sales today", "total earned today", "рдЖрдЬ рдХрдордИ", "рдХрдордИ", "aaj ki kamai", "how much today earnings"]

    cleaned_original_transcription = ""
    cleaned_english_translation = ""

    if media_url:
        if media_content_type and 'audio' in media_content_type:
            try:
                audio_file_path = f"./temp_audio_{sender_id.replace(':', '_')}.ogg"
                download_media_with_retry(media_url, audio_file_path)

                mp3_file_path = audio_file_path.replace(".ogg", ".mp3")
                AudioSegment.from_file(audio_file_path).export(mp3_file_path, format="mp3")
                os.remove(audio_file_path)

                transcription_result = transcribe_audio(mp3_file_path)
                os.remove(mp3_file_path)

                original_transcription = transcription_result["original_transcription"]
                english_translation = transcription_result["english_translation"]
                detected_language = language_map.get(transcription_result["detected_language"], 'en')
                print(f"Detected language: {detected_language}")
                print(f"Original Transcription: {original_transcription}")
                print(f"English Translation: {english_translation}")

                cleaned_original_transcription = re.sub(r'[^\w\s]', '', original_transcription, flags=re.IGNORECASE | re.UNICODE).lower().strip() if original_transcription else ''
                cleaned_english_translation = re.sub(r'[^\w\s]', '', english_translation, flags=re.IGNORECASE | re.UNICODE).lower().strip() if english_translation else ''

            except Exception as e:
                print(f"Error during voice note processing: {e}")
                reply_message = MESSAGES[detected_language]["file_error"].format(error_msg=str(e))
                await send_whatsapp_message(sender_id, reply_message)
                should_return_early = True
                original_transcription = ""
                english_translation = ""

        elif media_content_type and 'image' in media_content_type:
            try:
                image_file_path = f"./temp_image_{sender_id.replace(':', '_')}.jpg"
                download_media_with_retry(media_url, image_file_path)

                await send_whatsapp_message(sender_id, MESSAGES[detected_language]["image_received_stock_update"])

                extracted_bill_data = extract_items_from_bill_image(image_file_path)
                os.remove(image_file_path)

                bill_type = extracted_bill_data.get("bill_type", "unknown")
                extracted_items = extracted_bill_data.get("items", [])
                detected_language_from_bill = extracted_bill_data.get("detected_language", 'en')

                detected_language = language_map.get(detected_language_from_bill, 'en')
                print(f"DEBUG: Detected language from bill: {detected_language_from_bill} -> Normalized: {detected_language}")

                print(f"DEBUG: Extracted bill type: {bill_type}")
                print(f"DEBUG: Extracted items: {extracted_items}")

                if extracted_items:
                    update_messages = []

                    if bill_type == "unknown":
                        if any(item.get("cost_price_per_unit") is not None for item in extracted_items):
                            bill_type = "purchase"
                        elif any(item.get("selling_price_per_unit") is not None for item in extracted_items):
                            reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg="Sales via image are not supported. Please send sales details (item name, quantity, selling price) via voice note or text.")
                            await send_whatsapp_message(sender_id, reply_message)
                            should_return_early = True

                    if bill_type == "purchase":
                        total_bill_expense = 0.0
                        for item in extracted_items:
                            item_name = item.get("item_name")
                            quantity = item.get("quantity")
                            unit = item.get("unit", "pcs")
                            cost_price_per_unit = item.get("cost_price_per_unit")

                            if item_name and isinstance(quantity, (int, float)) and cost_price_per_unit is not None:
                                print(f"DEBUG: Processing purchase item: {item_name}, quantity={float(quantity)} {unit}, cost_price_per_unit={cost_price_per_unit}")
                                await update_stock_item(sender_id, item_name, float(quantity), unit, cost_price_per_unit)
                                update_messages.append(f"{item_name}: {quantity} {unit}")

                                quantity_for_expense_calc = float(quantity)

                                total_bill_expense += quantity_for_expense_calc * float(cost_price_per_unit)

                        if update_messages:
                            if total_bill_expense > 0:
                                expense_data = {
                                    "date": current_date.strftime('%Y-%m-%d'),
                                    "type": "expense",
                                    "amount": total_bill_expense,
                                    "item": f"Stock purchase via bill ({len(update_messages)} items)"
                                }
                                await save_transaction(expense_data, sender_id)
                                update_messages.append(f"Total expense of тВ╣{total_bill_expense:.2f} recorded.")

                            reply_message = MESSAGES[detected_language]["stock_update_success"].format(updates="\n".join(update_messages))
                            await send_whatsapp_message(sender_id, reply_message)
                            should_return_early = True
                        else:
                            reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg="Could not extract any valid items with cost prices from the purchase bill.")
                            await send_whatsapp_message(sender_id, reply_message)
                            should_return_early = True

                    elif bill_type == "sale":
                        reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg="Sales bills cannot be processed via image. Please send sales information via voice note or text (item name, quantity, selling price).")
                        await send_whatsapp_message(sender_id, reply_message)
                        should_return_early = True

                    else:
                        reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg="Could not extract any valid items or clear pricing information from the image to determine bill type.")
                        await send_whatsapp_message(sender_id, reply_message)
                        should_return_early = True

                else:
                    reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg="Could not extract any items from the image.")
                    await send_whatsapp_message(sender_id, reply_message)
                    should_return_early = True

            except Exception as e:
                print(f"Error during image processing: {e}")
                print(f"DEBUG: Type of exception e: {type(e)}")
                print(f"DEBUG: Content of exception e: {e}")
                reply_message = MESSAGES[detected_language]["stock_update_fail"].format(error_msg=str(e))
                await send_whatsapp_message(sender_id, reply_message)
                should_return_early = True
        else:
            print(f"Unsupported media type received: {media_content_type}")
            reply_message = MESSAGES[detected_language]["unsupported_media"].format(media_type=media_content_type)
            await send_whatsapp_message(sender_id, reply_message)
            should_return_early = True

    if should_return_early:
        return str(MessagingResponse())

    if message_body and not should_return_early:
        original_transcription = message_body
        english_translation = message_body
        print(f"Received text message: {message_body}")
        detected_language = 'en'
        cleaned_original_transcription = re.sub(r'[^\w\s]', '', original_transcription, flags=re.IGNORECASE | re.UNICODE).lower().strip() if original_transcription else ''
        cleaned_english_translation = re.sub(r'[^\w\s]', '', english_translation, flags=re.IGNORECASE | re.UNICODE).lower().strip() if english_translation else ''

    if should_return_early:
        return str(MessagingResponse())

    if not should_return_early:
        print(f"DEBUG_APP: should_return_early at start of main processing block: {should_return_early}")

        if detected_language != 'en' and english_translation:
            text_for_extraction = english_translation
            print(f"DEBUG: Using English translation for extraction (prioritized due to non-English detected language): {text_for_extraction}")
        elif original_transcription:
            text_for_extraction = original_transcription
            print(f"DEBUG: Using original transcription for extraction (default or English detected): {text_for_extraction}")
        elif english_translation:
            text_for_extraction = english_translation
            print(f"DEBUG: Using English translation for extraction (fallback): {text_for_extraction}")
        else:
            text_for_extraction = ""
            print("DEBUG: No text available for extraction.")

        is_balance_inquiry = any(keyword in cleaned_original_transcription or keyword in cleaned_english_translation for keyword in balance_keywords)
        is_earnings_inquiry = any(keyword in cleaned_original_transcription or keyword in cleaned_english_translation for keyword in earnings_keywords)

        if is_earnings_inquiry:
            today_sales, today_sales_transactions = await get_daily_sales_summary(sender_id, current_date)

            sales_details_list = []
            if today_sales_transactions:
                for txn in today_sales_transactions:
                    txn_item = txn.get("item", "N/A")
                    txn_amount = f'{txn.get("amount", 0.0):.2f}'
                    sales_details_list.append(f"тАв {txn_item}: тВ╣{txn_amount}")
                sales_details_str = "\n".join(sales_details_list)
            else:
                sales_details_str = MESSAGES[detected_language].get("no_sales_found_today", "No sales found today.")

            reply_message = MESSAGES[detected_language]["earnings_summary"].format(
                total_sales=today_sales,
                sales_details=sales_details_str
            )
            await send_whatsapp_message(sender_id, reply_message)
            should_return_early = True

        elif is_balance_inquiry:
            total_balance, recent_transactions = await get_user_transactions_summary(sender_id)

            transactions_summary_list = []
            for txn in recent_transactions:
                txn_date = txn.get("transaction_date", "N/A")
                txn_type = txn.get("transaction_type", "N/A").capitalize()
                txn_amount = f'{txn.get("amount", "N/A"):.2f}' if isinstance(txn.get("amount"), (int, float)) else "N/A"
                txn_item = txn.get("item", "")

                formatted_txn_amount = txn_amount
                formatted_txn_date = txn_date

                summary_line = f"тАв Date: {formatted_txn_date}, Type: {txn_type}, Amount: тВ╣{formatted_txn_amount}"
                if txn_item:
                    summary_line += f" ({txn_item})"
                transactions_summary_list.append(summary_line)

            transactions_summary_str = "\n".join(transactions_summary_list) if transactions_summary_list else MESSAGES[detected_language].get("no_transactions_found", "No recent transactions found.")

            reply_message = MESSAGES[detected_language]["balance_inquiry"].format(
                balance=total_balance,
                transactions_summary=transactions_summary_str
            )

            await send_whatsapp_message(sender_id, reply_message)
            should_return_early = True

        elif (english_translation or original_transcription):
            if detected_language != 'en' and english_translation:
                text_for_extraction = english_translation
                print(f"DEBUG: Using English translation for extraction (prioritized due to non-English detected language): {text_for_extraction}")
            elif original_transcription:
                text_for_extraction = original_transcription
                print(f"DEBUG: Using original transcription for extraction (default or English detected): {text_for_extraction}")
            elif english_translation:
                text_for_extraction = english_translation
                print(f"DEBUG: Using English translation for extraction (fallback): {text_for_extraction}")
            else:
                text_for_extraction = ""
                print("DEBUG: No text available for extraction.")

            if not text_for_extraction:
                print("ERROR_APP: No valid text available for extraction after selection logic.")
                await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])
                should_return_early = True
                return str(MessagingResponse()) # Return early

            print(f"DEBUG: Text for structured data extraction: {text_for_extraction}")
            try:
                raw_extracted_content = extract_structured_data(text_for_extraction, current_date)
                print(f"DEBUG_APP: Raw extracted content (from data_extractor): {raw_extracted_content}")
                extracted_data = copy.deepcopy(raw_extracted_content)
                print(f"DEBUG_APP: Extracted structured data (after direct deep copy): {extracted_data}")
            except Exception as e:
                print(f"ERROR_APP: Exception during data extraction or type checking: {e}")
                print(f"ERROR_APP: Type of exception: {type(e)}")
                extracted_data = {}
                should_return_early = True

            if isinstance(extracted_data, dict) and extracted_data:
                await _process_transaction_sync(
                    extracted_data,
                    sender_id,
                    detected_language,
                    current_date,
                    original_transcription,
                    english_translation
                )
            else:
                await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])
                should_return_early = True
        else:
            await send_whatsapp_message(sender_id, MESSAGES[detected_language]["transcribe_fail"])
            should_return_early = True

    print("DEBUG_APP: whatsapp_webhook function completing.")
    return str(MessagingResponse())

async def _translate_text_to_target_language(text: str, target_language: str) -> str:
    try:
        prompt = f"""Translate the following text into {target_language}. Respond only with the translated text.
Text: {text}"""
        response = client.chat.completions.create(
            model="gpt-3.5-turbo-0125",
            messages=[
                {"role": "system", "content": "You are a helpful assistant that translates text."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.0
        )
        translated_text = response.choices[0].message.content.strip()
        print(f"DEBUG_TRANSLATION: Original: '{text}', Translated to {target_language}: '{translated_text}'")
        return translated_text
    except Exception as e:
        print(f"ERROR_TRANSLATION: Error translating text: {e}")
        return text

async def _process_transaction_sync(extracted_data: dict, sender_id: str, detected_language: str, current_date: date, original_transcription: str, english_translation: str):
    print(f"DEBUG_APP: Entering synchronous transaction processing block with data: {extracted_data}")
    transaction_type = extracted_data.get("type", "").lower()
    print(f"DEBUG: Identified transaction type: {transaction_type}")

    profit_keywords = ["profit", "рдореБрдирд╛рдлрд╛", "labh", "рдлрд╛рдпda", "profitability", "рд▓рд╛рдн"]
    should_show_profit = any(keyword in original_transcription.lower() for keyword in profit_keywords) or \
                        any(keyword in english_translation.lower() for keyword in profit_keywords)

    if transaction_type == "sale":
        sales_summary_messages = []
        unprocessed_items_messages = []
        total_sales_amount = 0.0
        total_profit = 0.0

        items_sold = extracted_data.get("items_sold", [])
        if items_sold:
            stock_levels = await get_stock_levels(sender_id)
            stock_map = {f"{item['item_name']}-{item['unit']}": item for item in stock_levels}
            print(f"DEBUG_STOCK: Current stock_levels: {stock_levels}")
            print(f"DEBUG_STOCK: Current stock_map keys: {list(stock_map.keys())}")

            target_stock_language = "hi"

            for item in items_sold:
                item_name = item.get("item_name")
                quantity = item.get("quantity")
                unit = item.get("unit", "pcs")
                selling_amount = item.get("selling_amount")

                print(f"DEBUG_ITEM_PROCESSING: Processing extracted item: {{'item_name': '{item_name}', 'quantity': {quantity}, 'unit': '{unit}', 'selling_amount': {selling_amount}}}")

                if item_name and isinstance(quantity, (int, float)) and isinstance(selling_amount, (int, float)):
                    stock_item_name_for_lookup = item_name

                    contains_latin = bool(re.search(r'[a-zA-Z]', item_name))

                    if contains_latin and target_stock_language == "hi":
                        translated_item_name = await _translate_text_to_target_language(item_name, target_stock_language)
                        stock_item_name_for_lookup = translated_item_name
                        print(f"DEBUG: Extracted item name '{item_name}' contains Latin characters and target stock language is Hindi. Translated to '{translated_item_name}' for stock lookup.")
                    elif detected_language != target_stock_language:
                        translated_item_name = await _translate_text_to_target_language(item_name, target_stock_language)
                        stock_item_name_for_lookup = translated_item_name
                        print(f"DEBUG: Incoming item '{item_name}' (detected_lang={detected_language}) translated to '{translated_item_name}' (target_lang={target_stock_language}) for stock lookup.")
                    else:
                        print(f"DEBUG: Incoming item '{item_name}' (detected_lang={detected_language}) is already in target stock language ({target_stock_language}) or no translation needed. No translation performed.")

                    best_match_item_name = None
                    best_match_score = 0.0

                    print(f"DEBUG_FUZZY: Starting fuzzy match for '{stock_item_name_for_lookup}'")
                    for stock_item_obj in stock_levels:
                        item_name_in_stock = stock_item_obj['item_name']
                        current_score = max(fuzz.token_sort_ratio(stock_item_name_for_lookup.lower(), item_name_in_stock.lower()),
                                            fuzz.partial_ratio(stock_item_name_for_lookup.lower(), item_name_in_stock.lower()))
                        print(f"DEBUG_FUZZY: Comparing '{stock_item_name_for_lookup}' with stock item '{item_name_in_stock}'. Score: {current_score}")

                        if current_score > best_match_score:
                            best_match_score = current_score
                            best_match_item_name = item_name_in_stock

                    print(f"DEBUG_FUZZY: Best fuzzy match for '{stock_item_name_for_lookup}': '{best_match_item_name}' with score {best_match_score}")

                    if best_match_item_name and best_match_score >= 40:
                        original_lookup_name_before_fuzzy = stock_item_name_for_lookup
                        stock_item_name_for_lookup = best_match_item_name
                        print(f"DEBUG_FUZZY: Fuzzy match successful. Using '{stock_item_name_for_lookup}' (originally '{original_lookup_name_before_fuzzy}') for stock lookup.")
                    else:
                        print(f"DEBUG_FUZZY: No strong fuzzy match found for '{stock_item_name_for_lookup}' (score: {best_match_score}). Proceeding with original lookup name.")
                        pass

                    print(f"DEBUG_ITEM_MATCH: Attempting to find final stock item for '{stock_item_name_for_lookup}' with effective unit '{unit}'")
                    stock_key = f"{stock_item_name_for_lookup}-{unit}"

                    final_stock_item = None
                    if stock_key in stock_map:
                        final_stock_item = stock_map[stock_key]
                        print(f"DEBUG_ITEM_MATCH: Found exact match in stock_map for key: '{stock_key}'. Item: {final_stock_item}")
                    else:
                        print(f"DEBUG_ITEM_MATCH: No exact match in stock_map for key: '{stock_key}'. Attempting fuzzy unit match.")
                        for existing_stock_key, existing_stock_item in stock_map.items():
                            if fuzz.token_sort_ratio(stock_item_name_for_lookup.lower(), existing_stock_item['item_name'].lower()) >= 80:
                                final_stock_item = existing_stock_item
                                stock_key = existing_stock_key
                                unit = existing_stock_item['unit']
                                print(f"DEBUG_ITEM_MATCH: Found fuzzy item name match with stock item '{existing_stock_item['item_name']}' (unit: '{existing_stock_item['unit']}'). Using this item.")
                                break

                    print(f"DEBUG_FINAL_ITEM_CHECK: final_stock_item before not found check: {final_stock_item}")

                    if not final_stock_item:
                        debug_info = f"Original extracted: {item_name}"
                        if detected_language != target_stock_language:
                            debug_info += f", Translated (if applicable): {original_lookup_name_before_fuzzy if 'original_lookup_name_before_fuzzy' in locals() else item_name}"
                        if best_match_item_name:
                            debug_info += f", Fuzzy matched (if applicable): {best_match_item_name}"
                        debug_info += f", Unit: {unit}"
                        unprocessed_items_messages.append(f"'{item_name}' is not in stock. ({debug_info}). Sale not recorded.")
                        continue

                    if final_stock_item and 'unit' in final_stock_item:
                        unit = final_stock_item['unit']
                        print(f"DEBUG_UNIT: Final effective unit for transaction '{item_name}': '{unit}'. (Original extracted unit: '{item.get('unit', 'pcs')}')")


                    delta_for_update = -float(quantity)

                    await update_stock_item(sender_id, stock_item_name_for_lookup, delta_for_update, unit, None)

                    sale_data = {
                        "date": extracted_data.get("date", current_date.strftime('%Y-%m-%d')),
                        "type": "sale",
                        "amount": selling_amount,
                        "item": f"{stock_item_name_for_lookup} ({quantity} {item.get('unit', 'pcs')})"
                    }
                    await save_transaction(sale_data, sender_id)

                    total_sales_amount += selling_amount

                    cost_price_per_unit = None
                    if final_stock_item.get("cost_price_per_unit") is not None:
                        cost_price_per_unit = float(final_stock_item["cost_price_per_unit"])

                    profit_for_item = 0.0
                    if cost_price_per_unit is not None:
                        profit_for_item = selling_amount - (float(quantity) * cost_price_per_unit)
                        total_profit += profit_for_item

                    if should_show_profit and cost_price_per_unit is not None:
                        sales_summary_messages.append(f"{final_stock_item['item_name']}: тВ╣{selling_amount:.2f} (Profit: тВ╣{profit_for_item:.2f})")
                    else:
                        sales_summary_messages.append(f"{final_stock_item['item_name']}: тВ╣{selling_amount:.2f}")

            print(f"DEBUG_REPLY: sales_summary_messages: {sales_summary_messages}")
            print(f"DEBUG_REPLY: unprocessed_items_messages: {unprocessed_items_messages}")

            final_reply_parts = []
            if sales_summary_messages:
                success_item_summary = "\n".join(sales_summary_messages)
                item_details = f"Total Profit: тВ╣{total_profit:.2f}\n{success_item_summary}" if should_show_profit and total_profit > 0 else success_item_summary
                success_message = MESSAGES[detected_language]["sale_success"].format(amount=total_sales_amount, item_details=item_details)
                final_reply_parts.append(success_message)

            if unprocessed_items_messages:
                error_message = "тЭМ Some items were not processed:\n" + "\n".join(unprocessed_items_messages)
                final_reply_parts.append(error_message)

            print(f"DEBUG_REPLY: final_reply_parts before join: {final_reply_parts}")
            if final_reply_parts:
                reply_message = "\n\n".join(final_reply_parts)
                await send_whatsapp_message(sender_id, reply_message)
            else:
                await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])
        else:
            await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])

    elif transaction_type == "purchase":
        purchase_summary_messages = []
        total_purchase_expense = 0.0

        items_purchased = extracted_data.get("items_purchased", [])
        if items_purchased:
            for item in items_purchased:
                item_name = item.get("item_name")
                quantity = item.get("quantity")
                unit = item.get("unit", "pcs")
                cost_price_per_unit = item.get("cost_price_per_unit") # Corrected key

                if item_name and isinstance(quantity, (int, float)) and cost_price_per_unit is not None:
                    await update_stock_item(sender_id, item_name, float(quantity), unit, cost_price_per_unit)
                    purchase_summary_messages.append(f"{item_name}: {quantity} {unit} @ тВ╣{cost_price_per_unit:.2f}/{unit}")

                    total_purchase_expense += float(quantity) * float(cost_price_per_unit)

            if purchase_summary_messages:
                if total_purchase_expense > 0:
                    expense_data = {
                        "date": extracted_data.get("date", current_date.strftime('%Y-%m-%d')),
                        "type": "expense",
                        "amount": total_purchase_expense,
                        "item": f"Stock purchase ({len(purchase_summary_messages)} items)"
                    }
                    await save_transaction(expense_data, sender_id)
                    purchase_summary_messages.append(f"Total expense of тВ╣{total_purchase_expense:.2f} recorded.")

                reply_message = MESSAGES[detected_language]["stock_update_success"].format(updates="\n".join(purchase_summary_messages))
                await send_whatsapp_message(sender_id, reply_message)
            else:
                await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])
        else:
            await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])

    elif transaction_type == "expense":
        amount = extracted_data.get("amount")
        description = extracted_data.get("description", "")
        if isinstance(amount, (int, float)):
            expense_data = {
                "date": extracted_data.get("date", current_date.strftime('%Y-%m-%d')), "type": "expense",
                "amount": amount, "item": description
            }
            await save_transaction(expense_data, sender_id)

            if description:
                reply_message = MESSAGES[detected_language]["expense_success"].format(amount=amount, item=description)
            else:
                reply_message = MESSAGES[detected_language]["expense_success_no_item"].format(amount=amount)
            await send_whatsapp_message(sender_id, reply_message)
        else:
            await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])
    elif transaction_type == "order_confirmation":
        item_name = extracted_data.get("item_name")
        quantity = extracted_data.get("quantity")
        unit = extracted_data.get("unit", "pcs")
        supplier_name = extracted_data.get("supplier_name")

        if item_name and isinstance(quantity, (int, float)) and supplier_name:
            print(f"DEBUG_ORDER_CONFIRMATION: Received order confirmation for {quantity} {unit} of {item_name} from {supplier_name}.")
            
            supplier_phone_number = None
            supplier_item_cost_price = None

            # Find supplier details from SUPPLIERS dictionary
            for sup_name, sup_info in SUPPLIERS.items():
                if fuzz.ratio(supplier_name.lower(), sup_name.lower()) >= 80: # Fuzzy match for supplier name
                    supplier_phone_number = sup_info["phone"]
                    # Try to find cost price for the item from this supplier
                    for sup_item_name, item_details in sup_info["items"].items():
                        if fuzz.ratio(item_name.lower(), sup_item_name.lower()) >= 80 and unit.lower() == item_details["unit"].lower():
                            supplier_item_cost_price = item_details["price_per_unit"]
                            break
                    break

            if supplier_phone_number:
                call_initiated = await initiate_outbound_call(
                    to_number=supplier_phone_number,
                    item_name=item_name,
                    quantity=quantity,
                    unit=unit,
                    supplier_name=supplier_name,
                    user_id=sender_id,
                    detected_language="hi" # Force Hindi for outbound calls
                )

                if call_initiated:
                    reply_message = MESSAGES[detected_language]["call_initiated"].format(
                        item_name=item_name,
                        quantity=quantity,
                        unit=unit,
                        supplier_name=supplier_name,
                        supplier_phone_number=supplier_phone_number
                    )
                    await send_whatsapp_message(sender_id, reply_message)
                else:
                    print(f"ERROR: Failed to initiate call to {supplier_name} for {item_name}.")
                    reply_message = MESSAGES[detected_language]["order_failed_shopkeeper"].format(
                        item_name=item_name,
                        supplier_name=supplier_name,
                        reason="Failed to initiate call."
                    )
                    await send_whatsapp_message(sender_id, reply_message)
            else:
                reply_message = MESSAGES[detected_language]["item_not_found"].format(item_name=f"{item_name} (Supplier: {supplier_name})")
                await send_whatsapp_message(sender_id, reply_message)
        else:
            reply_message = MESSAGES[detected_language]["extract_fail"]
            await send_whatsapp_message(sender_id, reply_message)
    else:
        await send_whatsapp_message(sender_id, MESSAGES[detected_language]["extract_fail"])

async def check_low_stock_and_alert():
    print("DEBUG_SCHEDULER: Running low stock check...")
    try:
        response = await asyncio.to_thread(supabase.from_("stock_items").select("user_id").execute)
        if response.data:
            unique_user_ids = list(set([item['user_id'] for item in response.data]))
            print(f"DEBUG_SCHEDULER: Found unique user IDs: {unique_user_ids}")
        else:
            unique_user_ids = []
            print("DEBUG_SCHEDULER: No user IDs found in stock_items table.")

        for user_id in unique_user_ids:
            print(f"DEBUG_SCHEDULER: Checking low stock for user_id: {user_id}")
            low_stock_items = await get_low_stock_items(user_id)
            if low_stock_items:
                low_stock_messages = []
                print(f"DEBUG_SCHEDULER: Low stock items found for {user_id}: {low_stock_items}")
                for item in low_stock_items:
                    alert_item_name = item.get('item_name', 'Unknown Item')
                    alert_message_lang = 'hi' # Default to Hindi for now

                    # Define translated terms based on alert_message_lang
                    if alert_message_lang == 'hi':
                        min_text = "рдиреНрдпреВрдирддрдо"
                        cheapest_text = "рд╕рдмрд╕реЗ рд╕рд╕реНрддрд╛"
                        call_text = "рдХреЙрд▓"
                    else: # Default to English
                        min_text = "Min"
                        cheapest_text = "Cheapest"
                        call_text = "Call"

                    if bool(re.search(r'[a-zA-Z]', alert_item_name)) and alert_message_lang == 'hi':
                        alert_item_name = await _translate_text_to_target_language(alert_item_name, alert_message_lang)

                    supplier_info = await find_cheapest_supplier_for_item(alert_item_name, item['unit'])
                    supplier_details = ""
                    if supplier_info:
                        supplier_name = supplier_info["supplier_name"]
                        price = supplier_info["price_price_per_unit"]
                        supplier_phone = supplier_info["phone"]
                        supplier_details = f" ({cheapest_text}: {supplier_name}, тВ╣{price:.2f}/{item['unit']}, {call_text}: {supplier_phone})"

                    low_stock_messages.append(f"тАв {alert_item_name}: {item['quantity']} {item['unit']} ({min_text}: {item['min_quantity_threshold']} {item['unit']}){supplier_details}")
                
                alert_message = MESSAGES[alert_message_lang]["low_stock_alert"].format(
                    low_stock_items_list="\n".join(low_stock_messages))
                print(f"DEBUG_SCHEDULER: Prepared alert message for {user_id}: {alert_message}")
                await send_whatsapp_message(user_id, alert_message)
                print(f"DEBUG_SCHEDULER: Sent low stock alert to {user_id}.")
            else:
                print(f"DEBUG_SCHEDULER: No low stock items found for {user_id}.")
    except Exception as e:
        print(f"ERROR_SCHEDULER: Error during low stock check: {e}")

# Dictionary to store call states (e.g., conversation history, order details)
# In a production environment, this would be stored in a database.
call_states = {}

async def generate_speech_from_text(text: str, voice: str = "nova", model: str = "tts-1", is_ssml: bool = False) -> str:
    """Generates speech from text using OpenAI's TTS API and returns the audio file path."""
    try:
        # Ensure the audio directory exists
        audio_dir = "./audio"
        os.makedirs(audio_dir, exist_ok=True)

        # Generate a unique filename to avoid conflicts
        unique_id = f"{asyncio.current_task().get_name()}_{os.urandom(4).hex()}"
        speech_file_path = os.path.join(audio_dir, f"response_{unique_id}.mp3")

        input_text = text

        with client.audio.speech.with_streaming_response.create(
            model=model,
            voice=voice,
            input=input_text
        ) as response:
            response.stream_to_file(speech_file_path)
        print(f"DEBUG_TTS: Generated speech to {speech_file_path} (SSML: {is_ssml})")
        return speech_file_path
    except Exception as e:
        print(f"ERROR_TTS: Failed to generate speech from text '{text}': {e}")
        return "" # Return empty string on failure

async def transcribe_speech_from_url(audio_url: str) -> str:
    """Transcribes speech from an audio URL using OpenAI's Whisper API."""
    try:
        temp_audio_path = f"./temp_call_audio_{os.urandom(4).hex()}.wav"
        print(f"DEBUG_WHISPER: Downloading audio from {audio_url} to {temp_audio_path}")
        response = requests.get(audio_url, stream=True)
        response.raise_for_status()
        with open(temp_audio_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        print(f"DEBUG_WHISPER: Downloaded audio to {temp_audio_path}")

        with open(temp_audio_path, "rb") as audio_file:
            transcription = await asyncio.to_thread(
                client.audio.transcriptions.create,
                model="whisper-1",
                file=audio_file
            )
        os.remove(temp_audio_path)
        print(f"DEBUG_WHISPER: Transcription result: {transcription.text}")
        return transcription.text
    except Exception as e:
        print(f"ERROR_WHISPER: Failed to transcribe speech from {audio_url}: {e}")
        return ""

async def get_openai_response(conversation_history: list, temperature: float = 0.5, max_tokens: int = 150) -> str:
    """Gets a response from OpenAI's GPT model."""
    try:
        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo",
            messages=conversation_history,
            temperature=temperature,
            max_tokens=max_tokens
        )
        return response.choices[0].message.content
    except Exception as e:
        print(f"ERROR_OPENAI_RESPONSE: Failed to get OpenAI response: {e}")
        return "I'm sorry, I'm having trouble understanding right now. Please try again."

@app.route("/twilio_voice_webhook", methods=['POST'])
async def twilio_voice_webhook():
    voice_response = VoiceResponse()

    # Extract call context from URL parameters
    item_name = request.args.get("item_name")
    quantity = request.args.get("quantity")
    unit = request.args.get("unit")
    supplier_name = request.args.get("supplier_name")
    user_id = request.args.get("user_id")
    detected_language = request.args.get("detected_language")
    call_sid = request.form.get('CallSid')

    print(f"DEBUG_TWILIO_WEBHOOK: Received Twilio Voice webhook for CallSid: {call_sid}")
    print(f"DEBUG_TWILIO_WEBHOOK: Call context: item_name={item_name}, quantity={quantity}, unit={unit}, supplier_name={supplier_name}, user_id={user_id}, detected_language={detected_language}")

    # Initialize conversation history for this call_sid if it doesn't exist
    if call_sid not in call_states:
        call_states[call_sid] = {
            "conversation_history": [
                {"role": "system", "content": f"""
                You are a friendly, helpful, and polite AI assistant representing Gupta Kirana Store. 
                Your goal is to confirm orders, delivery times, and prices. 
                Speak naturally and politely in Hindi. Be concise and clear. 
                If you don't get all the details, explain what's missing and politely ask the supplier to confirm.
                
                Conversation flow:
                1. First say: 'рдирдорд╕реНрддреЗ, рдореИрдВ рдЧреБрдкреНрддрд╛ рдХрд┐рд░рд╛рдирд╛ рд╕реНрдЯреЛрд░ рд╕реЗ рд░рдорд╛ рдмрд╛рдд рдХрд░ рд░рд╣реА рд╣реВрдБред рдХреНрдпрд╛ рдореИрдВ {supplier_name} рд╕реЗ рдмрд╛рдд рдХрд░ рд╕рдХрддреА рд╣реВрдБ?'
                2. If the right person is on the line, ask: 'рдмрд╣реБрдд-рдмрд╣реБрдд рдзрдиреНрдпрд╡рд╛рджред рдореИрдВ рдЖрдкрдХреЛ {item_name} рдХреЗ рд╕реНрдЯреЙрдХ рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рдкреВрдЫрдиреЗ рдХреЗ рд▓рд┐рдП рдХреЙрд▓ рдХрд░ рд░рд╣реА рд╣реВрдБред'
                3. Then ask: 'рд╣рдорд╛рд░реЗ рдкрд╛рд╕ {item_name} рдХреА рдХрдореА рд╣реЛ рд░рд╣реА рд╣реИред рдХреНрдпрд╛ рдЖрдкрдХреЗ рдкрд╛рд╕ рдЕрднреА {quantity} {unit} {item_name} рдЙрдкрд▓рдмреНрдз рд╣реИ? рдФрд░ рдХреНрдпрд╛ рдЖрдк рдореБрдЭреЗ {item_name} рдХрд╛ рд╡рд░реНрддрдорд╛рди рдореВрд▓реНрдп рдкреНрд░рддрд┐ {unit} рдмрддрд╛ рд╕рдХрддреЗ рд╣реИрдВ?'
                4. If the item is available and price is confirmed, say: 'рдмрд╣реБрдд рдЕрдЪреНрдЫрд╛ред рдХреГрдкрдпрд╛ рд╣рдорд╛рд░реЗ рд▓рд┐рдП {quantity} {unit} {item_name} рдмреБрдХ рдХрд░ рджреЗрдВред рдХреНрдпрд╛ рдЖрдк рдбрд┐рд▓реАрд╡рд░реА рдХрд╛ рдЕрдиреБрдорд╛рдирд┐рдд рд╕рдордп рдмрддрд╛ рд╕рдХрддреЗ рд╣реИрдВ?'
                5. If item is not available or price is too high, say: 'рдареАрдХ рд╣реИ, рд╕рдордЭрдиреЗ рдХреЗ рд▓рд┐рдП рдзрдиреНрдпрд╡рд╛рджред рдореИрдВ рджреБрдХрд╛рди рдХреЗ рдорд╛рд▓рд┐рдХ рдХреЛ рд╕реВрдЪрд┐рдд рдХрд░ рджреВрдБрдЧреАред'
                6. If supplier confirms booking, say: 'рдмрд╣реБрдд-рдмрд╣реБрдд рдзрдиреНрдпрд╡рд╛рдж! рд╣рдо рдбрд┐рд▓реАрд╡рд░реА рдХрд╛ рдЗрдВрддрдЬрд╛рд░ рдХрд░реЗрдВрдЧреЗред рдирдорд╕реНрдХрд╛рд░ред'
                
                Important notes:
                - Only speak one or two sentences at a time
                - Wait for the supplier's response before continuing
                - Be natural and conversational
                - If you don't understand, politely ask for clarification
                - If there's silence, ask if they can hear you
                - If the call is breaking up, ask them to speak up or call back
                - Always be polite and professional
                """}
            ],
            "order_details": {
                "item_name": item_name,
                "quantity": quantity,
                "unit": unit,
                "supplier_name": supplier_name,
                "user_id": user_id,
                "detected_language": detected_language,
                "confirmed_price": None,
                "confirmed_delivery_time": None,
                "order_confirmed_status": False,
                "conversation_stage": "initial_greeting",
                "retry_count": 0
            }
        }
    
    # Get the current call state
    call_state = call_states[call_sid]
    
    # Only send the initial greeting if we're at the start of the conversation
    if call_state["order_details"]["conversation_stage"] == "initial_greeting":
        # First message to the supplier
        initial_message = MESSAGES[detected_language]["call_initiated"].format(
            supplier_name=supplier_name
        )
        call_state["conversation_history"].append({"role": "assistant", "content": initial_message})
        
        # Wrap the initial message in SSML to introduce a pause
        ssml_initial_message = f"<speak>{initial_message}<break time=\"1s\"/></speak>"
        speech_file_path = await generate_speech_from_text(ssml_initial_message, voice="nova", is_ssml=True)
        
        # Update conversation stage
        call_state["order_details"]["conversation_stage"] = "waiting_for_response"
    else:
        # This is a subsequent message in the conversation
        # Get the last assistant message to repeat it
        last_messages = [msg for msg in call_state["conversation_history"] if msg["role"] == "assistant"]
        if last_messages:
            last_message = last_messages[-1]["content"]
            speech_file_path = await generate_speech_from_text(f"<speak>{last_message}<break time=\"1s\"/></speak>", voice="nova", is_ssml=True)
    
    # Always include a gather to listen for the supplier's response
    if speech_file_path:
        audio_url = f"{BASE_URL}/audio/{os.path.basename(speech_file_path)}"
        voice_response.play(url=audio_url)
        print(f"DEBUG_TWILIO_WEBHOOK: Playing generated audio from {audio_url}")
    elif 'initial_message' in locals():
        print("ERROR_TWILIO_WEBHOOK: TTS generation failed. Falling back to <Say>.")
        voice_response.say(initial_message, voice='Polly.Aditi', language='hi-IN')
    
    # Add a small pause before gathering input
    voice_response.pause(length=1)
    
    # Gather speech from the supplier with increased timeout and better error handling
    gather_action_url = f"{BASE_URL}/handle_twilio_speech?call_sid={call_sid}"
    voice_response.gather(
        input='speech',
        timeout=10,  # Increased from 5 to 10 seconds
        speechTimeout='auto',
        action=gather_action_url,
        method='POST',
        actionOnEmptyResult=True,  # Important to handle cases where no speech is detected
        enhanced=True,  # Use enhanced speech recognition
        speechModel='phone_call',  # Optimize for phone call quality
        language='hi-IN'  # Specify Hindi language for better recognition
    )
    
    # If no input is received, redirect back to the same URL to try again
    query_string = request.query_string.decode()
    voice_response.redirect(
        method='POST',
        url=f"{BASE_URL}/twilio_voice_webhook?{query_string}"
    )
    
    print(f"DEBUG_TWILIO_WEBHOOK: TwiML response: {str(voice_response)}")
    return str(voice_response)

@app.route("/handle_twilio_speech", methods=['POST'])
async def handle_twilio_speech():
    voice_response = VoiceResponse()
    call_sid = request.args.get('call_sid')
    speech_result = request.form.get('SpeechResult')
    
    print(f"DEBUG_TWILIO_SPEECH: Received speech for CallSid: {call_sid}. SpeechResult: {speech_result}")

    if call_sid not in call_states:
        print(f"ERROR_TWILIO_SPEECH: Call SID {call_sid} not found in call_states")
        voice_response.say("Sorry, an application error occurred. Please call back later.", voice='Polly.Aditi', language='hi-IN')
        voice_response.hangup()
        return str(voice_response)

    current_call_state = call_states[call_sid]
    conversation_history = current_call_state["conversation_history"]
    order_details = current_call_state["order_details"]
    
    # Reset retry count if we got a response
    order_details['retry_count'] = 0
    
    # If no speech was detected, handle it gracefully
    if not speech_result or speech_result.strip() == '':
        print("WARNING_TWILIO_SPEECH: No speech detected or empty response")
        
        # Increment retry count
        order_details['retry_count'] = order_details.get('retry_count', 0) + 1
        
        # If we've retried too many times, end the call
        if order_details['retry_count'] > 2:
            response_text = "рдорд╛рдлрд╝ рдХреАрдЬрд┐рдП, рд╣рдо рдЖрдкрдХреЛ рд╕реБрди рдирд╣реАрдВ рдкрд╛ рд░рд╣реЗ рд╣реИрдВред рдХреГрдкрдпрд╛ рдмрд╛рдж рдореЗрдВ рдХреЙрд▓ рдХрд░реЗрдВред рдзрдиреНрдпрд╡рд╛рджред"
            voice_response.say(response_text, voice='Polly.Aditi', language='hi-IN')
            voice_response.hangup()
            return str(voice_response)
        
        # Otherwise, ask the supplier to speak again
        response_text = "рдорд╛рдлрд╝ рдХреАрдЬрд┐рдП, рдореИрдВрдиреЗ рдЖрдкрдХреЛ рд╕реНрдкрд╖реНрдЯ рд░реВрдк рд╕реЗ рдирд╣реАрдВ рд╕реБрдирд╛ред рдХреНрдпрд╛ рдЖрдк рдХреГрдкрдпрд╛ рдлрд┐рд░ рд╕реЗ рдмреЛрд▓ рд╕рдХрддреЗ рд╣реИрдВ?"
        conversation_history.append({"role": "assistant", "content": response_text})
        
        # Generate speech from text
        speech_file_path = await generate_speech_from_text(response_text, voice="nova")
        
        # Add the speech to the response
        if speech_file_path:
            audio_url = f"{BASE_URL}/audio/{os.path.basename(speech_file_path)}"
            voice_response.play(url=audio_url)
            print(f"DEBUG_TWILIO_SPEECH: Playing generated audio from {audio_url}")
        else:
            print("WARNING_TWILIO_SPEECH: TTS generation failed. Falling back to default TTS.")
            voice_response.say(response_text, voice='Polly.Aditi', language='hi-IN')
        
        # Add a small pause before next action
        voice_response.pause(length=1)
        
        if order_details.get("order_confirmed_status", False):
            # If order is confirmed, end the call gracefully
            voice_response.say("рдзрдиреНрдпрд╡рд╛рдж, рдЖрдкрдХрд╛ рджрд┐рди рд╢реБрдн рд╣реЛред", voice='Polly.Aditi', language='hi-IN')
            voice_response.hangup()
            # Clean up call state after a short delay
            async def cleanup_call_state():
                await asyncio.sleep(5)  # Wait for the call to end
                if call_sid in call_states:
                    del call_states[call_sid]
                    print(f"DEBUG_TWILIO_SPEECH: Cleaned up call state for {call_sid}")
            asyncio.create_task(cleanup_call_state())
            return str(voice_response)
        else:
            # Continue the conversation
            gather_action_url = f"{BASE_URL}/handle_twilio_speech?call_sid={call_sid}"
            voice_response.gather(
                input='speech',
                timeout=10,
                speechTimeout='auto',
                action=gather_action_url,
                method='POST',
                actionOnEmptyResult=True,
                enhanced=True,
                speechModel='phone_call',
                language='hi-IN'
            )
            # Add a redirect as a fallback in case gather fails
            redirect_params = {
                'item_name': order_details['item_name'],
                'quantity': order_details['quantity'],
                'unit': order_details['unit'],
                'supplier_name': order_details['supplier_name'],
                'user_id': order_details['user_id'],
                'detected_language': order_details['detected_language']
            }
            encoded_redirect = urllib.parse.urlencode(redirect_params)
            voice_response.redirect(
                method='POST',
                url=f"{BASE_URL}/twilio_voice_webhook?{encoded_redirect}"
            )
        return str(voice_response)

    # Process the speech result
    if speech_result:
        # Add user's speech to conversation history
        conversation_history.append({"role": "user", "content": speech_result})
        
        try:
            # Get response from OpenAI
            openai_response_text = await get_openai_response(conversation_history)
            text_to_speak = openai_response_text.strip()
            
            # Check for empty response
            if not text_to_speak:
                print("ERROR_TWILIO_SPEECH: OpenAI returned an empty response.")
                text_to_speak = "рдорд╛рдлрд╝ рдХреАрдЬрд┐рдП, рдХреБрдЫ рддрдХрдиреАрдХреА рд╕рдорд╕реНрдпрд╛ рдЖрдИ рд╣реИред рдХреГрдкрдпрд╛ рдереЛрдбрд╝реА рджреЗрд░ рдмрд╛рдж рдХреЛрд╢рд┐рд╢ рдХрд░реЗрдВред"
            
            # Add assistant's response to conversation history
            conversation_history.append({"role": "assistant", "content": text_to_speak})
            
            # Generate speech from text
            speech_file_path = await generate_speech_from_text(text_to_speak, voice="nova")
            
            # Check if this is an order confirmation
            confirmation_phrases = ["order confirmed", "confirmed the order", "рдмреБрдХ рдХрд░ рджреЗрдВ", "рд╣рд╛рдВ рдмреБрдХ рдХрд░ рджреЛ", 
                                 "рдареАрдХ рд╣реИ, рдмреБрдХ рдХрд░ рджреЛ", "рдбрд┐рд▓реАрд╡рд░реА рдХрд╛ рдЗрдВрддрдЬрд╛рд░ рдХрд░реЗрдВрдЧреЗ", "рдСрд░реНрдбрд░ рдХреА рдкреБрд╖реНрдЯрд┐ рд╣реЛ рдЧрдИ рд╣реИ"]
            order_confirmed = any(phrase in text_to_speak.lower() for phrase in confirmation_phrases)
            
            if order_confirmed:
                order_details["order_confirmed_status"] = True
                print("DEBUG_TWILIO_SPEECH: Detected order confirmation phrase.")
                
                # Send WhatsApp confirmation (in background, don't wait for it to complete)
                async def send_whatsapp_confirmation():
                    try:
                        print("DEBUG_TWILIO_SPEECH: Order confirmed. Sending WhatsApp...")
                        whatsapp_message = MESSAGES["hi"]["order_confirmed_shopkeeper"].format(
                            item_name=order_details["item_name"], 
                            quantity=order_details["quantity"], 
                            unit=order_details["unit"], 
                            supplier_name=order_details["supplier_name"]
                        )
                        await send_whatsapp_message(order_details["user_id"], whatsapp_message)
                        print("DEBUG_TWILIO_SPEECH: WhatsApp confirmation sent successfully")
                    except Exception as e:
                        print(f"ERROR_TWILIO_SPEECH: Failed to send WhatsApp: {str(e)}")
                        # If WhatsApp fails, we'll just log it and continue with the call
                
                # Start WhatsApp sending in the background
                asyncio.create_task(send_whatsapp_confirmation())
                
                # Ask for delivery time
                delivery_prompt = "рдХреГрдкрдпрд╛ рдбрд┐рд▓реАрд╡рд░реА рдХрд╛ рд╕рдордп рдмрддрд╛рдПрдВред рдХрд┐рддрдиреЗ рджрд┐рдиреЛрдВ рдореЗрдВ рдбрд┐рд▓реАрд╡рд░реА рд╣реЛ рд╕рдХрддреА рд╣реИ?"
                text_to_speak = f"{text_to_speak} {delivery_prompt}"
                speech_file_path = await generate_speech_from_text(text_to_speak, voice="nova")
                
                # Don't mark as confirmed yet, wait for delivery time confirmation
                order_confirmed = False
            
            # Add the speech to the response
            if speech_file_path:
                audio_url = f"{BASE_URL}/audio/{os.path.basename(speech_file_path)}"
                voice_response.play(url=audio_url)
                print(f"DEBUG_TWILIO_SPEECH: Playing generated audio from {audio_url}")
            else:
                print("WARNING_TWILIO_SPEECH: TTS generation failed. Falling back to default TTS.")
                voice_response.say(text_to_speak, voice='Polly.Aditi', language='hi-IN')
            
            # Add a small pause before next action
            voice_response.pause(length=1)
            
            if order_confirmed:
                # After getting delivery time, confirm and end the call
                voice_response.say("рдзрдиреНрдпрд╡рд╛рдж, рдЖрдкрдХрд╛ рдСрд░реНрдбрд░ рдХрдиреНрдлрд░реНрдо рд╣реЛ рдЧрдпрд╛ рд╣реИред рдЖрдкрдХреЛ рдПрдХ рдХрдиреНрдлрд░реНрдореЗрд╢рди рд╡реНрд╣рд╛рдЯреНрд╕рдПрдк рдкрд░ рднреЗрдЬ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред рдЖрдкрдХрд╛ рджрд┐рди рд╢реБрдн рд╣реЛред", 
                                 voice='Polly.Aditi', 
                                 language='hi-IN')
                voice_response.hangup()
                
                # Clean up call state after a short delay
                async def cleanup_call_state():
                    await asyncio.sleep(5)  # Wait for the call to end
                    if call_sid in call_states:
                        del call_states[call_sid]
                        print(f"DEBUG_TWILIO_SPEECH: Cleaned up call state for {call_sid}")
                
                asyncio.create_task(cleanup_call_state())
            else:
                # Continue the conversation
                gather_action_url = f"{BASE_URL}/handle_twilio_speech?call_sid={call_sid}"
                voice_response.gather(
                    input='speech',
                    timeout=10,
                    speechTimeout='auto',
                    action=gather_action_url,
                    method='POST',
                    actionOnEmptyResult=True,
                    enhanced=True,
                    speechModel='phone_call',
                    language='hi-IN'
                )
                
                # Add a redirect as a fallback in case gather fails
                params = {
                    'item_name': order_details['item_name'],
                    'quantity': order_details['quantity'],
                    'unit': order_details['unit'],
                    'supplier_name': order_details['supplier_name'],
                    'user_id': order_details['user_id'],
                    'detected_language': order_details['detected_language']
                }
                encoded_params = urllib.parse.urlencode(params)
                voice_response.redirect(
                    method='POST',
                    url=f"{BASE_URL}/twilio_voice_webhook?{encoded_params}"
                )
            
        except Exception as e:
            print(f"ERROR_TWILIO_SPEECH: Error processing OpenAI response: {str(e)}")
            error_msg = "рдорд╛рдлрд╝ рдХреАрдЬрд┐рдП, рдХреБрдЫ рддрдХрдиреАрдХреА рд╕рдорд╕реНрдпрд╛ рдЖрдИ рд╣реИред рдХреГрдкрдпрд╛ рдереЛрдбрд╝реА рджреЗрд░ рдмрд╛рдж рдХреЛрд╢рд┐рд╢ рдХрд░реЗрдВред"
            voice_response.say(error_msg, voice='Polly.Aditi', language='hi-IN')
            voice_response.hangup()
            
            # Clean up call state on error
            if call_sid in call_states:
                del call_states[call_sid]
                print(f"DEBUG_TWILIO_SPEECH: Call state cleaned up for {call_sid} due to error")
            if any(phrase in text_to_speak.lower() for phrase in confirmation_phrases):
                order_details["order_confirmed_status"] = True
                print("DEBUG_TWILIO_SPEECH: Detected order confirmation phrase.")
                
                # Send WhatsApp confirmation
                try:
                    print("DEBUG_TWILIO_SPEECH: Order confirmed. Sending WhatsApp and ending the call.")
                    whatsapp_message = MESSAGES["hi"]["order_confirmed_shopkeeper"].format(
                        item_name=order_details["item_name"], 
                        quantity=order_details["quantity"], 
                        unit=order_details["unit"], 
                        supplier_name=order_details["supplier_name"]
                    )
                    await send_whatsapp_message(order_details["user_id"], whatsapp_message)
                    
                    # Add confirmation to the response
                    text_to_speak += " рдЖрдкрдХреЛ рдПрдХ рдХрдиреНрдлрд░реНрдореЗрд╢рди рд╡реНрд╣рд╛рдЯреНрд╕рдПрдк рдкрд░ рднреЗрдЬ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред рдзрдиреНрдпрд╡рд╛рдж!"
                    speech_file_path = await generate_speech_from_text(text_to_speak, voice="nova")
                except Exception as e:
                    print(f"ERROR_TWILIO_SPEECH: Failed to send WhatsApp: {str(e)}")
                    text_to_speak += " рд▓реЗрдХрд┐рди рд╡реНрд╣рд╛рдЯреНрд╕рдПрдк рдХрдиреНрдлрд░реНрдореЗрд╢рди рднреЗрдЬрдиреЗ рдореЗрдВ рд╕рдорд╕реНрдпрд╛ рдЖрдИред рдХреГрдкрдпрд╛ рдореИрдиреНрдпреБрдЕрд▓ рд░реВрдк рд╕реЗ рдЪреЗрдХ рдХрд░реЗрдВред"

            speech_file_path = await generate_speech_from_text(text_to_speak, voice="nova")
            if speech_file_path:
                voice_response.play(url=f"{BASE_URL}/audio/{os.path.basename(speech_file_path)}")
            else:
                voice_response.say(text_to_speak, voice='Polly.Aditi', language='hi-IN')
            
            voice_response.hangup()
            if call_sid in call_states: 
                del call_states[call_sid]
            return str(voice_response)
            
    else: # No speech was detected by <Gather>
        text_to_speak = "рдорд╛рдлрд╝ рдХреАрдЬрд┐рдП, рдореБрдЭреЗ рдЖрдкрдХреА рдЖрд╡рд╛рдЬрд╝ рд╕реБрдирд╛рдИ рдирд╣реАрдВ рджреАред рдХреНрдпрд╛ рдЖрдк рджреЛрд╣рд░рд╛ рд╕рдХрддреЗ рд╣реИрдВ?"
        conversation_history.append({"role": "assistant", "content": text_to_speak})

    # --- This block now runs for ALL continuing conversation turns ---
    ssml_response = f"<speak>{text_to_speak}<break time=\"1s\"/></speak>"
    speech_file_path = await generate_speech_from_text(ssml_response, voice="nova", is_ssml=True)
    
    if speech_file_path:
        voice_response.play(url=f"{BASE_URL}/audio/{os.path.basename(speech_file_path)}")
    else:
        voice_response.say(text_to_speak, voice='Polly.Aditi', language='hi-IN')

    # *** FIX: Always re-gather to keep the conversation going ***
    action_url = f"{BASE_URL}/handle_twilio_speech?call_sid={call_sid}"
    voice_response.gather(input='speech', speechTimeout='auto', action=action_url, method='POST')
    
    print(f"DEBUG_TWILIO_SPEECH: TwiML response (Continue): {str(voice_response)}")
    return str(voice_response)


@app.route("/audio/<filename>")
def serve_audio(filename):
    print(f"DEBUG: Serving audio file: {filename}")
    try:
        return send_from_directory('audio', filename)
    except Exception as e:
        print(f"ERROR: Failed to serve audio file {filename}: {str(e)}")
        return ("Audio file not found", 404)

# Function to run the scheduler in its own event loop
def _run_scheduler():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.call_soon_threadsafe(scheduler.start)
    loop.run_forever()

# Shut down the scheduler when the Flask app stops
@app.teardown_appcontext
def shutdown_scheduler(exception=None):
    if scheduler.running:
        scheduler.shutdown()
        print("Scheduler for low stock alerts has been shut down.")

async def generate_local_insights():
    """Generates local insights and personalized recommendations for all shopkeepers with stock, including weather-based, festival-based, and low-stock alerts."""
    print("DEBUG_INSIGHTS: Generating local insights...")
    unique_user_ids_raw = await get_all_unique_user_ids_with_stock()
    unique_user_ids = unique_user_ids_raw # Corrected: unique_user_ids_raw already contains strings

    # Fetch global data once
    latitude = SHOPKEEPER_LOCATION["latitude"]
    longitude = SHOPKEEPER_LOCATION["longitude"]
    weather_data = await get_weather_forecast(latitude, longitude)
    festivals_data = await get_festivals_from_llm(days_in_advance=60) # Increased days_in_advance to 60 for more festivals

    for user_id in unique_user_ids:
        print(f"DEBUG_INSIGHTS: Generating insights for user: {user_id}")
        insights = []
        recommendations = []
        all_recommended_item_names = set() # To keep track of all recommended items

        stock_levels = await get_stock_levels(user_id)
        stock_map = {item['item_name'].lower(): item for item in stock_levels}

        # --- Weather-based Insights and Recommendations ---
        if weather_data:
            current_temp = weather_data["current"]["temperature_2m"]
            print(f"DEBUG_WEATHER: Current temperature: {current_temp}┬░C") # Added debug log for current temperature

            if current_temp > 30:
                insights.append("It's hot today!")

                # Get generic weather-based item suggestions from LLM
                generic_weather_recommendation_prompt = f"""Based on hot weather, suggest 2-3 popular items (not necessarily from any specific inventory) that a shopkeeper should promote. 
Respond as a comma-separated list of item names only, with no additional text."""
                llm_generic_weather_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests popular items based on weather conditions."},
                        {"role": "user", "content": generic_weather_recommendation_prompt}
                    ],
                    temperature=1.0,
                    max_tokens=100
                )
                generic_weather_recommended_items_str = llm_generic_weather_recommendation_response.choices[0].message.content.strip()
                print(f"DEBUG_LLM_RECOMMENDATION: LLM suggested generic items for hot weather: {generic_weather_recommended_items_str}")

                if generic_weather_recommended_items_str:
                    for item_name in [item.strip() for item in generic_weather_recommended_items_str.split(',')]:
                        all_recommended_item_names.add(item_name.lower())
                
                # Original inventory-specific recommendations (if still desired in primary recs)
                weather_recommendation_prompt = f"""Based on hot weather, suggest 2-3 specific items from the following inventory that a shopkeeper should promote. 
Inventory: {', '.join(stock_map.keys())}.
Respond as a comma-separated list of item names only, with no additional text. If no relevant items, respond with 'None'."""

                print(f"DEBUG_LLM_RECOMMENDATION: Prompt sent to LLM for hot weather: {weather_recommendation_prompt}") # Added logging for the prompt

                llm_weather_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests inventory items based on weather conditions."},
                        {"role": "user", "content": weather_recommendation_prompt}
                    ],
                    temperature=1.0, 
                    max_tokens=100
                )
                weather_recommended_items_str = llm_weather_recommendation_response.choices[0].message.content.strip()
                
                print(f"DEBUG_LLM_RECOMMENDATION: LLM recommended for hot weather: {weather_recommended_items_str}")

                if weather_recommended_items_str and weather_recommended_items_str.lower() != 'none':
                    weather_recommended_items_list = [item.strip().lower() for item in weather_recommended_items_str.split(',')]
                    found_weather_recommendations = False
                    for recommended_item_name in weather_recommended_items_list:
                        matched_item = next((item_name for item_name in stock_map if fuzz.token_sort_ratio(recommended_item_name, item_name) >= 70), None)
                        if matched_item:
                            item_details = stock_map[matched_item]
                            suggested_price = item_details.get("cost_price_per_unit", 0) * 1.20 # 20% markup for weather items
                            recommendations.append(f"Suggest selling {item_details['item_name']} for тВ╣{suggested_price:.2f} per {item_details['unit']} due to hot weather.")
                            # all_recommended_item_names.add(item_details['item_name'].lower()) # Already added above for generic
                            found_weather_recommendations = True
                    if not found_weather_recommendations:
                        # Ensure at least one recommendation is added for weather even if specific inventory items aren't matched
                        recommendations.append(f"Consider stocking popular items like {weather_recommended_items_str if weather_recommended_items_str else 'cold drinks and ice cream'} due to hot weather.")
                else:
                    recommendations.append("Consider stocking cold drinks and ice cream due to hot weather.")
                print("DEBUG_WEATHER_RECOMMENDATIONS_GENERATED: Weather-based recommendations added.") # Debug log

            elif current_temp < 15:
                insights.append("It's chilly!")

                # Get generic weather-based item suggestions from LLM
                generic_weather_recommendation_prompt = f"""Based on chilly weather, suggest 2-3 popular items (not necessarily from any specific inventory) that a shopkeeper should promote. 
Respond as a comma-separated list of item names only, with no additional text."""
                llm_generic_weather_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests popular items based on weather conditions."},
                        {"role": "user", "content": generic_weather_recommendation_prompt}
                    ],
                    temperature=1.0,
                    max_tokens=100
                )
                generic_weather_recommended_items_str = llm_generic_weather_recommendation_response.choices[0].message.content.strip()
                print(f"DEBUG_LLM_RECOMMENDATION: LLM suggested generic items for chilly weather: {generic_weather_recommended_items_str}")

                if generic_weather_recommended_items_str:
                    for item_name in [item.strip() for item in generic_weather_recommended_items_str.split(',')]:
                        all_recommended_item_names.add(item_name.lower())

                # Original inventory-specific recommendations (if still desired in primary recs)
                weather_recommendation_prompt = f"""Based on chilly weather, suggest 2-3 specific items from the following inventory that a shopkeeper should promote. 
Inventory: {', '.join(stock_map.keys())}.
Respond as a comma-separated list of item names only, with no additional text. If no relevant items, respond with 'None'."""

                print(f"DEBUG_LLM_RECOMMENDATION: Prompt sent to LLM for chilly weather: {weather_recommendation_prompt}") # Added logging for the prompt

                llm_weather_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests inventory items based on weather conditions."},
                        {"role": "user", "content": weather_recommendation_prompt}
                    ],
                    temperature=1.0, 
                    max_tokens=100
                )
                weather_recommended_items_str = llm_weather_recommendation_response.choices[0].message.content.strip()
                print(f"DEBUG_LLM_RECOMMENDATION: LLM recommended for chilly weather: {weather_recommended_items_str}")

                if weather_recommended_items_str and weather_recommended_items_str.lower() != 'none':
                    weather_recommended_items_list = [item.strip().lower() for item in weather_recommended_items_str.split(',')]
                    found_weather_recommendations = False
                    for recommended_item_name in weather_recommended_items_list:
                        matched_item = next((item_name for item_name in stock_map if fuzz.token_sort_ratio(recommended_item_name, item_name) >= 70), None)
                        if matched_item:
                            item_details = stock_map[matched_item]
                            suggested_price = item_details.get("cost_price_per_unit", 0) * 1.15 # 15% markup for weather items
                            recommendations.append(f"Suggest selling {item_details['item_name']} for тВ╣{suggested_price:.2f} per {item_details['unit']} due to chilly weather.")
                            # all_recommended_item_names.add(item_details['item_name'].lower()) # Already added above for generic
                            found_weather_recommendations = True
                    if not found_weather_recommendations:
                        # Ensure at least one recommendation is added for weather even if specific inventory items aren't matched
                        recommendations.append(f"Consider stocking popular items like {weather_recommended_items_str if weather_recommended_items_str else 'warm beverages and comfort food'} due to chilly weather.")
                else:
                    recommendations.append("Consider stocking warm beverages and comfort food due to chilly weather.")
                print("DEBUG_WEATHER_RECOMMENDATIONS_GENERATED: Weather-based recommendations added.") # Debug log

        # --- Festival-based Insights and Recommendations ---
        if festivals_data:
            for festival in festivals_data[:5]: # Limit to 5 festivals
                festival_name = festival.get("name")
                festival_date_info = festival.get("date", "")
                insights.append(f"Upcoming festival: {festival_name} (around {festival_date_info}).")

                # Get generic festival-based item suggestions from LLM
                generic_festival_recommendation_prompt = f"""For the upcoming festival '{festival_name}' (around {festival_date_info}), suggest 2-3 generic items (not necessarily from any specific inventory) that a shopkeeper should promote. 
Consider items that are commonly used as ingredients for sweets, special dishes, traditional offerings, or festive decorations during Indian festivals. 
Respond as a comma-separated list of item names only, with no additional text."""
                llm_generic_festival_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests popular items for Indian festivals."},
                        {"role": "user", "content": generic_festival_recommendation_prompt}
                    ],
                    temperature=1.0,
                    max_tokens=100
                )
                generic_festival_recommended_items_str = llm_generic_festival_recommendation_response.choices[0].message.content.strip()
                print(f"DEBUG_LLM_RECOMMENDATION: LLM suggested generic items for {festival_name}: {generic_festival_recommended_items_str}")

                if generic_festival_recommended_items_str:
                    for item_name in [item.strip() for item in generic_festival_recommended_items_str.split(',')]:
                        all_recommended_item_names.add(item_name.lower())

                # Original inventory-specific recommendations (if still desired in primary recs)
                inventory_items = ", ".join(stock_map.keys())
                recommendation_prompt = f"""For the upcoming festival '{festival_name}' (around {festival_date_info}), suggest 2-3 specific items from the following inventory that a shopkeeper should promote. 
Consider items that are commonly used as ingredients for sweets, special dishes, or other relevant preparations during Indian festivals.
Inventory: {inventory_items}.
Respond as a comma-separated list of item names only, with no additional text. If no relevant items, respond with 'None'."""
                
                print(f"DEBUG_LLM_RECOMMENDATION: Prompt sent to LLM for {festival_name}: {recommendation_prompt}") # Added logging for the prompt

                llm_recommendation_response = await asyncio.to_thread(
                    client.chat.completions.create,
                    model="gpt-3.5-turbo-0125", # Changed model
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant that suggests inventory items for festivals."},
                        {"role": "user", "content": recommendation_prompt}
                    ],
                    temperature=1.0, 
                    max_tokens=100
                )

                recommended_items_str = llm_recommendation_response.choices[0].message.content.strip()

                print(f"DEBUG_LLM_RECOMMENDATION: LLM recommended for {festival_name}: {recommended_items_str}")

                if recommended_items_str and recommended_items_str.lower() != 'none':
                    recommended_items_list = [item.strip().lower() for item in recommended_items_str.split(',')]
                    found_recommendations = False
                    for recommended_item_name in recommended_items_list:
                        matched_item = next((item_name for item_name in stock_map if fuzz.token_sort_ratio(recommended_item_name, item_name) >= 70), None)
                        if matched_item:
                            item_details = stock_map[matched_item]
                            suggested_price = item_details.get("cost_price_per_unit", 0) * 1.15 # 15% markup for festival items
                            recommendations.append(f"Promote {item_details['item_name']} for {festival_name} at тВ╣{suggested_price:.2f} per {item_details['unit']}.")
                            all_recommended_item_names.add(item_details['item_name'].lower())
                            found_recommendations = True
                    if not found_recommendations:
                        recommendations.append(f"Consider stocking items like {recommended_items_str} for the upcoming {festival_name}.")
                else:
                    recommendations.append(f"Consider stocking general festival items for the upcoming {festival_name}.")
        
        # --- Low Stock Alert (Integrated) ---
        critical_low_stock_items = []
        for item_name, item_details in stock_map.items():
            if item_details.get("quantity", 0) < item_details.get("min_quantity_threshold", 0):
                critical_low_stock_items.append(item_details)

        recommended_items_for_stocking_consideration = set()
        for recommended_item_name in all_recommended_item_names:
            recommended_items_for_stocking_consideration.add(recommended_item_name)
        
        low_stock_alert_message = ""
        low_stock_message_parts = []

        if critical_low_stock_items:
            print(f"DEBUG_INSIGHTS: Found critical low stock items for {user_id}: {critical_low_stock_items}")
            low_stock_message_parts.append("тЪая╕П **рдХрдо рд╕реНрдЯреЙрдХ рдЪреЗрддрд╛рд╡рдиреА!** рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рдЖрдЗрдЯрдо рдХрдо рд╣реЛ рд░рд╣реЗ рд╣реИрдВ:") # Bold for emphasis
            for item in critical_low_stock_items:
                item_name = item['item_name']
                quantity = item['quantity']
                unit = item['unit']
                min_threshold = item['min_quantity_threshold']

                cheapest_supplier_info = await find_cheapest_supplier_for_item(item_name, unit)
                supplier_details = ""
                if cheapest_supplier_info:
                    supplier_name = cheapest_supplier_info["supplier_name"]
                    price = cheapest_supplier_info["price_per_unit"]
                    supplier_phone = cheapest_supplier_info["phone"]
                    supplier_details = f" (рд╕рдмрд╕реЗ рд╕рд╕реНрддрд╛: {supplier_name}, тВ╣{price:.2f}/{unit}, рдХреЙрд▓: {supplier_phone})"
                low_stock_message_parts.append(f"тАв {item_name}: {quantity} {unit} (рдиреНрдпреВрдирддрдо: {min_threshold} {unit}){supplier_details}")
            low_stock_message_parts.append("рдЬрд▓реНрдж рд╣реА рдСрд░реНрдбрд░ рдХрд░рдиреЗ рдкрд░ рд╡рд┐рдЪрд╛рд░ рдХрд░реЗрдВред") # Closing sentence
        
        if recommended_items_for_stocking_consideration:
            if low_stock_message_parts: # Add a separator if there are critical low stock items
                low_stock_message_parts.append("\n") 
            low_stock_message_parts.append("тЬи **рд╡рд┐рдЪрд╛рд░ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдЕрдиреБрд╢рдВрд╕рд┐рдд рдЖрдЗрдЯрдо:**") # New section title
            
            # Prioritize items not in stock, then add other recommended items, limit to 5
            not_in_stock_items = []
            in_stock_items = []
            for rec_item_name in recommended_items_for_stocking_consideration:
                if rec_item_name in stock_map:
                    item_details = stock_map[rec_item_name]
                    if item_details.get("quantity", 0) <= 0: # Treat zero quantity as not in stock for recommendation purposes
                        not_in_stock_items.append(rec_item_name)
                    else:
                        in_stock_items.append(rec_item_name)
                else:
                    not_in_stock_items.append(rec_item_name)
            
            # Combine and limit the list
            final_recommended_items = not_in_stock_items + in_stock_items
            for rec_item_name in final_recommended_items[:5]: # Limit to 5 items
                if rec_item_name in stock_map:
                    item_details = stock_map[rec_item_name]
                    status = "(рдЖрдкрдХреЗ рд╕реНрдЯреЙрдХ рдореЗрдВ)" if item_details.get("quantity", 0) > 0 else "(рд╕реНрдЯреЙрдХ рдореЗрдВ рдирд╣реАрдВ/рдХрдо)"
                    low_stock_message_parts.append(f"тАв {item_details['item_name']} {status}")
                else:
                    low_stock_message_parts.append(f"тАв {rec_item_name} (рдЖрдкрдХреЗ рд╕реНрдЯреЙрдХ рдореЗрдВ рдирд╣реАрдВ)")

        if low_stock_message_parts:
            low_stock_alert_message = "\n".join(low_stock_message_parts)

        # --- Construct and Send Final Message ---
        final_message_parts = []
        if insights:
            final_message_parts.append("--- Local Insights ---")
            final_message_parts.extend([f"- {insight}" for insight in insights])
        if recommendations:
            final_message_parts.append("\n--- Recommendations for you ---")
            final_message_parts.extend([f"- {rec}" for rec in recommendations])
        
        # Append low stock alert after insights and recommendations
        if low_stock_alert_message:
            if final_message_parts: # Add a separator if there are previous messages
                final_message_parts.append("\n") 
            final_message_parts.append("--- Stocking Suggestions ---") # Changed section title
            final_message_parts.append(low_stock_alert_message)

        final_message_body = "\n".join(final_message_parts)

        if final_message_body:
            await send_whatsapp_message(user_id, final_message_body)
        else:
            print(f"DEBUG_INSIGHTS: No specific local insights or recommendations generated for {user_id} at this time.")

if __name__ == "__main__":
    # Initialize and start the scheduler when the app starts
    if not scheduler.running:
        scheduler.add_job(generate_local_insights, 'interval', seconds=30)
        # Removed the low stock alert scheduler job
        # scheduler.add_job(check_low_stock_and_alert, 'interval', seconds=30, id='check_low_stock_and_alert', replace_existing=True)
        scheduler_thread = Thread(target=_run_scheduler)
        scheduler_thread.daemon = True
        scheduler_thread.start()
        print("Scheduler for low stock alerts has been started in a separate thread.")

    # Run the Flask app
    # Using debug=True is helpful for development as it provides detailed errors
    # and automatically reloads the server when you make code changes.
    # Make sure to set debug=False for a production environment.
    app.run(debug=True, host="0.0.0.0", port=5000)